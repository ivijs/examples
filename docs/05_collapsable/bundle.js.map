{"version":3,"sources":["node_modules/ivi/src/common/dev_mode.ts"," [synthetic:es6/util/inherits] "," [synthetic:util/global] "," [synthetic:util/defineproperty] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/polyfill] "," [synthetic:es6/array/fill] "," [synthetic:util/owns] "," [synthetic:es6/weakmap] "," [synthetic:es6/map] "," [synthetic:es6/string/repeat] "," [synthetic:util/checkstringargs] ","node_modules/ivi/src/common/feature_detection.ts","node_modules/ivi/src/common/user_agent.ts","node_modules/ivi/src/common/noop.ts","node_modules/ivi/src/events/utils.ts","node_modules/ivi/src/common/screen_of_death.ts","node_modules/ivi/src/vdom/vnode_builder.ts","src/05_collapsable/main.ts","node_modules/ivi/src/vdom/context.ts","node_modules/ivi/src/vdom/sync_dom.ts","node_modules/ivi/src/common/dom.ts","node_modules/ivi/src/events/sync_events.ts","node_modules/ivi/src/vdom/implementation.ts","node_modules/ivi/src/scheduler/scheduler.ts","node_modules/ivi/src/events/event_dispatcher.ts","node_modules/ivi/src/events/dispatch_event.ts","node_modules/ivi/src/events/native_event_dispatcher.ts","node_modules/ivi/src/events/traverse_dom.ts","node_modules/ivi/src/events/synthetic_event.ts","node_modules/ivi/src/events/events.ts","node_modules/ivi/src/vdom/component.ts","node_modules/ivi/src/vdom/root.ts"," [synthetic:es6/util/arrayfromiterable] "],"names":["$jscomp.global","$jscomp.defineProperty","$jscomp.initSymbol","$jscomp.global.Symbol","$jscomp.Symbol","$jscomp.symbolCounter_","$jscomp.SYMBOL_PREFIX","$jscomp.global.Symbol.iterator","$jscomp.arrayIterator","$jscomp.initSymbolIterator","$jscomp.iteratorPrototype","$jscomp.polyfill","$jscomp.makeIterator","$jscomp.owns","FEATURES","opts","Object","defineProperty","get","window","addEventListener","e","USER_AGENT","test","navigator","ua","userAgent","MSStream","NOOP","getEventTarget","ev","target","correspondingUseElement","nodeType","parentNode","EVENT_CAPTURE_PASSIVE_OPTIONS","EVENT_PASSIVE_OPTIONS","getEventOptions","flags","screenOfDeathElement","bodyMargin","bodyPadding","injectScreenOfDeath","title","content","document","body","style","margin","padding","createElement","zIndex","backgroundColor","position","width","height","boxSizing","innerHTML","color","className","removeChild","undefined","appendChild","screenOfDeathErrorHandler","error","message","stack","constructor","VNodeBuilder","tag","props","children","_flags","_tag","_key","_props","_className","_events","_style","_children","_ref","_dom","VNodeBuilder.prototype","?.prototype","key","Array","isArray","i","length","n","result","slice","_normalizeVNodes","$t","value","checked","$h","tagName","cloneVNode","node","newChildren","newNode","nodes","push","Context","data","from","v","keys","l","k","ROOT_CONTEXT","syncClassName","b","setAttribute","syncStyle","a","cssText","matchCount","bValue","aValue","hasOwnProperty","setDOMProperty","volume","removeAttribute","charCodeAt","setAttributeNS","XML_NAMESPACE","XLINK_NAMESPACE","syncDOMProps","syncEvents","registerHandler","handler","dispatcher","unregisterHandler","aHandler","bHandler","events","_updateComponent","component","ref","_rootDOMNode","oldRoot","root","componentUpdateContext","_parentDOMNode","newRoot","componentClassRender","vNodeSyncOrReplace","_context","vNodePropagateNewContext","_updateComponentFunction","parent","context","owner","fn","vNodeMount","vnode","vNodeUnmount","vNodeUnmountAll","vnodes","_parentContext","vNodeRemoveChild","render","vNodeRender","createTextNode","type","createElementNS","SVG_NAMESPACE","textContent","insertBefore","input","vNodeRenderInto","container","refChild","vNodeCanSync","vNodeSync","nodeValue","bParentFlags","aParentFlags","c","firstChild","aStart","bStart","aEnd","bEnd","aStartNode","bStartNode","aEndNode","bEndNode","aNode","bNode","nextPos","next","aLength","bLength","sources","fill","moved","pos","synced","j","keyIndex","Map","set","p","il","u","newProps","newRef","replaceChild","FrameTasksGroup","_componentTasks","_afterTasks","_readTasks","_writeTasks","write","callback","read","clock","microtasks","macrotasks","currentFrame","nextFrame","updateComponents","microtaskNode","macrotaskMessage","Math","random","observe","microtaskObserver","MutationObserver","runMicrotasks","scheduler.microtaskNode","characterData","handleWindowMessage","requestNextFrame","scheduler.flags","requestAnimationFrame","handleNextFrame","source","scheduler.macrotaskMessage","tasks","scheduler.macrotasks","scheduler.clock","frame","scheduler.nextFrame","scheduler.currentFrame","scheduler.updateComponents.length","scheduler.updateComponents","componentGroups","componentGroup","scheduler.updateComponents.pop","pop","scheduler.microtasks.length","scheduler.microtasks","scheduleMacrotask","task","postMessage","scheduler.macrotasks.push","EventDispatcher","counter","dependents","dependencies","dispatch","activate","registerDispatcher","deactivate","unregisterDispatcher","indexOf","dispatchEventToLocalEventHandlers","dispatchTarget","event","matchFlags","currentTarget","handlers","NativeEventDispatcher","name","eventType","_dispatch","bind","_deactivating","$jscomp.inherits","deps","matches","parentElement","s","bubble","dispatchEventsToDependents","removeEventListener","SyntheticEvent","_data","stopPropagation","stopImmediatePropagation","preventDefault","$jscomp.global.Object.defineProperties","defaultPrevented","bubbles","cancelable","isTrusted","eventPhase","SyntheticDOMEvent","timeStamp","AT_TARGET","BUBBLING_PHASE","CAPTURING_PHASE","SyntheticUIEvent","detail","view","SyntheticMouseEvent","getModifierState","keyArg","altKey","button","buttons","clientX","clientY","ctrlKey","fromElement","layerX","layerY","metaKey","movementX","movementY","offsetX","offsetY","pageX","pageY","relatedTarget","screenX","screenY","shiftKey","toElement","which","x","y","click","Component","depth","roots","Collapsable","arguments","$jscomp.arrayFromIterator","collapsed","onClick","NativeEventDispatchers.click","invalidate","dirtyFlags","updateComponent","priority","group","child","prototype","getElementById","r","vNode","domNode","onclick","last"],"mappings":"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","file":"bundle.js","sourceRoot":"../..","sourcesContent":["/**\n * Development Mode.\n *\n * Development Mode is enabled when global variable `__IVI_DEV__` is `true`.\n */\n\ndeclare global {\n    /* tslint:disable:no-unused-variable */\n    /**\n     * Global variable that enables Development Mode.\n     *\n     * @define {boolean}\n     */\n    const __IVI_DEV__: boolean;\n    /* tslint:enable:no-unused-variable */\n}\n\n/**\n * Dev Mode Flags.\n *\n * `setDevModeFlags` function is used to set Dev Mode flags.\n */\nexport const enum DevModeFlags {\n    /**\n     * Disable Nesting Validation.\n     */\n    DisableNestingValidation = 1,\n    /**\n     * Disable Stack Trace Augmentation.\n     */\n    DisableStackTraceAugmentation = 1 << 1,\n    /**\n     * Disable Screen of Death.\n     */\n    DisableScreenOfDeath = 1 << 2,\n    /**\n     * Disable global `window.addEventListener(\"error\", ...)` error handler.\n     */\n    DisableScreenOfDeathGlobalErrorHandling = 1 << 3,\n}\n\n/**\n * Dev Mode Flags. See `DevModeFlags` for details.\n */\nexport let DEV_MODE: DevModeFlags = 0;\n\nexport function setDevModeFlags(flags: DevModeFlags): void {\n    DEV_MODE |= flags;\n}\n\n/**\n * Print error to the console and throw local exception.\n *\n * Local exception is thrown so that we can break on caught errors.\n *\n * @param message Error message.\n */\nexport function printError(message: string): void {\n    console.error(message);\n    try {\n        throw new Error(message);\n    } catch (_) {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,"/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n *\n * NOTE: Do not implement feature detection for features that aren't used in `ivi` library.\n */\n\n/**\n * Feature Flags.\n */\nexport const enum FeatureFlags {\n    /**\n     * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n     * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n     * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n     *\n     * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n     */\n    PassiveEvents = 1,\n}\n\n/**\n * Supported Features, see `FeatureFlags` for details.\n */\nexport let FEATURES: FeatureFlags = 0;\n\n/**\n * Passive Events:\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n */\ntry {\n    // Test via a getter in the options object to see if the passive property is accessed\n    const opts = Object.defineProperty({}, \"passive\", {\n        get: function () {\n            FEATURES |= FeatureFlags.PassiveEvents;\n        },\n    });\n    window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n} catch (e) {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n}\n","/**\n * User Agent detection is used to fix some quirks like iOS event bubbling, etc.\n *\n * NOTE: Do not implement any browser detection that aren't used in `ivi` library.\n */\n\nconst ua = navigator ? navigator.userAgent : \"\";\n\n/**\n * User Agent Flags.\n */\nexport const enum UserAgentFlags {\n    /**\n     * iOS browser (iPad, iPhone, iPod).\n     */\n    iOS = 1,\n};\n\n/**\n * User Agent, see `UserAgentFlags` for details.\n */\nexport let USER_AGENT: UserAgentFlags = 0;\n\nif (/iPad|iPhone|iPod/.test(ua) && !(window as any).MSStream) {\n    USER_AGENT |= UserAgentFlags.iOS;\n}\n","\n/**\n * NOOP function.\n */\nexport function NOOP() {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n}\n","import { FEATURES, FeatureFlags } from \"../common/feature_detection\";\nimport { NativeEventDispatcherFlags } from \"./flags\";\nimport { EventHandlerList } from \"./event_handler\";\n\n/**\n * Gets the target node from a native Event.\n *\n * @param ev Native DOM Event.\n * @returns Target Node.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n    let target = ev.target || window;\n\n    /**\n     * Fix for `SVGUseElement` in old browsers.\n     */\n    if ((target as any).correspondingUseElement) {\n        target = (target as any).correspondingUseElement;\n    }\n\n    /**\n     * Safari fires events on Text Nodes.\n     *\n     * http://www.quirksmode.org/js/events_properties.html\n     */\n    return (target as Node).nodeType === 3 ? (target as Node).parentNode! : target;\n}\n\n/**\n * `{ capture: true, passive: true }` object that should be used as a third parameter in `addEventListener`.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS =\n    (FEATURES & FeatureFlags.PassiveEvents) ?\n        { \"capture\": true, \"passive\": true } :\n        true;\n\n/**\n * `{ passive: true }` object that should be used as a third parameter in `addEventListener`.\n */\nexport const EVENT_PASSIVE_OPTIONS =\n    (FEATURES & FeatureFlags.PassiveEvents) ?\n        { \"passive\": true } :\n        false;\n\n/**\n * Get Event options that should be used when adding Event Listener.\n *\n * @param flags See `EventDispatcherFlags` for details.\n * @returns Option object that can be used as a 3rd parameter in `addEventListener` call.\n */\nexport function getEventOptions(flags: NativeEventDispatcherFlags): boolean | { capture?: boolean, passive?: boolean } {\n    if (flags & NativeEventDispatcherFlags.Passive) {\n        if (flags & NativeEventDispatcherFlags.Capture) {\n            return EVENT_CAPTURE_PASSIVE_OPTIONS;\n        }\n        return EVENT_PASSIVE_OPTIONS;\n    }\n    if (flags & NativeEventDispatcherFlags.Capture) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Property that is used on DOM Nodes to store EventProps object.\n */\nexport const DOM_NODE_EVENTS_PROPERTY = \"_ev\";\n\n/**\n * Set Event Handler list to DOM Node.\n *\n * @param node DOM Node.\n * @param events Event Handler List.\n */\nexport function setEventHandlerListToDOMNode(node: Node, events: EventHandlerList | undefined): void {\n    (node as any)[DOM_NODE_EVENTS_PROPERTY] = events;\n}\n\n/**\n * Get Event Handler list from DOM Node.\n *\n * @param node DOM Node.\n * @returns EventHandlerList or undefined if DOM Node doesn't listen for any events.\n */\nexport function getEventHandlerListFromDOMNode(node: Node): EventHandlerList | undefined {\n    return (node as any)[DOM_NODE_EVENTS_PROPERTY];\n}\n","/**\n * Screen of Death.\n *\n * When exception is thrown, inject Screen of Death into document.\n *\n * To disable Screen of Death, set Dev Mode `DisableScreenOfDeath` flag with a function\n * `setDevModeFlags(DevModeFlags.DisableScreenOfDeath)`.\n */\nimport { DevModeFlags, DEV_MODE } from \"./dev_mode\";\nimport { getEventTarget } from \"../events/utils\";\n\n/**\n * Screen of Death Element.\n */\nlet screenOfDeathElement: HTMLDivElement | undefined;\n\n/**\n * Store original body margin when Screen of Death is injected.\n */\nlet bodyMargin: string | null;\n/**\n * Store original body padding when Screen of Death is injected.\n */\nlet bodyPadding: string | null;\n\n/**\n * Inject Screen of Death into document.\n *\n * @param title Title.\n * @param content Content.\n */\nexport function injectScreenOfDeath(title: string, content: string): void {\n    if (!screenOfDeathElement) {\n        // Save original body margin and padding.\n        bodyMargin = document.body.style.margin;\n        bodyPadding = document.body.style.padding;\n\n        // Remove body margin and padding.\n        document.body.style.margin = \"0\";\n        document.body.style.padding = \"0\";\n\n        // Inject Screen of Death.\n        screenOfDeathElement = document.createElement(\"div\");\n        const style = screenOfDeathElement.style;\n        style.zIndex = \"2147483647\";\n        style.backgroundColor = \"#600\";\n        style.position = \"absolute\";\n        style.width = \"100%\";\n        style.height = \"100%\";\n        style.boxSizing = \"border-box\";\n        style.padding = \"1em\";\n        screenOfDeathElement.innerHTML = `` +\n            `<div style=\"color:#fff;font-family:monospace;font-weight:bold;font-size:2em;line-height:2em\">` +\n            `${title}</div>` +\n            `<pre style=\"color:#fff;font-weight:bold;font-size:1.2em\">${content}</pre>` +\n            `<div` +\n            ` style=\"position:absolute;top:0;right:0;padding:1em;color:#fff;cursor:pointer;` +\n            `font-size:2em;line-height:1em;font-weight:bold\"` +\n            ` class=\"ivi-screen-of-death-close\">x</div>`;\n        screenOfDeathElement.style.color = \"#fff\";\n        screenOfDeathElement.addEventListener(\"click\", (ev) => {\n            if ((getEventTarget(ev) as Element).className === \"ivi-screen-of-death-close\") {\n                removeScreenOfDeath();\n            }\n        });\n        document.body.appendChild(screenOfDeathElement);\n    }\n}\n\n/**\n * Remove Screen of Death.\n */\nfunction removeScreenOfDeath(): void {\n    if (screenOfDeathElement) {\n        // Restore original body margin and padding.\n        document.body.style.margin = bodyMargin;\n        document.body.style.padding = bodyPadding;\n\n        // Remove Screen of Death.\n        document.body.removeChild(screenOfDeathElement);\n        screenOfDeathElement = undefined;\n    }\n}\n\nif (!(DEV_MODE & (DevModeFlags.DisableScreenOfDeath | DevModeFlags.DisableScreenOfDeathGlobalErrorHandling))) {\n    window.addEventListener(\"error\", function screenOfDeathErrorHandler(e: ErrorEvent) {\n        injectScreenOfDeath(`Global Error: ${e.error.message}`, e.error.stack);\n    });\n}\n","import { VNode } from \"./vnode\";\nimport { VNodeFlags } from \"./flags\";\nimport { ComponentFunction, ComponentClass, Component } from \"./component\";\nimport { EventHandlerList } from \"../events/event_handler\";\nimport {\n    HTMLAnchorElementProps, HTMLElementProps, HTMLAppletElementProps, HTMLAreaElementProps, HTMLAudioElementProps,\n    HTMLBaseElementProps, HTMLBaseFontElementProps, HTMLBodyElementProps, HTMLBRElementProps, HTMLButtonElementProps,\n    HTMLCanvasElementProps, HTMLQuoteElementProps, HTMLTableCaptionElementProps, HTMLTableColElementProps,\n    HTMLDataListElementProps, HTMLModElementProps, HTMLDirectoryElementProps, HTMLDivElementProps,\n    HTMLDListElementProps, HTMLEmbedElementProps, HTMLFieldSetElementProps, HTMLFontElementProps, HTMLFormElementProps,\n    HTMLFrameElementProps, HTMLFrameSetElementProps, HTMLHeadElementProps, HTMLHeadingElementProps, HTMLHRElementProps,\n    HTMLHtmlElementProps, HTMLIFrameElementProps, HTMLImageElementProps, HTMLInputElementProps, HTMLLabelElementProps,\n    HTMLLegendElementProps, HTMLLIElementProps, HTMLLinkElementProps, HTMLMapElementProps, HTMLMarqueeElementProps,\n    HTMLMenuElementProps, HTMLMetaElementProps, HTMLMeterElementProps, HTMLObjectElementProps, HTMLOListElementProps,\n    HTMLOptGroupElementProps, HTMLOptionElementProps, HTMLParagraphElementProps, HTMLParamElementProps,\n    HTMLPictureElementProps, HTMLPreElementProps, HTMLProgressElementProps, HTMLScriptElementProps,\n    HTMLSelectElementProps, HTMLSourceElementProps, HTMLSpanElementProps, HTMLStyleElementProps,\n    HTMLTableDataCellElementProps, HTMLTableElementProps, HTMLTableHeaderCellElementProps, HTMLTableRowElementProps,\n    HTMLTableSectionElementProps, HTMLTemplateElementProps, HTMLTextAreaElementProps, HTMLTitleElementProps,\n    HTMLTrackElementProps, HTMLUListElementProps, HTMLUnknownElementProps, HTMLVideoElementProps, HTMLMediaElementProps,\n    MSHTMLWebViewElementProps,\n\n    SVGCircleElementProps, SVGClipPathElementProps, SVGDefsElementProps, SVGDescElementProps, SVGEllipseElementProps,\n    SVGFEBlendElementProps, SVGFEColorMatrixElementProps, SVGFEComponentTransferElementProps,\n    SVGFECompositeElementProps, SVGFEConvolveMatrixElementProps, SVGFEDiffuseLightingElementProps,\n    SVGFEDisplacementMapElementProps, SVGFEDistantLightElementProps, SVGFEFloodElementProps, SVGFEFuncAElementProps,\n    SVGFEFuncBElementProps, SVGFEFuncGElementProps, SVGFEFuncRElementProps, SVGFEGaussianBlurElementProps,\n    SVGFEImageElementProps, SVGFEMergeElementProps, SVGFEMergeNodeElementProps, SVGFEMorphologyElementProps,\n    SVGFEOffsetElementProps, SVGFEPointLightElementProps, SVGFESpecularLightingElementProps, SVGFESpotLightElementProps,\n    SVGFETileElementProps, SVGFETurbulenceElementProps, SVGFilterElementProps, SVGForeignObjectElementProps,\n    SVGGElementProps, SVGImageElementProps, SVGLinearGradientElementProps, SVGLineElementProps, SVGMarkerElementProps,\n    SVGMaskElementProps, SVGMetadataElementProps, SVGPathElementProps, SVGPatternElementProps, SVGPolygonElementProps,\n    SVGPolylineElementProps, SVGRadialGradientElementProps, SVGRectElementProps, SVGStopElementProps,\n    SVGSVGElementProps, SVGSwitchElementProps, SVGSymbolElementProps, SVGTextElementProps, SVGTextPathElementProps,\n    SVGTSpanElementProps, SVGViewElementProps, SVGUseElementProps, SVGElementProps,\n\n    CSSStyleProps,\n} from \"./dom_props\";\n\n/**\n * VNode Builder provides a chain-method API to build VNodes.\n *\n * VNodeBuilder class has a parametric type `P` to specify `props` type.\n *\n *     const vnode = $h(\"div\", \"div-class-name\")\n *         .props({ id: \"div-id\" })\n *         .events({ click: Events.onClick((e) => console.log(\"click event\", e)) })\n *         .children(\"Hello\");\n *\n * There are several factory functions that create VNode Builder objects:\n *\n *     // Basic HTML Elements\n *     $h(tagName: string, className?: string): VNodeBuilder<HTMLElementProps | null>;\n *\n *     // SVG Elements\n *     $s(tagName: string, className?: string): VNodeBuilder<SVGElementProps | null>;\n *\n *     // Components\n *     $c<P>(component: ComponentClass<P> | ComponentFunction<P>, props: P): VNodeBuilder<P>;\n *\n *     // Input Elements and TextArea (specifying type as \"textarea\" will create HTMLTextAreaElement)\n *     $i(type: string, className?: string): VNodeBuilder<HTMLInputElementProps | HTMLTextAreaElementProps | null>;\n *\n *     // Media Elements (Video and Audio)\n *     $m(tagName: string, className?: string): VNodeBuilder<HTMLMediaElementProps | null>;\n *\n *     // Text Nodes\n *     $t(text: string): VNodeBuilder<null>;\n *\n * @final\n */\nexport class VNodeBuilder<P> implements VNode<P> {\n    _flags: VNodeFlags;\n    _tag: string | ComponentClass<any> | ComponentFunction<any> | null;\n    _key: any;\n    _props: P | null;\n    _className: string | null;\n    _style: CSSStyleProps | string | null;\n    _events: EventHandlerList | null;\n    _children: VNode<any>[] | VNode<any> | string | number | boolean | Component<any> | null | undefined;\n    _dom: Node | null;\n    _ref: ((ref: Node | Component<any> | null) => void) | null;\n\n    constructor(\n        flags: number,\n        tag: string | ComponentFunction<P> | ComponentClass<P> | null,\n        props: P | null,\n        className: string | null,\n        children: VNode<any>[] | VNode<any> | string | number | boolean | Component<any> | null | undefined,\n    ) {\n        this._flags = flags;\n        this._tag = tag;\n        this._key = null;\n        this._props = props;\n        this._className = className;\n        this._style = null;\n        this._events = null;\n        this._children = children;\n        this._dom = null;\n        this._ref = null;\n    }\n\n    /**\n     * Set key.\n     *\n     * Children reconciliation algorithm is using key property to find the same node in the previous children array. Key\n     * should be unique among its siblings.\n     *\n     * @param key Any object that should be unique among its siblings.\n     * @returns VNodeBuilder.\n     */\n    key(key: any): VNodeBuilder<P> {\n        this._key = key;\n        return this;\n    }\n\n    /**\n     * Set className.\n     *\n     * @param className.\n     * @returns VNodeBuilder.\n     */\n    className(className: string | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set className on VNode: className method should be called on element \" +\n                    \"nodes only.\");\n            }\n        }\n        this._className = className;\n        return this;\n    }\n\n    /**\n     * Set style.\n     *\n     * @param style.\n     * @returns VNodeBuilder.\n     */\n    style(style: CSSStyleProps | string | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set style on VNode: style method should be called on element nodes only.\");\n            }\n        }\n        this._style = style;\n        return this;\n    }\n\n    /**\n     * Set events.\n     *\n     * @param events.\n     * @returns VNodeBuilder.\n     */\n    events(events: EventHandlerList | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set events on VNode: event method should be called on element nodes only.\");\n            }\n        }\n        this._events = events;\n        return this;\n    }\n\n    /**\n     * Set props.\n     *\n     * @param props.\n     * @returns VNodeBuilder.\n     */\n    props(props: P): VNodeBuilder<P> {\n        this._props = props;\n        return this;\n    }\n\n    /**\n     * Set children.\n     *\n     * @param children Children can be a simple string, single VNode or recursive list of VNodes with strings and null\n     *   values. It will automatically normalize recursive lists by flattening, filtering out null values and replacing\n     *   strings with text nodes.\n     * @returns VNodeBuilder.\n     */\n    children(children: VNodeRecursiveArray | VNode<any> | string | number | boolean | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set children on VNode: children method should be called on element nodes \" +\n                    \"only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set children on VNode: input elements can't have children.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children on VNode: media elements can't have children.\");\n            }\n        }\n        if (Array.isArray(children)) {\n            this._flags |= VNodeFlags.ChildrenArray;\n            this._children = normalizeVNodes(children);\n        } else {\n            if (typeof children === \"object\") {\n                this._flags |= VNodeFlags.ChildrenVNode;\n            } else {\n                this._flags |= VNodeFlags.ChildrenBasic;\n            }\n            this._children = children;\n        }\n        return this;\n    }\n\n    /**\n     * Set children that will be tracked by `key` property.\n     *\n     * To support use cases with static nodes at the beginning and at the end of the children list, children list may\n     * contain nodes with `null` keys at the beginning of the list and at the end, children with `null` keys shouldn't\n     * move.\n     *\n     * NOTE: If you've found any other use case that can't be easily solved with the current `trackByKeyChildren`\n     * implementation, feel free to submit an issue, but most of the time it is better to help browsers with layout\n     * calculation, and it will be better to wrap nodes that aren't moved into its own container nodes and specify css\n     * containment property. Use cases with \"semantic\" markup probably will be ignored.\n     *\n     * @param children Recursive lists of vnodes that can contain null values. It will automatically normalize recursive\n     *   lists by flattening and filtering out null values.\n     * @returns VNodeBuilder.\n     */\n    trackByKeyChildren(children: VNodeRecursiveArray | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set children on VNode: children method should be called on element nodes \" +\n                    \"only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set children on VNode: input elements can't have children.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children on VNode: media elements can't have children.\");\n            }\n\n        }\n        this._flags |= VNodeFlags.TrackByKeyChildren | VNodeFlags.ChildrenArray;\n        if (children) {\n            this._children = normalizeVNodes(children);\n        }\n\n        if (__IVI_DEV__) {\n            const childrenArray = this._children as VNode<any>[];\n            let child: VNode<any>;\n            let start = 0;\n            let end = childrenArray.length - 1;\n            while (start <= end) {\n                child = childrenArray[start];\n                if (child._key !== null) {\n                    break;\n                }\n                start++;\n            }\n            while (start <= end) {\n                child = childrenArray[end];\n                if (child._key !== null) {\n                    break;\n                }\n                end--;\n            }\n\n            if (start <= end) {\n                const usedKeys = new Set<any>();\n                while (start <= end) {\n                    child = childrenArray[start];\n                    const key = child._key;\n                    if (key === null) {\n                        throw new Error(`Failed to set children on VNode: invalid keyed children list, keyed ` +\n                            `children should have a shape like [non-keyed, keyed, non-keyed].`);\n                    }\n                    if (usedKeys.has(key)) {\n                        throw new Error(`Failed to set children on VNode: invalid children list, key: \"${key}\" is ` +\n                            `used multiple times.`);\n                    }\n                    usedKeys.add(key);\n                    start++;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Set children as an innerHTML string. It is potentially vulnerable to XSS attacks.\n     *\n     * @param html innerHTML in a string format.\n     * @returns VNodeBuilder.\n    */\n    unsafeHTML(html: string): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set unsafeHTML on VNode: unsafeHTML method should be called on element \" +\n                    \"nodes only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set unsafeHTML on VNode: input elements can't have innerHTML.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children on VNode: media elements can't have children.\");\n            }\n        }\n        this._flags |= VNodeFlags.UnsafeHTML;\n        this._children = html;\n        return this;\n    }\n\n    /**\n     * Set HTMLInputElement/HTMLTextAreaElement value property.\n     *\n     * @param text Text value.\n     * @returns VNodeBuilder.\n     */\n    value(value: string | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.InputElement)) {\n                throw new Error(\"Failed to set value on VNode: value method is working only with input elements.\");\n            }\n        }\n        this._children = value;\n        return this;\n    }\n\n    /**\n     * Set HTMLInputElement checked property.\n     *\n     * @param text Text value.\n     * @returns VNodeBuilder.\n     */\n    checked(checked: boolean | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.InputElement)) {\n                throw new Error(\"Failed to set checked on VNode: checked method is working only with input elements.\");\n            }\n            if (!isInputTypeSupportsCheckedValue(this._tag as InputType)) {\n                throw new Error(`Failed to set checked on VNode: input elements with type ${this._tag} doesn't have `\n                    + `checked value.`);\n            }\n        }\n        this._children = checked;\n        return this;\n    }\n\n    /**\n     * Set ref callback.\n     *\n     * When VNode is mounted ref callback will be invoked with a Node value for DOM Elements or Component instance for\n     * components.\n     *\n     * When VNode is unmounted ref callback will be invoked with a `null` value.\n     *\n     * @param ref callback.\n     * @returns VNodeBuilder.\n     */\n    ref(ref: (ref: Node | null) => void): VNodeBuilder<P>;\n    ref(ref: (ref: Component<any> | null) => void): VNodeBuilder<P>;\n    ref(ref: ((ref: Node | null) => void) | ((ref: Component<any> | null) => void)): VNodeBuilder<P> {\n        this._ref = ref;\n        return this;\n    }\n}\n\nexport type VNodeRecursiveListValue = VNodeRecursiveArray | VNode<any> | string | number | boolean | null;\n/**\n * Recursive VNode List.\n */\nexport interface VNodeRecursiveArray extends Array<VNodeRecursiveListValue> { }\n\n/**\n * Create a VNodeBuilder representing a Text node.\n *\n * @param context Text content.\n * @returns VNodeBuilder object.\n */\nexport function $t(content: string | number | boolean | null): VNodeBuilder<null> {\n    return new VNodeBuilder<null>(VNodeFlags.Text, null, null, null, content);\n}\n\n/* tslint:disable:max-line-length */\n/**\n * Create a VNodeBuilder representing an Element node.\n *\n * @param tagName HTML Element tag name.\n * @param props HTML Element props.\n * @returns VNodeBuilder object.\n */\nexport function $h(tagName: \"a\", className?: string): VNodeBuilder<HTMLAnchorElementProps | null>;\nexport function $h(tagName: \"abbr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"acronym\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"address\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"applet\", className?: string): VNodeBuilder<HTMLAppletElementProps | null>;\nexport function $h(tagName: \"area\", className?: string): VNodeBuilder<HTMLAreaElementProps | null>;\nexport function $h(tagName: \"article\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"aside\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"b\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"base\", className?: string): VNodeBuilder<HTMLBaseElementProps | null>;\nexport function $h(tagName: \"basefont\", className?: string): VNodeBuilder<HTMLBaseFontElementProps | null>;\nexport function $h(tagName: \"bdo\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"big\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"blockquote\", className?: string): VNodeBuilder<HTMLQuoteElementProps | null>;\nexport function $h(tagName: \"body\", className?: string): VNodeBuilder<HTMLBodyElementProps | null>;\nexport function $h(tagName: \"br\", className?: string): VNodeBuilder<HTMLBRElementProps | null>;\nexport function $h(tagName: \"button\", className?: string): VNodeBuilder<HTMLButtonElementProps | null>;\nexport function $h(tagName: \"canvas\", className?: string): VNodeBuilder<HTMLCanvasElementProps | null>;\nexport function $h(tagName: \"caption\", className?: string): VNodeBuilder<HTMLTableCaptionElementProps | null>;\nexport function $h(tagName: \"center\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"cite\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"code\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"col\", className?: string): VNodeBuilder<HTMLTableColElementProps | null>;\nexport function $h(tagName: \"colgroup\", className?: string): VNodeBuilder<HTMLTableColElementProps | null>;\nexport function $h(tagName: \"datalist\", className?: string): VNodeBuilder<HTMLDataListElementProps | null>;\nexport function $h(tagName: \"dd\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"del\", className?: string): VNodeBuilder<HTMLModElementProps | null>;\nexport function $h(tagName: \"dfn\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"dir\", className?: string): VNodeBuilder<HTMLDirectoryElementProps | null>;\nexport function $h(tagName: \"div\", className?: string): VNodeBuilder<HTMLDivElementProps | null>;\nexport function $h(tagName: \"dl\", className?: string): VNodeBuilder<HTMLDListElementProps | null>;\nexport function $h(tagName: \"dt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"em\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"embed\", className?: string): VNodeBuilder<HTMLEmbedElementProps | null>;\nexport function $h(tagName: \"fieldset\", className?: string): VNodeBuilder<HTMLFieldSetElementProps | null>;\nexport function $h(tagName: \"figcaption\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"figure\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"font\", className?: string): VNodeBuilder<HTMLFontElementProps | null>;\nexport function $h(tagName: \"footer\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"form\", className?: string): VNodeBuilder<HTMLFormElementProps | null>;\nexport function $h(tagName: \"frame\", className?: string): VNodeBuilder<HTMLFrameElementProps | null>;\nexport function $h(tagName: \"frameset\", className?: string): VNodeBuilder<HTMLFrameSetElementProps | null>;\nexport function $h(tagName: \"h1\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h2\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h3\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h4\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h5\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h6\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"head\", className?: string): VNodeBuilder<HTMLHeadElementProps | null>;\nexport function $h(tagName: \"header\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"hgroup\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"hr\", className?: string): VNodeBuilder<HTMLHRElementProps | null>;\nexport function $h(tagName: \"html\", className?: string): VNodeBuilder<HTMLHtmlElementProps | null>;\nexport function $h(tagName: \"i\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"iframe\", className?: string): VNodeBuilder<HTMLIFrameElementProps | null>;\nexport function $h(tagName: \"img\", className?: string): VNodeBuilder<HTMLImageElementProps | null>;\nexport function $h(tagName: \"ins\", className?: string): VNodeBuilder<HTMLModElementProps | null>;\nexport function $h(tagName: \"isindex\", className?: string): VNodeBuilder<HTMLUnknownElementProps | null>;\nexport function $h(tagName: \"kbd\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"keygen\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"label\", className?: string): VNodeBuilder<HTMLLabelElementProps | null>;\nexport function $h(tagName: \"legend\", className?: string): VNodeBuilder<HTMLLegendElementProps | null>;\nexport function $h(tagName: \"li\", className?: string): VNodeBuilder<HTMLLIElementProps | null>;\nexport function $h(tagName: \"link\", className?: string): VNodeBuilder<HTMLLinkElementProps | null>;\nexport function $h(tagName: \"listing\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: \"map\", className?: string): VNodeBuilder<HTMLMapElementProps | null>;\nexport function $h(tagName: \"mark\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"marquee\", className?: string): VNodeBuilder<HTMLMarqueeElementProps | null>;\nexport function $h(tagName: \"menu\", className?: string): VNodeBuilder<HTMLMenuElementProps | null>;\nexport function $h(tagName: \"meta\", className?: string): VNodeBuilder<HTMLMetaElementProps | null>;\nexport function $h(tagName: \"meter\", className?: string): VNodeBuilder<HTMLMeterElementProps | null>;\nexport function $h(tagName: \"nav\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"nextid\", className?: string): VNodeBuilder<HTMLUnknownElementProps | null>;\nexport function $h(tagName: \"nobr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"noframes\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"noscript\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"object\", className?: string): VNodeBuilder<HTMLObjectElementProps | null>;\nexport function $h(tagName: \"ol\", className?: string): VNodeBuilder<HTMLOListElementProps | null>;\nexport function $h(tagName: \"optgroup\", className?: string): VNodeBuilder<HTMLOptGroupElementProps | null>;\nexport function $h(tagName: \"option\", className?: string): VNodeBuilder<HTMLOptionElementProps | null>;\nexport function $h(tagName: \"p\", className?: string): VNodeBuilder<HTMLParagraphElementProps | null>;\nexport function $h(tagName: \"param\", className?: string): VNodeBuilder<HTMLParamElementProps | null>;\nexport function $h(tagName: \"picture\", className?: string): VNodeBuilder<HTMLPictureElementProps | null>;\nexport function $h(tagName: \"plaintext\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"pre\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: \"progress\", className?: string): VNodeBuilder<HTMLProgressElementProps | null>;\nexport function $h(tagName: \"q\", className?: string): VNodeBuilder<HTMLQuoteElementProps | null>;\nexport function $h(tagName: \"rt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"ruby\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"s\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"samp\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"script\", className?: string): VNodeBuilder<HTMLScriptElementProps | null>;\nexport function $h(tagName: \"section\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"select\", className?: string): VNodeBuilder<HTMLSelectElementProps | null>;\nexport function $h(tagName: \"small\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"source\", className?: string): VNodeBuilder<HTMLSourceElementProps | null>;\nexport function $h(tagName: \"span\", className?: string): VNodeBuilder<HTMLSpanElementProps | null>;\nexport function $h(tagName: \"strike\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"strong\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"style\", className?: string): VNodeBuilder<HTMLStyleElementProps | null>;\nexport function $h(tagName: \"sub\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"sup\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"table\", className?: string): VNodeBuilder<HTMLTableElementProps | null>;\nexport function $h(tagName: \"tbody\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"td\", className?: string): VNodeBuilder<HTMLTableDataCellElementProps | null>;\nexport function $h(tagName: \"template\", className?: string): VNodeBuilder<HTMLTemplateElementProps | null>;\nexport function $h(tagName: \"textarea\", className?: string): VNodeBuilder<HTMLTextAreaElementProps | null>;\nexport function $h(tagName: \"tfoot\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"th\", className?: string): VNodeBuilder<HTMLTableHeaderCellElementProps | null>;\nexport function $h(tagName: \"thead\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"title\", className?: string): VNodeBuilder<HTMLTitleElementProps | null>;\nexport function $h(tagName: \"tr\", className?: string): VNodeBuilder<HTMLTableRowElementProps | null>;\nexport function $h(tagName: \"track\", className?: string): VNodeBuilder<HTMLTrackElementProps | null>;\nexport function $h(tagName: \"tt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"u\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"ul\", className?: string): VNodeBuilder<HTMLUListElementProps | null>;\nexport function $h(tagName: \"var\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"wbr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"x-ms-webview\", className?: string): VNodeBuilder<MSHTMLWebViewElementProps | null>;\nexport function $h(tagName: \"xmp\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: string, className?: string): VNodeBuilder<HTMLElementProps | null> {\n    return new VNodeBuilder<HTMLElementProps | null>(\n        VNodeFlags.Element,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\n/**\n * Create a VNodeBuilder representing a SVGElement node.\n *\n * @param tagName SVG Element tag name.\n * @param props SVG Element props.\n * @returns VNodeBuilder object.\n */\nexport function $s(tagName: \"circle\", className?: string): VNodeBuilder<SVGCircleElementProps | null>;\nexport function $s(tagName: \"clippath\", className?: string): VNodeBuilder<SVGClipPathElementProps | null>;\nexport function $s(tagName: \"defs\", className?: string): VNodeBuilder<SVGDefsElementProps | null>;\nexport function $s(tagName: \"desc\", className?: string): VNodeBuilder<SVGDescElementProps | null>;\nexport function $s(tagName: \"ellipse\", className?: string): VNodeBuilder<SVGEllipseElementProps | null>;\nexport function $s(tagName: \"feblend\", className?: string): VNodeBuilder<SVGFEBlendElementProps | null>;\nexport function $s(tagName: \"fecolormatrix\", className?: string): VNodeBuilder<SVGFEColorMatrixElementProps | null>;\nexport function $s(tagName: \"fecomponenttransfer\", className?: string): VNodeBuilder<SVGFEComponentTransferElementProps | null>;\nexport function $s(tagName: \"fecomposite\", className?: string): VNodeBuilder<SVGFECompositeElementProps | null>;\nexport function $s(tagName: \"feconvolvematrix\", className?: string): VNodeBuilder<SVGFEConvolveMatrixElementProps | null>;\nexport function $s(tagName: \"fediffuselighting\", className?: string): VNodeBuilder<SVGFEDiffuseLightingElementProps | null>;\nexport function $s(tagName: \"fedisplacementmap\", className?: string): VNodeBuilder<SVGFEDisplacementMapElementProps | null>;\nexport function $s(tagName: \"fedistantlight\", className?: string): VNodeBuilder<SVGFEDistantLightElementProps | null>;\nexport function $s(tagName: \"feflood\", className?: string): VNodeBuilder<SVGFEFloodElementProps | null>;\nexport function $s(tagName: \"fefunca\", className?: string): VNodeBuilder<SVGFEFuncAElementProps | null>;\nexport function $s(tagName: \"fefuncb\", className?: string): VNodeBuilder<SVGFEFuncBElementProps | null>;\nexport function $s(tagName: \"fefuncg\", className?: string): VNodeBuilder<SVGFEFuncGElementProps | null>;\nexport function $s(tagName: \"fefuncr\", className?: string): VNodeBuilder<SVGFEFuncRElementProps | null>;\nexport function $s(tagName: \"fegaussianblur\", className?: string): VNodeBuilder<SVGFEGaussianBlurElementProps | null>;\nexport function $s(tagName: \"feimage\", className?: string): VNodeBuilder<SVGFEImageElementProps | null>;\nexport function $s(tagName: \"femerge\", className?: string): VNodeBuilder<SVGFEMergeElementProps | null>;\nexport function $s(tagName: \"femergenode\", className?: string): VNodeBuilder<SVGFEMergeNodeElementProps | null>;\nexport function $s(tagName: \"femorphology\", className?: string): VNodeBuilder<SVGFEMorphologyElementProps | null>;\nexport function $s(tagName: \"feoffset\", className?: string): VNodeBuilder<SVGFEOffsetElementProps | null>;\nexport function $s(tagName: \"fepointlight\", className?: string): VNodeBuilder<SVGFEPointLightElementProps | null>;\nexport function $s(tagName: \"fespecularlighting\", className?: string): VNodeBuilder<SVGFESpecularLightingElementProps | null>;\nexport function $s(tagName: \"fespotlight\", className?: string): VNodeBuilder<SVGFESpotLightElementProps | null>;\nexport function $s(tagName: \"fetile\", className?: string): VNodeBuilder<SVGFETileElementProps | null>;\nexport function $s(tagName: \"feturbulence\", className?: string): VNodeBuilder<SVGFETurbulenceElementProps | null>;\nexport function $s(tagName: \"filter\", className?: string): VNodeBuilder<SVGFilterElementProps | null>;\nexport function $s(tagName: \"foreignobject\", className?: string): VNodeBuilder<SVGForeignObjectElementProps | null>;\nexport function $s(tagName: \"g\", className?: string): VNodeBuilder<SVGGElementProps | null>;\nexport function $s(tagName: \"image\", className?: string): VNodeBuilder<SVGImageElementProps | null>;\nexport function $s(tagName: \"line\", className?: string): VNodeBuilder<SVGLineElementProps | null>;\nexport function $s(tagName: \"lineargradient\", className?: string): VNodeBuilder<SVGLinearGradientElementProps | null>;\nexport function $s(tagName: \"marker\", className?: string): VNodeBuilder<SVGMarkerElementProps | null>;\nexport function $s(tagName: \"mask\", className?: string): VNodeBuilder<SVGMaskElementProps | null>;\nexport function $s(tagName: \"metadata\", className?: string): VNodeBuilder<SVGMetadataElementProps | null>;\nexport function $s(tagName: \"path\", className?: string): VNodeBuilder<SVGPathElementProps | null>;\nexport function $s(tagName: \"pattern\", className?: string): VNodeBuilder<SVGPatternElementProps | null>;\nexport function $s(tagName: \"polygon\", className?: string): VNodeBuilder<SVGPolygonElementProps | null>;\nexport function $s(tagName: \"polyline\", className?: string): VNodeBuilder<SVGPolylineElementProps | null>;\nexport function $s(tagName: \"radialgradient\", className?: string): VNodeBuilder<SVGRadialGradientElementProps | null>;\nexport function $s(tagName: \"rect\", className?: string): VNodeBuilder<SVGRectElementProps | null>;\nexport function $s(tagName: \"stop\", className?: string): VNodeBuilder<SVGStopElementProps | null>;\nexport function $s(tagName: \"svg\", className?: string): VNodeBuilder<SVGSVGElementProps | null>;\nexport function $s(tagName: \"switch\", className?: string): VNodeBuilder<SVGSwitchElementProps | null>;\nexport function $s(tagName: \"symbol\", className?: string): VNodeBuilder<SVGSymbolElementProps | null>;\nexport function $s(tagName: \"text\", className?: string): VNodeBuilder<SVGTextElementProps | null>;\nexport function $s(tagName: \"textpath\", className?: string): VNodeBuilder<SVGTextPathElementProps | null>;\nexport function $s(tagName: \"tspan\", className?: string): VNodeBuilder<SVGTSpanElementProps | null>;\nexport function $s(tagName: \"use\", className?: string): VNodeBuilder<SVGUseElementProps | null>;\nexport function $s(tagName: \"view\", className?: string): VNodeBuilder<SVGViewElementProps | null>;\nexport function $s(tagName: string, className?: string): VNodeBuilder<SVGElementProps | null> {\n    return new VNodeBuilder<SVGElementProps | null>(\n        VNodeFlags.Element | VNodeFlags.SvgElement,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\nexport type InputType = \"textarea\" | \"button\" | \"checkbox\" | \"color\" | \"date\" | \"datetime\" | \"datetime-local\" |\n    \"email\" | \"file\" | \"hidden\" | \"image\" | \"month\" | \"number\" | \"password\" | \"radio\" | \"range\" | \"reset\" | \"search\" |\n    \"submit\" | \"tel\" | \"text\" | \"time\" | \"url\" | \"week\";\n\nfunction isInputTypeSupportsCheckedValue(type: InputType): boolean {\n    if (type === \"checkbox\" || type === \"radio\") {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Create a VNodeBuilder representing an HTMLInputElement node.\n *\n * @param type Input Element type. When type param has value \"textarea\", HTMLTextAreaElement will be created.\n * @param props Input Element props.\n * @returns VNodeBuilder object.\n */\nexport function $i(type: \"textarea\", className?: string): VNodeBuilder<HTMLTextAreaElementProps | null>;\nexport function $i(type: \"button\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"checkbox\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"color\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"date\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"datetime\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"datetime-local\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"email\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"file\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"hidden\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"image\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"month\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"number\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"password\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"radio\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"range\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"reset\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"search\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"submit\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"tel\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"text\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"time\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"url\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"week\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: InputType, className?: string): VNodeBuilder<HTMLInputElementProps | null> {\n    return new VNodeBuilder<HTMLInputElementProps | null>(\n        type === \"textarea\" ?\n            VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.TextAreaElement :\n            VNodeFlags.Element | VNodeFlags.InputElement,\n        type,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\n/**\n * Create a VNodeBuilder representing an HTMLMediaElement node.\n *\n * @param tagName Media element tag name.\n * @param props\n * @returns VNodeBuilder object.\n */\nexport function $m(tagName: \"audio\", className?: string): VNodeBuilder<HTMLAudioElementProps | null>;\nexport function $m(tagName: \"video\", className?: string): VNodeBuilder<HTMLVideoElementProps | null>;\nexport function $m(tagName: string, className?: string): VNodeBuilder<HTMLMediaElementProps | null> {\n    return new VNodeBuilder<HTMLMediaElementProps | null>(\n        VNodeFlags.Element | VNodeFlags.MediaElement,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n/* tslint:enable:max-line-length */\n\n/**\n * Create a VNodeBuilder representing a Component node.\n *\n * @param c Component factory.\n * @param props Component props.\n * @returns VNodeBuilder object.\n */\nexport function $c(c: ComponentFunction<null> | ComponentClass<null>): VNodeBuilder<null>;\nexport function $c<P>(c: ComponentFunction<P> | ComponentClass<P>, props: P): VNodeBuilder<P>;\nexport function $c<P>(c: ComponentFunction<P> | ComponentClass<P>, props?: P): VNodeBuilder<P> {\n    return new VNodeBuilder<P>(\n        (c.prototype.render) ? VNodeFlags.ComponentClass : VNodeFlags.ComponentFunction,\n        c,\n        props!,\n        null,\n        null);\n}\n\n/**\n * Perform a deep VNode cloning with DOM and Component reference erasure.\n *\n * @param node VNode to clone.\n * @returns Cloned VNode.\n */\nexport function cloneVNode(node: VNode<any>): VNode<any> {\n    const flags = node._flags;\n    let children = node._children;\n    if (children !== null && (flags & VNodeFlags.ChildrenArray)) {\n        children = children as VNode<any>[];\n        const newChildren = new Array<VNode<any>>(children.length);\n        for (let i = 0; i < 0; i++) {\n            newChildren[i] = cloneVNode(children[i]);\n        }\n    }\n\n    const newNode = new VNodeBuilder(\n        node._flags,\n        node._tag,\n        node._props,\n        node._className,\n        (node._flags & VNodeFlags.Component) ? null : node._children);\n    newNode._key = node._key;\n    newNode._events = node._events;\n    newNode._style = node._style;\n\n    return newNode;\n}\n\nfunction _normalizeVNodes(nodes: VNodeRecursiveArray, result: VNode<any>[], i: number): void {\n    for (; i < nodes.length; i++) {\n        const n = nodes[i];\n        if (n !== null) {\n            if (Array.isArray(n)) {\n                _normalizeVNodes(n, result, 0);\n            } else {\n                result.push(typeof n === \"object\" ? n as VNode<any> : $t(n));\n            }\n        }\n    }\n}\n\n/**\n * Normalizes recursive VNode lists by flattening all nodes, filtering out `null` children and converting strings to\n * text nodes.\n *\n * @param nodes\n * @returns Normalized VNode array.\n */\nexport function normalizeVNodes(nodes: VNodeRecursiveArray): VNode<any>[] {\n    for (let i = 0; i < nodes.length; i++) {\n        const n = nodes[i];\n\n        if (n === null || Array.isArray(n)) {\n            const result = nodes.slice(0, i) as VNode<any>[];\n            _normalizeVNodes(nodes, result, i);\n            return result;\n        } else if (typeof n !== \"object\") {\n            nodes[i] = $t(n);\n        }\n    }\n\n    return nodes as VNode<any>[];\n}\n","import { render, Component, VNode, Events, $h, $c } from \"ivi\";\n\nclass Collapsable extends Component<{\n    child: VNode<any>,\n}> {\n    private collapsed = false;\n\n    private onClick = Events.onClick((ev) => {\n        this.collapsed = !this.collapsed;\n        this.invalidate();\n    });\n\n    render() {\n        return $h(\"div\", this.collapsed ? \"Collapsable close\" : \"Collapsable\")\n            .events({ click: this.onClick })\n            .children(this.props.child);\n    }\n}\n\nrender(\n    $c(Collapsable, {\n        child: $h(\"div\").children(\"Collapsable content\"),\n    }),\n    document.getElementById(\"app\") !,\n);\n","\n/**\n * Context.\n *\n * All Context objects should be immutable.\n *\n * Context objects will be implicitly propagated through virtual dom trees.\n *\n * @final\n */\nexport class Context {\n    /**\n     * Context data.\n     */\n    readonly data: { [key: string]: any };\n    /**\n     * Parent context.\n     *\n     * Contexts are built as a tree of immutable objects.\n     */\n    readonly from?: Context;\n\n    constructor(data: any, from?: Context) {\n        this.data = data;\n        this.from = from;\n    }\n\n    /**\n     * Find a context data.\n     *\n     * Get method supports two ways to retrieve context values:\n     *  - Retrieve value with a simple key.\n     *  - Object with a key => value mapping.\n     *\n     * Retrieving values with a simple key works by iterating through all parent contexts until it finds value,\n     * `undefined` value is returned when nothing is found.\n     *\n     * Retrieving values with key => value mapping works by iterating through all parent contexts and mapping all\n     * keys with values on the first occurence, this process goes on until it finds values for all keys.\n     *\n     * @param key Key may be a simple string, or a { [key: string]: value | undefined } object.\n     * @returns Value for the provided key if it is a simple string, or key object that was used as a key => value\n     *   mapping.\n     */\n    get<V>(key: V): V;\n    get<V>(key: string): V | undefined;\n    get<V>(key: string | V): V | undefined {\n        let n: Context | undefined = this;\n        let v: any;\n\n        if (typeof key !== \"string\") {\n            const keys = Object.keys(key) as (string | null)[];\n            let l = keys.length;\n\n            while (l > 0 && n) {\n                if (n.data) {\n                    for (let i = 0; i < keys.length; i++) {\n                        const k = keys[i];\n                        if (k) {\n                            v = n.data[k];\n                            if (v !== undefined) {\n                                (key as any)[k] = n.data[k];\n                                keys[i] = null;\n                                l--;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                n = n.from;\n            }\n\n            return key;\n        }\n\n        while (n) {\n            if (n.data) {\n                v = n.data[key];\n                if (v !== undefined) {\n                    return v as V;\n                }\n            }\n            n = n.from;\n        }\n\n        return;\n    }\n}\n\n/**\n * Root Context.\n *\n * Default Context that is used to render root nodes.\n */\nexport const ROOT_CONTEXT = new Context(undefined);\n","import { XML_NAMESPACE, XLINK_NAMESPACE } from \"../common/dom\";\nimport { VNodeFlags } from \"./flags\";\nimport { CSSStyleProps } from \"./dom_props\";\n\n/**\n * Sync DOM class names.\n *\n * @param node HTML or SVG Element.\n * @param flags VNode flags.\n * @param a Old className.\n * @param b New className.\n */\nexport function syncClassName(node: Element, flags: VNodeFlags, a: string | null, b: string | null): void {\n    if (!b) {\n        b = \"\";\n    }\n    if (flags & VNodeFlags.SvgElement) {\n        node.setAttribute(\"class\", b);\n    } else {\n        node.className = b;\n    }\n}\n\n/**\n * Sync DOM styles.\n *\n * When styles are synced, and style from the old list is missing in the new one, its value will be reassigned with a\n * `null` value.\n *\n *    a: { backgroundColor: \"#333\", color: \"#fff\" }\n *    b: { backgroundColor: \"#333\" }\n *\n * In this example `color` style will receive a `null` value.\n *\n * DOM style syncing also supports `string` values, and they can be used interchangeably.\n *\n *    a: \"backgroundColor: #333; color: #fff\"\n *    b: { backgroundColor: \"#333\" }\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param a Old styles.\n * @param b New styles.\n */\nexport function syncStyle(\n    node: HTMLElement | SVGStylable,\n    a: CSSStyleProps | string | null,\n    b: CSSStyleProps | string | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n    let style: CSSStyleDeclaration;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, insert all styles from b.\n            style = node.style;\n            if (typeof b === \"string\") {\n                style.cssText = b;\n            } else {\n                keys = Object.keys(b);\n                for (i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    (style as any)[key] = (b as any)[key];\n                }\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all styles from a.\n        style = node.style;\n        if (typeof a === \"string\") {\n            style.cssText = \"\";\n        } else {\n            keys = Object.keys(a);\n            for (i = 0; i < keys.length; i++) {\n                (style as any)[keys[i]] = null;\n            }\n        }\n    } else {\n        style = node.style;\n        if (typeof b === \"string\") {\n            style.cssText = b;\n        } else {\n            if (typeof a === \"string\") {\n                style.cssText = \"\";\n                keys = Object.keys(b);\n                for (i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    (style as any)[key] = (b as any)[key];\n                }\n            } else {\n                let matchCount = 0;\n\n                keys = Object.keys(a);\n                for (i = 0; i < keys.length; i++) {\n                    key = keys[i];\n                    const bValue = (b as any)[key];\n\n                    if (bValue !== undefined) {\n                        const aValue = (a as any)[key];\n                        if (aValue !== bValue) {\n                            (style as any)[key] = bValue;\n                        }\n                        matchCount++;\n                    } else {\n                        (style as any)[key] = null;\n                    }\n                }\n\n                keys = Object.keys(b);\n                i = 0;\n                while (matchCount < keys.length && i < keys.length) {\n                    key = keys[i++];\n                    if (!a.hasOwnProperty(key)) {\n                        (style as any)[key] = (b as any)[key];\n                        matchCount++;\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Set DOM property.\n *\n * @param node HTML or SVG Element.\n * @param isSVG node is an SVG Element.\n * @param key Attribute name.\n * @param value Attribute value.\n */\nfunction setDOMProperty(node: Element, flags: VNodeFlags, key: string, value?: any, prevValue?: any): void {\n    if (flags & VNodeFlags.MediaElement) {\n        /**\n         * HTMLMediaElements has an internal state with a `volume` property, so it should be checked before an\n         * assignment to prevent unnecessary events when `volume` value is the same as the `volume` in the internal\n         * state.\n         *\n         * In general we don't want to override behaviour of DOM Elements with an internal state. Assigning props\n         * to such elements should be treated as a one-time assignment, so it works almost like `volume` attribute,\n         * except when a new value is passed down, it can override previous value when it doesn't match the previous\n         * one. There is absolutely no reasons to overcomplicate such behaviour just to make it more beatiful like it\n         * is a declarative assignment and can't be changed, because in real applications, component that controls this\n         * element will always track changes to propagate them into its own state or an external state, and when it\n         * changes it will invalidate its representation, so everything stays in-sync.\n         */\n        if (key === \"volume\") {\n            if ((node as HTMLMediaElement).volume !== value) {\n                (node as HTMLMediaElement).volume = value === undefined ? null : value;\n            }\n            return;\n        }\n    }\n\n    if (value === undefined) {\n        /**\n         * Because there is no generic way to assign a default value for a property when it is removed, it is always\n         * removed with `removeAttribute` method.\n         */\n        node.removeAttribute(key);\n    } else {\n        if (key.length > 5) {\n            if (key.charCodeAt(0) === 120 &&\n                (key.charCodeAt(3) === 58 || key.charCodeAt(5) === 58)) { // 58 === \":\" \"xml:\", \"xlink:\"\n                if (key.charCodeAt(1) === 109 && key.charCodeAt(2) === 108) { // [109, 108] === \"ml\"\n                    /**\n                     * All attributes that starts with an \"xml:\" prefix will be assigned with XML namespace.\n                     */\n                    node.setAttributeNS(XML_NAMESPACE, key, value);\n                    return;\n                } else if (key.charCodeAt(1) === 108 &&\n                    key.charCodeAt(2) === 105 &&\n                    key.charCodeAt(3) === 110 &&\n                    key.charCodeAt(4) === 107) { // [108, 105, 110, 107] === \"link\"\n                    /**\n                     * All attributes that starts with an \"xlink:\" prefix will be assigned with XLINK namespace.\n                     */\n                    node.setAttributeNS(XLINK_NAMESPACE, key, value);\n                    return;\n                }\n            } else if (key.charCodeAt(4) === 45) { // 45 === \"-\" \"data-\", \"aria-\"\n                /**\n                 * Attributes that has \"-\" character at the 4th position will be assigned with a `setAttribute` method.\n                 * It should work with \"data-\" and \"aria-\" attributes. Otherwise just use property assignment instead\n                 * of `setAttribute`.\n                 */\n                node.setAttribute(key, value);\n                return;\n            }\n        }\n\n        (node as any)[key] = value;\n    }\n}\n\n/**\n * Sync DOM properties.\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param flags VNode flags.\n * @param a Old DOM properties.\n * @param b New DOM properties.\n */\nexport function syncDOMProps(\n    node: Element,\n    flags: VNodeFlags,\n    a: { [key: string]: any } | null,\n    b: { [key: string]: any } | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, insert all attributes from b.\n            keys = Object.keys(b);\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                setDOMProperty(node, flags, key, b[key]);\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all attributes from a.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            setDOMProperty(node, flags, keys[i]);\n        }\n    } else {\n        let matchCount = 0;\n\n        // Remove and update attributes.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            const bValue = b[key];\n            if (bValue === undefined) {\n                setDOMProperty(node, flags, key);\n            } else {\n                const aValue = a[key];\n                if (aValue !== bValue) {\n                    setDOMProperty(node, flags, key, bValue, aValue);\n                }\n                matchCount++;\n            }\n        }\n\n        // Insert new attributes.\n        keys = Object.keys(b);\n        i = 0;\n        while (matchCount < keys.length && i < keys.length) {\n            key = keys[i++];\n            if (!a.hasOwnProperty(key)) {\n                setDOMProperty(node, flags, key, b[key]);\n                matchCount++;\n            }\n        }\n    }\n}\n","/**\n * Miscellaneous DOM related stuff.\n */\n\nexport const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n\n/**\n * Traverses the DOM to the top and calculates DOM Node depth.\n *\n * @param node DOM Node.\n * @returns DOM Node depth.\n */\nexport function nodeDepth(node: Node | null): number {\n    let depth = 0;\n    while (node) {\n        depth++;\n        node = node.parentNode;\n    }\n    return depth;\n}\n","import { EventHandler, EventHandlerList } from \"./event_handler\";\nimport { setEventHandlerListToDOMNode } from \"./utils\";\n\n/**\n * Shortcut for Event Handler registration.\n *\n * @param handler Event Handler.\n */\nfunction registerEventHandler(handler: EventHandler<any, any>): void {\n    handler.dispatcher.registerHandler(handler.fn);\n}\n\n/**\n * Shortcut for Event Handler unregistration.\n *\n * @param handler Event Handler.\n */\nfunction unregisterEventHandler(handler: EventHandler<any, any>): void {\n    handler.dispatcher.unregisterHandler(handler.fn);\n}\n\n/**\n * Sync DOM events.\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param a Old events.\n * @param b New events.\n */\nexport function syncEvents(\n    node: Element,\n    a: EventHandlerList | null,\n    b: EventHandlerList | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, register all events from b.\n            keys = Object.keys(b);\n            for (i = 0; i < keys.length; i++) {\n                registerEventHandler(b[keys[i]]);\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all events from a.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            unregisterEventHandler(a[keys[i]]);\n        }\n    } else {\n        let matchCount = 0;\n\n        // Remove and update events.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            const aHandler = a[key];\n            const bHandler = b[key];\n            if (bHandler !== undefined) {\n                if (aHandler !== bHandler) {\n                    registerEventHandler(bHandler);\n                    unregisterEventHandler(aHandler);\n                }\n                matchCount++;\n            } else {\n                unregisterEventHandler(aHandler);\n            }\n        }\n\n        // Insert new events.\n        keys = Object.keys(b);\n        i = 0;\n        while (matchCount < keys.length && i < keys.length) {\n            key = keys[i++];\n            if (!a.hasOwnProperty(key)) {\n                registerEventHandler(b[key]);\n                matchCount++;\n            }\n        }\n    }\n\n    setEventHandlerListToDOMNode(node, b === null ? undefined : b);\n}\n","/**\n * DO NOT MOVE THIS FUNCTIONS TO SEPARATE MODULES!\n *\n * There are so many circular dependencies between functions in this module, so just leave it all here instead of\n * creating many circular dependencies between JS modules.\n *\n * Tags:\n *\n * #entry - Entry point, function that will be invoked just once when the reconciliation process is started with a root\n *   render, or when scheduler updates invalidated components. Entry point is a good place to inject tryCatch statements\n *   to improve stack trace messages etc.\n * #augment - Function that is used only for augmenting.\n * #component - Component related functions.\n */\n\nimport { DevModeFlags, DEV_MODE } from \"../common/dev_mode\";\nimport { injectScreenOfDeath } from \"../common/screen_of_death\";\nimport { SVG_NAMESPACE } from \"../common/dom\";\nimport {\n    setInitialNestingState, pushNestingState, restoreNestingState, checkNestingViolation, nestingStateAncestorFlags,\n    nestingStateParentTagName, AncestorFlags,\n} from \"../common/html_nesting_rules\";\nimport { VNodeFlags, ComponentFlags } from \"./flags\";\nimport { VNode } from \"./vnode\";\nimport { cloneVNode, $t } from \"./vnode_builder\";\nimport { ComponentClass, ComponentFunction, Component } from \"./component\";\nimport { stackTracePushComponent, stackTracePopComponent, stackTraceReset, stackTraceAugment } from \"./stack_trace\";\nimport { Context } from \"./context\";\nimport { syncDOMProps, syncClassName, syncStyle } from \"./sync_dom\";\nimport { syncEvents } from \"../events/sync_events\";\n\n/**\n * Render VNode entry point tryCatch wrapper.\n *\n * #entry\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nexport function renderVNode(\n    parent: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    if (__IVI_DEV__) {\n        if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n            if ((parent as Element).tagName) {\n                setInitialNestingState((parent as Element).tagName.toLowerCase(), 0);\n            } else {\n                setInitialNestingState(\"\", 0);\n            }\n        }\n\n        if (!(DEV_MODE & (DevModeFlags.DisableStackTraceAugmentation | DevModeFlags.DisableScreenOfDeath))) {\n            try {\n                return _renderVNode(parent, refChild, vnode, context, owner);\n            } catch (e) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceAugment(e);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableScreenOfDeath)) {\n                    injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceReset();\n                }\n                throw e;\n            }\n        }\n    }\n    return _renderVNode(parent, refChild, vnode, context, owner);\n}\n\n/**\n * Render VNode entry point. Renders VNode into container and invokes `didMount` lifecycle methods after VNode is\n * inserted into container.\n *\n * #entry\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction _renderVNode(\n    container: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    return vNodeRenderInto(container, refChild, vnode, context, owner);\n}\n\n/**\n * Sync VNode entry point tryCatch wrapper.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nexport function syncVNode(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    if (__IVI_DEV__) {\n        if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n            if ((parent as Element).tagName) {\n                setInitialNestingState((parent as Element).tagName.toLowerCase(), 0);\n            } else {\n                setInitialNestingState(\"\", 0);\n            }\n        }\n\n        if (!(DEV_MODE & (DevModeFlags.DisableStackTraceAugmentation | DevModeFlags.DisableScreenOfDeath))) {\n            try {\n                return _syncVNode(parent, a, b, context, owner);\n            } catch (e) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceAugment(e);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableScreenOfDeath)) {\n                    injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceReset();\n                }\n                throw e;\n            }\n        }\n    }\n    return _syncVNode(parent, a, b, context, owner);\n}\n\n/**\n * Sync VNode entry point. Sync VNode with a new one or replace when they aren't compatible.\n *\n * #entry\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction _syncVNode(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    return vNodeSyncOrReplace(parent, a, b, context, owner);\n}\n\n/**\n * Remove VNode entry point tryCatch wrapper.\n *\n * #entry\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nexport function removeVNode(parent: Node, node: VNode<any>): void {\n    if (__IVI_DEV__) {\n        if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n            if ((parent as Element).tagName) {\n                setInitialNestingState((parent as Element).tagName.toLowerCase(), 0);\n            } else {\n                setInitialNestingState(\"\", 0);\n            }\n        }\n\n        if (!(DEV_MODE & (DevModeFlags.DisableStackTraceAugmentation | DevModeFlags.DisableScreenOfDeath))) {\n            try {\n                _removeVNode(parent, node);\n                return;\n            } catch (e) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceAugment(e);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableScreenOfDeath)) {\n                    injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceReset();\n                }\n                throw e;\n            }\n        }\n    }\n    _removeVNode(parent, node);\n}\n\n/**\n * Remove VNode entry point.\n *\n * #entry\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nfunction _removeVNode(parent: Node, node: VNode<any>): void {\n    parent.removeChild(node._dom!);\n    vNodeUnmount(node);\n}\n\n/**\n * Augment entry point tryCatch wrapper.\n *\n * #entry\n * #augment\n *\n * TODO: check mounting logic\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nexport function augmentVNode(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): void {\n    if (__IVI_DEV__) {\n        if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n            if ((parent as Element).tagName) {\n                setInitialNestingState((parent as Element).tagName.toLowerCase(), 0);\n            } else {\n                setInitialNestingState(\"\", 0);\n            }\n        }\n\n        if (!(DEV_MODE & (DevModeFlags.DisableStackTraceAugmentation | DevModeFlags.DisableScreenOfDeath))) {\n            try {\n                _augmentVNode(parent, node, vnode, context, owner);\n                return;\n            } catch (e) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceAugment(e);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableScreenOfDeath)) {\n                    injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceReset();\n                }\n                throw e;\n            }\n        }\n    }\n    _augmentVNode(parent, node, vnode, context, owner);\n}\n\n/**\n * Augment entry point. Augments DOM tree with a Virtual DOM tree and performs mounting.\n *\n * #entry\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nfunction _augmentVNode(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): void {\n    vNodeAugment(parent, node, vnode, context, owner);\n}\n\n/**\n * Update Component entry point tryCatch wrapper.\n *\n * #entry\n * #component\n *\n * @param component Component to update.\n * @returns DOM Node.\n */\nexport function updateComponent<P>(component: Component<P>): Node {\n    if (__IVI_DEV__) {\n        if (!(DEV_MODE & (DevModeFlags.DisableStackTraceAugmentation | DevModeFlags.DisableScreenOfDeath))) {\n            try {\n                stackTracePushComponent((component as Object).constructor as ComponentClass<any>);\n                const ret = _updateComponent(component);\n                stackTracePopComponent();\n                return ret;\n            } catch (e) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceAugment(e);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableScreenOfDeath)) {\n                    injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n                }\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTraceReset();\n                }\n                throw e;\n            }\n        }\n    }\n    return _updateComponent(component);\n}\n\n/**\n * Update Component.\n *\n * #entry\n *\n * @param component Component to update.\n * @returns DOM Node.\n */\nfunction _updateComponent<P>(component: Component<P>): Node {\n    const flags = component.flags;\n    let ref = component._rootDOMNode!;\n\n    if ((flags & ComponentFlags.Mounted) && (flags & ComponentFlags.Dirty)) {\n        const oldRoot = component.root!;\n        if (flags & ComponentFlags.DirtyContext) {\n            componentUpdateContext(component);\n        }\n\n        component.willUpdate();\n\n        if (flags & (ComponentFlags.DirtyProps | ComponentFlags.DirtyState | ComponentFlags.UsingContext)) {\n            if (__IVI_DEV__) {\n                if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n                    if ((component._parentDOMNode as Element).tagName) {\n                        setInitialNestingState((component._parentDOMNode as Element).tagName.toLowerCase(),\n                            component._ancestorFlags);\n                    } else {\n                        setInitialNestingState(\"\", component._ancestorFlags);\n                    }\n                }\n            }\n            const parentNode = component._parentDOMNode;\n            const newRoot = componentClassRender(component);\n            ref = component._rootDOMNode = vNodeSyncOrReplace(parentNode!, oldRoot, newRoot, component._context);\n            component.flags &= ~(ComponentFlags.Dirty | ComponentFlags.InUpdateQueue);\n        } else if (oldRoot) {\n            vNodePropagateNewContext(component._parentDOMNode!, oldRoot, component._context, component);\n        }\n\n        component.didUpdate();\n    }\n\n    return ref;\n}\n\n/**\n * Update a component function.\n *\n * #component\n *\n * @param parent Parent DOM Node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current Context.\n * @param owner Owner.\n * @returns DOM Node.\n */\nfunction _updateComponentFunction(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    let ref: Node = a._dom!;\n    const fn = b._tag as ComponentFunction<any>;\n\n    if (a === b || !fn.isPropsChanged || fn.isPropsChanged(a._props, b._props)) {\n        const oldRoot = a._children as VNode<any>;\n        const newRoot = b._children = componentFunctionRender(fn, b._props, context);\n        ref = vNodeSyncOrReplace(parent, oldRoot, newRoot, context, owner);\n    } else {\n        b._children = a._children;\n    }\n\n    b._dom = ref;\n    return ref;\n}\n\n/**\n * Recursively mount all nodes.\n *\n * @param vnode VNode.\n */\nfunction vNodeMount(vnode: VNode<any>): void {\n    const flags = vnode._flags;\n\n    if (flags & VNodeFlags.Component) {\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePushComponent(vnode._tag as ComponentClass<any> | ComponentFunction<any>);\n            }\n        }\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._children as Component<any>;\n\n            if (__IVI_DEV__) {\n                if (component.flags & ComponentFlags.Mounted) {\n                    throw new Error(\"Failed to mount Component: component is already mounted.\");\n                }\n            }\n\n            component.flags |= ComponentFlags.Mounted;\n            component.didMount();\n            vNodeMount(component.root!);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            vNodeMount(vnode._children as VNode<any>);\n        }\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePopComponent();\n            }\n        }\n    } else if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n        let children = vnode._children;\n        if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n            if (flags & VNodeFlags.ChildrenArray) {\n                children = children as VNode<any>[];\n                for (let i = 0; i < children.length; i++) {\n                    vNodeMount(children[i]);\n                }\n            } else {\n                vNodeMount(children as VNode<any>);\n            }\n        }\n    }\n\n    if (vnode._ref) {\n        vnode._ref((flags & VNodeFlags.Component) ? vnode._children as Component<any> : vnode._dom);\n    }\n}\n\n/**\n * Recursively unmount all nodes.\n *\n * @param vnode VNode.\n */\nfunction vNodeUnmount(vnode: VNode<any>): void {\n    const flags = vnode._flags;\n    if (flags & VNodeFlags.Component) {\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePushComponent(vnode._tag as ComponentClass<any> | ComponentFunction<any>);\n            }\n        }\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._children as Component<any>;\n\n            if (__IVI_DEV__) {\n                if (!(component.flags & ComponentFlags.Mounted)) {\n                    throw new Error(\"Failed to unmount Component: component is already unmounted.\");\n                }\n            }\n            vNodeUnmount(component.root!);\n            component.flags &= ~(ComponentFlags.Mounted | ComponentFlags.UpdateEachFrame);\n            component.didUnmount();\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            vNodeUnmount(vnode._children as VNode<any>);\n        }\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePopComponent();\n            }\n        }\n    } else if (flags & VNodeFlags.Element) {\n        if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n            let children = vnode._children;\n            if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n                if (flags & VNodeFlags.ChildrenArray) {\n                    children = children as VNode<any>[];\n                    for (let i = 0; i < children.length; i++) {\n                        vNodeUnmount(children[i]);\n                    }\n                } else {\n                    vNodeUnmount(children as VNode<any>);\n                }\n            }\n        }\n        if (vnode._events) {\n            syncEvents(vnode._dom as Element, vnode._events, null);\n        }\n    }\n\n    if (vnode._ref) {\n        vnode._ref(null);\n    }\n}\n\n/**\n * Unmount all nodes and its subtrees.\n *\n * @param vnodes Array of VNodes.\n */\nfunction vNodeUnmountAll(vnodes: VNode<any>[]): void {\n    for (let i = 0; i < vnodes.length; i++) {\n        vNodeUnmount(vnodes[i]);\n    }\n}\n\n/**\n * Recursively propagate new context.\n *\n * @param vnode VNode.\n * @param context New context.\n */\nfunction vNodePropagateNewContext(parent: Node, vnode: VNode<any>, context: Context, owner?: Component<any>): void {\n    const flags = vnode._flags;\n    if (flags & VNodeFlags.Component) {\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePushComponent(vnode._tag as ComponentClass<any> | ComponentFunction<any>);\n            }\n        }\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._children as Component<any>;\n            componentUpdateParentContext(component, context);\n            _updateComponent(component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            const fn = vnode._tag as ComponentFunction<any>;\n            // Optimization that checks if function is using context parameter. When function doesn't use context, it\n            // means that we can ignore re-renders when context is changed, and just propagate a new context through\n            // existing subtree.\n            if (fn.length < 2) {\n                if (vnode._children) {\n                    vNodePropagateNewContext(parent, vnode._children as VNode<any>, context, owner);\n                }\n            } else {\n                _updateComponentFunction(parent, vnode._children as VNode<any>, vnode._children as VNode<any>, context,\n                    owner);\n            }\n        }\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePopComponent();\n            }\n        }\n    } else if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n        let children = vnode._children;\n        if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n            if (flags & VNodeFlags.ChildrenArray) {\n                children = children as VNode<any>[];\n                for (let i = 0; i < children.length; i++) {\n                    vNodePropagateNewContext(parent, children[i], context, owner);\n                }\n            } else {\n                vNodePropagateNewContext(parent, children as VNode<any>, context, owner);\n            }\n        }\n    }\n}\n\n/**\n * Move node.\n *\n * @param parent Parent DOM node.\n * @param node VNode element to move.\n * @param nextRef Reference to the next node, if it is null, node will be moved to the end.\n */\nfunction vNodeMoveChild(parent: Node, node: VNode<any>, nextRef: Node | null): void {\n    parent.insertBefore(node._dom!, nextRef!);\n}\n\n/**\n * Remove all children.\n *\n * `didUnmount` lifecycle methods will be invoked in all children and their subtrees.\n *\n * @param parent Parent DOM node.\n * @param nodes Arrays of VNodes to remove.\n */\nfunction vNodeRemoveAllChildren(parent: Node, nodes: VNode<any>[]): void {\n    parent.textContent = \"\";\n    vNodeUnmountAll(nodes);\n}\n\n/**\n * Remove child.\n *\n * `didUnmount` lifecycle methods will be invoked in removed node and its subtree.\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nfunction vNodeRemoveChild(parent: Node, node: VNode<any>): void {\n    parent.removeChild(node._dom!);\n    vNodeUnmount(node);\n}\n\n/**\n * Assign a new parent context to a component.\n *\n * Reference equality is used to check if context is changed, all context objects should be immutable.\n *\n * #component\n *\n * @param component Component.\n * @param newContext New Context to assign.\n */\nfunction componentUpdateParentContext<P>(component: Component<P>, newParentContext: Context): void {\n    if (component._parentContext !== newParentContext) {\n        component.flags |= ComponentFlags.DirtyContext;\n        const oldContext = component._parentContext;\n        component._parentContext = newParentContext;\n        component.didReceiveNewContext(oldContext, newParentContext);\n    }\n}\n\n/**\n * Update current context of a component.\n *\n * #component\n *\n * @param component Component.\n */\nfunction componentUpdateContext<P>(component: Component<P>): void {\n    component.flags &= ~(ComponentFlags.CheckUsingProps | ComponentFlags.ContextUsingProps);\n    const contextData = component.updateContext();\n    component.flags |= (component.flags & ComponentFlags.CheckUsingProps) << 1;\n    const newContext = contextData ? new Context(contextData, component._parentContext) : component._parentContext;\n    component._context = newContext;\n}\n\n/**\n * Assign a new props to a component.\n *\n * #component\n *\n * @param component Component.\n * @param newProps New props to assign.\n */\nfunction componentUpdateProps<P>(component: Component<P>, newProps: P): void {\n    const oldProps = component._props;\n    if (component.isPropsChanged(oldProps, newProps)) {\n        component.flags |= ComponentFlags.DirtyProps;\n\n        component._props = newProps;\n\n        // There is no reason to call `didReceivewNewProps` when props aren't changed, even when they are reassigned\n        // later to reduce memory usage.\n        component.didReceiveNewProps(oldProps, newProps);\n        if (component.flags & ComponentFlags.ContextUsingProps) {\n            component.flags |= ComponentFlags.DirtyContext;\n        }\n    } else {\n        // Reassign props even when they aren't changed to reduce overall memory usage.\n        //\n        // New value always stays alive because it is referenced from virtual dom tree, so instead of keeping in memory\n        // two values even when they are the same, we just always reassign it to the new value.\n        component._props = newProps;\n    }\n}\n\n/**\n * Render a component class instance and return root VNode.\n *\n * #component\n *\n * @param component Component.\n * @returns Root VNode.\n */\nfunction componentClassRender<P>(component: Component<P>): VNode<any> {\n    component.flags &= ~(ComponentFlags.CheckUsingContext | ComponentFlags.UsingContext);\n    const root = component.root = component.render() || $t(\"\");\n    component.flags |= (component.flags & ComponentFlags.CheckUsingContext) << 1;\n    return root;\n}\n\n/**\n * Render a component function instance and return root VNode.\n *\n * #component\n *\n * @param component Component function.\n * @param props Props.\n * @param context Context.\n * @returns Root VNode.\n */\nfunction componentFunctionRender<P>(component: ComponentFunction<P>, props: P, context?: Context): VNode<any> {\n    return component(props, context) || $t(\"\");\n}\n\n/**\n * Set value for HTMLInputElement.\n *\n * When value has a string type it is assigned to `value` property, otherwise it is assigned to `checked` property.\n *\n * @param input HTMLInputElement.\n * @param value Value.\n */\nfunction setHTMLInputValue(input: HTMLInputElement, value: string | boolean | null): void {\n    if (typeof value === \"string\") {\n        input.value = value;\n    } else {\n        input.checked = value as boolean;\n    }\n}\n\n/**\n * Render VNode.\n *\n * @param parent Parent DOM Node.\n * @param vnode VNode to render.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction vNodeRender(parent: Node, vnode: VNode<any>, context: Context, owner?: Component<any>): Node {\n    // if VNode already has a reference to a DOM Node, perform a deep clone of vnodes\n    if (vnode._dom) {\n        vnode = cloneVNode(vnode);\n    }\n\n    const flags = vnode._flags;\n    let ref: Node | undefined;\n    let i: number;\n\n    if (flags & (VNodeFlags.Text | VNodeFlags.Element)) {\n        // Push nesting state and check for nesting violation.\n        let _prevNestingStateParentTagName: string | undefined;\n        let _prevNestingStateAncestorFlags: AncestorFlags | undefined;\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n                _prevNestingStateParentTagName = nestingStateParentTagName();\n                _prevNestingStateAncestorFlags = nestingStateAncestorFlags();\n                pushNestingState((flags & VNodeFlags.Text) ? \"$t\" : vnode._tag as string);\n                checkNestingViolation();\n            }\n        }\n        if (flags & VNodeFlags.Text) {\n            ref = document.createTextNode(vnode._children as string);\n        } else { // (flags & VNodeFlags.Element)\n            if (flags & VNodeFlags.InputElement) {\n                if (flags & VNodeFlags.TextAreaElement) {\n                    ref = document.createElement(\"textarea\");\n                } else {\n                    ref = document.createElement(\"input\");\n                    (ref as HTMLInputElement).type = vnode._tag as string;\n                }\n            } else if (flags & VNodeFlags.SvgElement) {\n                ref = document.createElementNS(SVG_NAMESPACE, vnode._tag as string);\n            } else {\n                ref = document.createElement(vnode._tag as string);\n            }\n\n            if (vnode._props) {\n                syncDOMProps(ref as Element, flags, null, vnode._props);\n            }\n            if (vnode._className !== null) {\n                syncClassName(ref as Element, flags, null, vnode._className);\n            }\n            if (vnode._style !== null) {\n                syncStyle(ref as HTMLElement, null, vnode._style);\n            }\n            if (vnode._events) {\n                syncEvents(ref as Element, null, vnode._events);\n            }\n\n            let children = vnode._children;\n            if (children !== null) {\n                if (flags & (VNodeFlags.ChildrenBasic | VNodeFlags.ChildrenArray)) {\n                    if (flags & VNodeFlags.ChildrenBasic) {\n                        ref.textContent = children as string;\n                    } else {\n                        children = children as VNode<any>[];\n                        for (i = 0; i < children.length; i++) {\n                            ref.insertBefore(vNodeRender(ref, children[i], context, owner), null);\n                        }\n                    }\n                } else if (flags & VNodeFlags.ChildrenVNode) {\n                    ref.insertBefore(vNodeRender(ref, children as VNode<any>, context, owner), null);\n                } else if (flags & VNodeFlags.InputElement) {\n                    setHTMLInputValue(ref as HTMLInputElement, children as string | boolean);\n                } else { // (flags & VNodeFlags.UnsafeHTML)\n                    (ref as Element).innerHTML = children as string;\n                }\n            }\n        }\n        // Restore nesting state.\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n                restoreNestingState(_prevNestingStateParentTagName, _prevNestingStateAncestorFlags!);\n            }\n        }\n    } else { // (flags & VNodeFlags.Component)\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePushComponent(vnode._tag as ComponentClass<any> | ComponentFunction<any>);\n            }\n        }\n\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._children = new (vnode._tag as ComponentClass<any>)(vnode._props, context, owner);\n            if (__IVI_DEV__) {\n                if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n                    component._ancestorFlags = nestingStateAncestorFlags();\n                }\n            }\n            component._parentDOMNode = parent;\n            componentUpdateContext(component);\n            const root = componentClassRender(component);\n            ref = component._rootDOMNode = vNodeRender(parent, root, component._context, component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            const root = vnode._children =\n                componentFunctionRender(vnode._tag as ComponentFunction<any>, vnode._props, context);\n            ref = vnode._dom = vNodeRender(parent, root, context, owner);\n        }\n\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePopComponent();\n            }\n        }\n    }\n\n    vnode._dom = ref;\n\n    return ref;\n}\n\n/**\n * Render VNode into container and invoke `didMount` lifecycle methods after VNode is inserted into container.\n *\n * It is important that `didMount` methods are invoked only after DOM Nodes have been inserted into container, so it\n * goes twice through the entire vnode tree, first time when everything is rendered and the second time when `didMount`\n * methods are invoked.\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction vNodeRenderInto(\n    container: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    const ref = container.insertBefore(vNodeRender(container, vnode, context, owner), refChild);\n    vNodeMount(vnode);\n    return ref;\n}\n\n/**\n * Get non-comment DOM Node. This function removes all comment DOM Nodes when searching for non-comment nodes.\n *\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @returns Non-comment DOM Node.\n */\nfunction getNonCommentNode(parent: Node, node: Node | null): Node | null {\n    while (node && node.nodeType === 8) {\n        const next = node.nextSibling;\n        parent.removeChild(node);\n        node = next;\n    }\n    return node;\n}\n\n/**\n * Augment DOM Node with a Virtual DOM Node.\n *\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nfunction vNodeAugment(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): void {\n    // if VNode already has a reference to a DOM Node, perform a deep clone of vnodes\n    if (vnode._dom) {\n        vnode = cloneVNode(vnode);\n    }\n\n    if (node) {\n        const flags = vnode._flags;\n\n        if (flags & (VNodeFlags.Element | VNodeFlags.Text)) {\n            if (flags & VNodeFlags.Element) {\n                if (vnode._events) {\n                    syncEvents(node as Element, null, vnode._events);\n                }\n\n                if (vnode._children !== null) {\n                    if (flags & (VNodeFlags.ChildrenArray | VNodeFlags.ChildrenVNode)) {\n                        let domChild = getNonCommentNode(node, node.firstChild);\n                        if (flags & VNodeFlags.ChildrenArray) {\n                            const children = vnode._children as VNode<any>[];\n                            for (let i = 0; i < children.length; i++) {\n                                vNodeAugment(node, domChild, children[i], context, owner);\n                                domChild = getNonCommentNode(node, domChild!.nextSibling);\n                            }\n                        } else {\n                            vNodeAugment(node, domChild, vnode._children as VNode<any>, context, owner);\n                        }\n                    } else if (flags & VNodeFlags.InputElement) {\n                        setHTMLInputValue(node as HTMLInputElement, vnode._children as string | boolean);\n                    }\n                }\n            }\n        } else { // (flags & VNodeFlags.Component)\n            if (__IVI_DEV__) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTracePushComponent(vnode._tag as ComponentClass<any> | ComponentFunction<any>);\n                }\n            }\n\n            if (flags & VNodeFlags.ComponentClass) {\n                const component = vnode._children =\n                    new (vnode._tag as ComponentClass<any>)(vnode._props, context, owner);\n\n                if (__IVI_DEV__) {\n                    if (!(DEV_MODE & DevModeFlags.DisableNestingValidation)) {\n                        component._ancestorFlags = nestingStateAncestorFlags();\n                    }\n                }\n\n                component._parentDOMNode = parent;\n                component._rootDOMNode = node;\n                componentUpdateContext(component);\n                const root = componentClassRender(component);\n                vNodeAugment(parent, node, root, component._context, component);\n            } else {\n                const root = vnode._children =\n                    componentFunctionRender(vnode._tag as ComponentFunction<any>, vnode._props, context);\n                vNodeAugment(parent, node, root, context, owner);\n            }\n\n            if (__IVI_DEV__) {\n                if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                    stackTracePopComponent();\n                }\n            }\n        }\n    } else {\n        node = vNodeRenderInto(parent, null, vnode, context, owner);\n    }\n\n    vnode._dom = node;\n}\n\n/**\n * Check if two nodes can be synced.\n *\n * Two nodes can be synced when their flags and tags are identical.\n *\n * @param a Old VNode.\n * @param b New VNode.\n * @return true if nodes can be synced.\n */\nfunction vNodeCanSync(a: VNode<any>, b: VNode<any>): boolean {\n    return ((a._flags & VNodeFlags.Syncable) === (b._flags & VNodeFlags.Syncable) &&\n        a._tag === b._tag &&\n        a._key === b._key);\n}\n\n/**\n * Sync two VNodes.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction vNodeSync(parent: Node, a: VNode<any>, b: VNode<any>, context: Context, owner?: Component<any>): Node {\n    if (a === b) {\n        return b._dom!;\n    }\n\n    if (b._dom) {\n        b = cloneVNode(b);\n    }\n    const flags = a._flags;\n    let ref: Node | undefined;\n\n    if (flags & (VNodeFlags.Text | VNodeFlags.Element)) {\n        ref = b._dom = a._dom!;\n\n        if (flags & VNodeFlags.Text) {\n            if (a._children !== b._children) {\n                ref.nodeValue = b._children as string;\n            }\n        } else { // (flags & VNodeFlags.Element)\n            if (a._props !== b._props) {\n                syncDOMProps(ref as Element, flags, a._props, b._props);\n            }\n            if (a._className !== b._className) {\n                syncClassName(ref as Element, flags, a._className, b._className);\n            }\n            if (a._style !== b._style) {\n                syncStyle(ref as HTMLElement, a._style, b._style);\n            }\n            if (a._events !== b._events) {\n                syncEvents(ref as HTMLElement, a._events, b._events);\n            }\n\n            if (a._children !== b._children) {\n                syncChildren(\n                    a._dom!,\n                    a._flags,\n                    b._flags,\n                    a._children as VNode<any>[] | VNode<any> | string | number | boolean,\n                    b._children as VNode<any>[] | VNode<any> | string | number | boolean,\n                    context,\n                    owner);\n            }\n        }\n    } else { // (flags & VNodeFlags.Component)\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePushComponent(b._tag as ComponentClass<any> | ComponentFunction<any>);\n            }\n        }\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = b._children = a._children as Component<any>;\n            componentUpdateProps(component, b._props);\n            componentUpdateParentContext(component, context);\n            ref = b._dom = _updateComponent(component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            ref = b._dom = _updateComponentFunction(parent, a, b, context, owner);\n        }\n        if (__IVI_DEV__) {\n            if (!(DEV_MODE & DevModeFlags.DisableStackTraceAugmentation)) {\n                stackTracePopComponent();\n            }\n        }\n    }\n\n    return ref;\n}\n\n/**\n * Sync VNode with a new one or replace when they aren't compatible.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction vNodeSyncOrReplace(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node {\n    if (vNodeCanSync(a, b)) {\n        return vNodeSync(parent, a, b, context, owner);\n    }\n    const newRef = vNodeRender(parent, b, context, owner) as Element;\n    parent.replaceChild(newRef, a._dom!);\n    vNodeUnmount(a);\n    vNodeMount(b);\n    return newRef;\n}\n\n/**\n * Sync old children list with the new one.\n *\n * @param parent Parent node.\n * @param aParentFlags Old parent VNode flags.\n * @param bParentFlags New parent VNode flags.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildren(\n    parent: Node,\n    aParentFlags: VNodeFlags,\n    bParentFlags: VNodeFlags,\n    a: VNode<any>[] | VNode<any> | string | number | boolean,\n    b: VNode<any>[] | VNode<any> | string | number | boolean,\n    context: Context,\n    owner: Component<any> | undefined,\n): void {\n    let i = 0;\n\n    if (a === null) {\n        if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.ChildrenArray)) {\n            if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                parent.textContent = b as string;\n            } else {\n                b = b as VNode<any>[];\n                for (i = 0; i < b.length; i++) {\n                    vNodeRenderInto(parent, null, b[i], context, owner);\n                }\n            }\n        } else if (bParentFlags & VNodeFlags.ChildrenVNode) {\n            vNodeRenderInto(parent, null, b as VNode<any>, context, owner);\n        } else if (bParentFlags & VNodeFlags.InputElement) {\n            setHTMLInputValue(parent as HTMLInputElement, b as string | boolean);\n        } else { // (bParentFlags & VNodeFlags.UnsafeHTML)\n            (parent as Element).innerHTML = b as string;\n        }\n    } else if (b === null) {\n        if (aParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n            parent.textContent = \"\";\n        } else if (aParentFlags & VNodeFlags.ChildrenArray) {\n            vNodeRemoveAllChildren(parent, a as VNode<any>[]);\n        } else if (aParentFlags & VNodeFlags.ChildrenVNode) {\n            vNodeRemoveChild(parent, a as VNode<any>);\n        } else { // (bParentFlags & VNodeFlags.InputElement)\n            if (typeof a === \"string\") {\n                (parent as HTMLInputElement).value = \"\";\n            } else {\n                (parent as HTMLInputElement).checked = false;\n            }\n        }\n    } else {\n        if (aParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    const c = parent.firstChild;\n                    if (c) {\n                        c.nodeValue = b as string;\n                    } else {\n                        parent.textContent = b as string;\n                    }\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n            } else {\n                parent.textContent = \"\";\n                if (bParentFlags & VNodeFlags.ChildrenArray) {\n                    b = b as VNode<any>[];\n                    for (i = 0; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    vNodeRenderInto(parent, null, b as VNode<any>, context, owner);\n                }\n            }\n        } else if (aParentFlags & VNodeFlags.ChildrenArray) {\n            a = a as VNode<any>[];\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    parent.textContent = b as string;\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n                vNodeUnmountAll(a);\n            } else if (bParentFlags & VNodeFlags.ChildrenArray) {\n                b = b as VNode<any>[];\n                if (a.length === 0) {\n                    for (i = 0; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    if (b.length === 0) {\n                        vNodeRemoveAllChildren(parent, a);\n                    } else if (a.length === 1 && b.length === 1) {\n                        vNodeSyncOrReplace(parent, a[0], b[0], context, owner);\n                    } else {\n                        if (aParentFlags & bParentFlags & VNodeFlags.TrackByKeyChildren) {\n                            syncChildrenTrackByKeys(parent, a, b, context, owner);\n                        } else {\n                            syncChildrenNaive(parent, a, b, context, owner);\n                        }\n                    }\n                }\n            } else {\n                b = b as VNode<any>;\n                if (a.length > 0) {\n                    vNodeSyncOrReplace(parent, a[0], b, context, owner);\n                    for (i = 1; i < a.length; i++) {\n                        vNodeRemoveChild(parent, a[i]);\n                    }\n                } else {\n                    vNodeRenderInto(parent, null, b, context, owner);\n                }\n            }\n        } else if (aParentFlags & VNodeFlags.ChildrenVNode) {\n            a = a as VNode<any>;\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    parent.textContent = b as string;\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n                vNodeUnmount(a);\n            } else if (bParentFlags & VNodeFlags.ChildrenArray) {\n                b = b as VNode<any>[];\n                if (b.length > 0) {\n                    vNodeSyncOrReplace(parent, a, b[0], context, owner);\n                    for (i = 1; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    vNodeRemoveChild(parent, a);\n                }\n            } else {\n                vNodeSyncOrReplace(parent, a, b as VNode<any>, context, owner);\n            }\n        } else { // (aParentFlags & VNodeFlags.InputElement)\n            if (typeof b === \"string\") {\n                if ((parent as HTMLInputElement).value !== b) {\n                    (parent as HTMLInputElement).value = b;\n                }\n            } else {\n                (parent as HTMLInputElement).checked = b as boolean;\n            }\n        }\n    }\n}\n\n/**\n * Sync children naive way.\n *\n * Any heuristics that is used in this algorithm is an undefined behaviour, and external dependencies should not rely on\n * any knowledge about this algorithm, because it can be changed in any time.\n *\n * This naive algorithm is quite simple:\n *\n *  A: -> [a a c d e g g] <-\n *  B: -> [a a f d c g] <-\n *\n * It starts by iterating over old children list `A` and new children list `B` from both ends.\n *\n *  A: -> [a b c d e g g] <-\n *  B: -> [a b f d c g] <-\n *\n * When it find nodes that have the same key, tag and flags, it will sync them. Node \"a\" and \"b\" on the right side, and\n * node \"g\" on the right side will be synced.\n *\n *  A: -> [c d e g]\n *  B: -> [f d c]\n *\n * Then it start iterating over old and new children lists from the left side and check if nodes can be synced. Nodes\n * \"c\" and \"f\" can't be synced, remove node \"c\" and insert new node \"f\".\n *\n *  A: -> [d e g]\n *  B: -> [d c]\n *\n * Node \"d\" is synced.\n *\n *  A: -> [e g]\n *  B: -> [c]\n *\n * Node \"e\" removed, node \"c\" inserted.\n *\n *  A: -> [g]\n *  B:    []\n *\n * Length of the old list is larger than length of the new list, remove remaining nodes from the old list.\n *\n * @param parent Parent node.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildrenNaive(\n    parent: Node,\n    a: VNode<any>[],\n    b: VNode<any>[],\n    context: Context,\n    owner?: Component<any>,\n): void {\n    let aStart = 0;\n    let bStart = 0;\n    let aEnd = a.length - 1;\n    let bEnd = b.length - 1;\n    let aNode: VNode<any>;\n    let bNode: VNode<any>;\n    let nextPos: number;\n    let next: Node | null;\n\n    // Sync similar nodes at the beginning.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aStart];\n        bNode = b[bStart];\n\n        if (!vNodeCanSync(aNode, bNode)) {\n            break;\n        }\n\n        aStart++;\n        bStart++;\n\n        vNodeSync(parent, aNode, bNode, context, owner);\n    }\n\n    // Sync similar nodes at the end.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n\n        if (!vNodeCanSync(aNode, bNode)) {\n            break;\n        }\n\n        aEnd--;\n        bEnd--;\n\n        vNodeSync(parent, aNode, bNode, context, owner);\n    }\n\n    // Iterate over the remaining nodes and if they have the same type, then sync, otherwise just\n    // remove the old node and insert the new one.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aStart++];\n        bNode = b[bStart++];\n        vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n    }\n\n    if (aStart <= aEnd) {\n        // All nodes from a are synced, remove the rest.\n        do {\n            vNodeRemoveChild(parent, a[aStart++]);\n        } while (aStart <= aEnd);\n    } else if (bStart <= bEnd) {\n        // All nodes from b are synced, insert the rest.\n        nextPos = bEnd + 1;\n        next = nextPos < b.length ? b[nextPos]._dom : null;\n        do {\n            vNodeRenderInto(parent, next, b[bStart++], context, owner);\n        } while (bStart <= bEnd);\n    }\n}\n\n/**\n * Sync children with track by keys algorithm.\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix, and perform simple moves on the edges.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a b f d c g] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"g\" at the end.\n *\n *  A: -> [c d e f] <-\n *  B: -> [f d c] <-\n *\n * At this position it will try to look at the opposite edge, and if there is a node with the same key at the opposite\n * edge, it will perform simple move operation. Node \"c\" is moved to the right edge, and node \"f\" is moved to the left\n * edge.\n *\n *  A: -> [d e] <-\n *  B: -> [d] <-\n *\n * Now it will try again to find common prefix and suffix, node \"d\" is the same, so we can skip it.\n *\n *  A: [e]\n *  B: []\n *\n * Here it will check if the size of one of the list is equal to zero, and if length of the old children list is zero,\n * it will insert all remaining nodes from the new list, or if length of the new children list is zero, it will remove\n * all remaining nodes from the old list.\n *\n * This simple optimization technique will cover most of the real world use cases, even reversing the children list,\n * except for sorting.\n *\n * When algorithm couldn't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * That is how children reconciliation algorithm is working in one of the fastest virtual dom libraries :)\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here. Naive algo\n * and simple 1/N, N/1 cases are using replace op.\n *\n * @param parent Parent node.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildrenTrackByKeys(\n    parent: Node,\n    a: VNode<any>[],\n    b: VNode<any>[],\n    context: Context,\n    owner?: Component<any>,\n): void {\n    let aStart = 0;\n    let bStart = 0;\n    let aEnd = a.length - 1;\n    let bEnd = b.length - 1;\n    let aStartNode = a[aStart];\n    let bStartNode = b[bStart];\n    let aEndNode = a[aEnd];\n    let bEndNode = b[bEnd];\n    let i: number;\n    let j: number | undefined;\n    let nextPos: number;\n    let next: Node | null;\n    let aNode: VNode<any> | null;\n    let bNode: VNode<any>;\n    let node: VNode<any>;\n\n    // Step 1\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode._key === bStartNode._key) {\n            vNodeSyncOrReplace(parent, aStartNode, bStartNode, context, owner);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n        }\n\n        // Sync nodes with the same key at the end.\n        while (aEndNode._key === bEndNode._key) {\n            vNodeSyncOrReplace(parent, aEndNode, bEndNode, context, owner);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n        }\n\n        // Move and sync nodes from right to left.\n        if (aEndNode._key === bStartNode._key) {\n            vNodeSyncOrReplace(parent, aEndNode, bStartNode, context, owner);\n            vNodeMoveChild(parent, bStartNode, aStartNode._dom);\n            aEnd--;\n            bStart++;\n            // There is no need to check when we out of bounds, because the only way we can get here is when there are\n            // more nodes in the lists.\n            //\n            // Impossible transformations:\n            //   [a] => [a b] (common prefix)\n            //   [b a] => [a] (common suffix)\n            //\n            // Possible transformations:\n            //   [b a] => [a b]\n            //   [b a] => [a c]\n\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            // In a real-world scenarios there is a higher chance that next node after the move will be the same, so we\n            // immediately jump to the start of this prefix/suffix algo.\n            continue;\n        }\n\n        // Move and sync nodes from left to right.\n        if (aStartNode._key === bEndNode._key) {\n            vNodeSyncOrReplace(parent, aStartNode, bEndNode, context, owner);\n            nextPos = bEnd + 1;\n            next = nextPos < b.length ? b[nextPos]._dom : null;\n            vNodeMoveChild(parent, bEndNode, next);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            continue;\n        }\n\n        break;\n    }\n\n    if (aStart > aEnd) {\n        // All nodes from a are synced, insert the rest from b.\n        nextPos = bEnd + 1;\n        next = nextPos < b.length ? b[nextPos]._dom : null;\n        while (bStart <= bEnd) {\n            vNodeRenderInto(parent, next, b[bStart++], context, owner);\n        }\n    } else if (bStart > bEnd) {\n        // All nodes from b are synced, remove the rest from a.\n        while (aStart <= aEnd) {\n            vNodeRemoveChild(parent, a[aStart++]);\n        }\n        // Step 2\n    } else {\n        let aLength = aEnd - aStart + 1;\n        let bLength = bEnd - bStart + 1;\n        const aNullable = a as Array<VNode<any> | null>; // will be removed by js optimizing compilers.\n        // Mark all nodes as inserted.\n        const sources = new Array<number>(bLength).fill(-1);\n\n        let moved = false;\n        let pos = 0;\n        let synced = 0;\n\n        // When children lists are small, we are using naive O(N) algorithm to find if child is removed.\n        if ((bLength <= 4) || ((aLength * bLength) <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (synced < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode._key === bNode._key) {\n                            sources[j - bStart] = i;\n\n                            if (pos > j) {\n                                moved = true;\n                            } else {\n                                pos = j;\n                            }\n                            vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n                            synced++;\n                            aNullable[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            const keyIndex = new Map<any, number>();\n\n            for (i = bStart; i <= bEnd; i++) {\n                node = b[i];\n                keyIndex.set(node._key, i);\n            }\n\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n\n                if (synced < bLength) {\n                    j = keyIndex.get(aNode._key);\n\n                    if (j !== undefined) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        } else {\n                            pos = j;\n                        }\n                        vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n                        synced++;\n                        aNullable[i] = null;\n                    }\n                }\n            }\n        }\n\n        if (aLength === a.length && synced === 0) {\n            // Noone is synced, remove all children with one dom op.\n            vNodeRemoveAllChildren(parent, a);\n            while (bStart < bLength) {\n                vNodeRenderInto(parent, null, b[bStart++], context, owner);\n            }\n        } else {\n            i = aLength - synced;\n            while (i > 0) {\n                aNode = aNullable[aStart++];\n                if (aNode !== null) {\n                    vNodeRemoveChild(parent, aNode);\n                    i--;\n                }\n            }\n\n            // Step 3\n            if (moved) {\n                const seq = lis(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        next = nextPos < b.length ? b[nextPos]._dom : null;\n                        vNodeRenderInto(parent, next, node, context, owner);\n                    } else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            next = nextPos < b.length ? b[nextPos]._dom : null;\n                            vNodeMoveChild(parent, node, next);\n                        } else {\n                            j--;\n                        }\n                    }\n                }\n            } else if (synced !== bLength) {\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        next = nextPos < b.length ? b[nextPos]._dom : null;\n                        vNodeRenderInto(parent, next, node, context, owner);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n *\n * @param a Array of numbers.\n * @returns Longest increasing subsequence.\n */\nfunction lis(a: number[]): number[] {\n    const p = a.slice(0);\n    const result: number[] = [];\n    result.push(0);\n    let u: number;\n    let v: number;\n\n    for (let i = 0, il = a.length; i < il; i++) {\n        if (a[i] === -1) {\n            continue;\n        }\n\n        let j = result[result.length - 1];\n        if (a[j] < a[i]) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n\n        u = 0;\n        v = result.length - 1;\n\n        while (u < v) {\n            let c = ((u + v) / 2) | 0;\n            if (a[result[c]] < a[i]) {\n                u = c + 1;\n            } else {\n                v = c;\n            }\n        }\n\n        if (a[i] < a[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n\n    u = result.length;\n    v = result[u - 1];\n\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n\n    return result;\n}\n","/**\n * Global Scheduler.\n */\n\nimport { Component } from \"../vdom/component\";\nimport { updateComponent } from \"../vdom/implementation\";\nimport { ComponentFlags } from \"../vdom/flags\";\n\n/**\n * Scheduler Task.\n */\nexport type SchedulerTask = () => void;\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n    /**\n     * Microtasks are pending for execution in microtasks queue.\n     */\n    MicrotaskPending = 1,\n    /**\n     * Macrotasks are pending for execution in macrotasks queue.\n     */\n    MacrotaskPending = 1 << 1,\n    /**\n     * Frametasks are pending for execution in frametasks queue.\n     */\n    FrametaskPending = 1 << 2,\n    /**\n     * Current frame ready.\n     */\n    CurrentFrameReady = 1 << 3,\n}\n\n/**\n * Frame Tasks Group flags.\n */\nconst enum FrameTasksGroupFlags {\n    /**\n     * Group contains component update tasks.\n     */\n    Component = 1,\n    /**\n     * Group contains \"write\" tasks.\n     */\n    Write = 1 << 1,\n    /**\n     * Group contains \"read\" tasks\".\n     */\n    Read = 1 << 2,\n    /**\n     * Group contains \"after\" tasks.\n     */\n    After = 1 << 3,\n    /**\n     * Group is locked from reading and writing.\n     */\n    RWLock = 1 << 4,\n}\n\n/**\n * Frame tasks group contains tasks for updating components, read dom and write dom tasks, and tasks that should be\n * executed after all other tasks are finished.\n *\n * To get access to the frame tasks group, use: `currentFrame()` and `nextFrame()` scheduler methods.\n *\n *     scheduler.currentFrame().read(() => {\n *       console.log(element.clientWidth);\n *     });\n *\n * @final\n */\nexport class FrameTasksGroup {\n    /**\n     * See `FrameTasksGroupFlags` for details.\n     */\n    _flags: number;\n    /**\n     * Array of component arrays indexed by their depth.\n     */\n    _componentTasks: Array<Component<any>[] | null>;\n    /**\n     * Write DOM task queue.\n     */\n    _writeTasks: SchedulerTask[] | null;\n    /**\n     * Read DOM task queue.\n     */\n    _readTasks: SchedulerTask[] | null;\n    /**\n     * Tasks that should be executed when all other tasks are finished.\n     */\n    _afterTasks: SchedulerTask[] | null;\n\n    constructor() {\n        this._flags = 0;\n        this._componentTasks = [];\n        this._writeTasks = null;\n        this._readTasks = null;\n        this._afterTasks = null;\n    }\n\n    /**\n     * Add Component to the components queue.\n     *\n     * @param component\n     */\n    updateComponent(component: Component<any>): void {\n        if (__IVI_DEV__) {\n            if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                throw new Error(\"Failed to add update component task to the current frame, current frame is locked \" +\n                    \"for read and write tasks.\");\n            }\n        }\n\n        if ((component.flags & ComponentFlags.InUpdateQueue) === 0) {\n            component.flags |= ComponentFlags.InUpdateQueue;\n            const priority = component.depth;\n\n            this._flags |= FrameTasksGroupFlags.Component;\n            while (priority >= this._componentTasks.length) {\n                this._componentTasks.push(null);\n            }\n\n            const group = this._componentTasks[priority];\n            if (group === null) {\n                this._componentTasks[priority] = [component];\n            } else {\n                group.push(component);\n            }\n        }\n    }\n\n    /**\n     * Add new task to the write DOM task queue.\n     *\n     * @param callback\n     */\n    write(callback: SchedulerTask): void {\n        if (__IVI_DEV__) {\n            if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                throw new Error(\"Failed to add update component task to the current frame, current frame is locked \" +\n                    \"for read and write tasks.\");\n            }\n        }\n\n        this._flags |= FrameTasksGroupFlags.Write;\n        if (this._writeTasks === null) {\n            this._writeTasks = [];\n        }\n        this._writeTasks.push(callback);\n    }\n\n    /**\n     * Add new task to the read DOM task queue.\n     *\n     * @param callback\n     */\n    read(callback: SchedulerTask): void {\n        if (__IVI_DEV__) {\n            if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                throw new Error(\"Failed to add update component task to the current frame, current frame is locked \" +\n                    \"for read and write tasks.\");\n            }\n        }\n\n        this._flags |= FrameTasksGroupFlags.Read;\n        if (this._readTasks === null) {\n            this._readTasks = [];\n        }\n        this._readTasks.push(callback);\n    }\n\n    /**\n     * Add new task to the task queue that will execute tasks when all DOM tasks are finished.\n     *\n     * @param callback\n     */\n    after(callback: SchedulerTask): void {\n        this._flags |= FrameTasksGroupFlags.After;\n        if (this._afterTasks === null) {\n            this._afterTasks = [];\n        }\n        this._afterTasks.push(callback);\n    }\n\n    /**\n     * Lock read and write task queues.\n     *\n     * Works in DEBUG mode only.\n     */\n    _rwLock(): void {\n        if (__IVI_DEV__) {\n            this._flags |= FrameTasksGroupFlags.RWLock;\n        }\n    }\n\n    /**\n     * Unlock read and write task queue.\n     *\n     * Works in DEBUG mode only.\n     */\n    _rwUnlock(): void {\n        if (__IVI_DEV__) {\n            this._flags &= ~FrameTasksGroupFlags.RWLock;\n        }\n    }\n}\n\n/**\n * Scheduler.\n */\nconst scheduler = {\n    /**\n     * See `SchedulerFlags` for details.\n     */\n    flags: 0,\n    clock: 0,\n    time: 0,\n    microtasks: [] as SchedulerTask[],\n    macrotasks: [] as SchedulerTask[],\n    currentFrame: new FrameTasksGroup(),\n    nextFrame: new FrameTasksGroup(),\n    updateComponents: [] as Component<any>[],\n    microtaskNode: document.createTextNode(\"\"),\n    microtaskToggle: 0,\n    macrotaskMessage: \"__ivi\" + Math.random(),\n};\n\n// Microtask scheduler based on mutation observer\nconst microtaskObserver = new MutationObserver(runMicrotasks);\nmicrotaskObserver.observe(scheduler.microtaskNode, { characterData: true });\n\n// Macrotask scheduler based on postMessage\nwindow.addEventListener(\"message\", handleWindowMessage);\n\nscheduler.currentFrame._rwLock();\n\n/**\n * Monotonically increasing clock.\n *\n * @returns current clock value.\n */\nexport function clock(): number {\n    return scheduler.clock;\n}\n\n/**\n * Trigger microtasks execution.\n */\nfunction requestMicrotaskExecution(): void {\n    if ((scheduler.flags & SchedulerFlags.MicrotaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.MicrotaskPending;\n        scheduler.microtaskToggle ^= 1;\n        scheduler.microtaskNode.nodeValue = scheduler.microtaskToggle ? \"1\" : \"0\";\n    }\n}\n\n/**\n * Trigger macrotasks execution.\n */\nfunction requestMacrotaskExecution(): void {\n    if ((scheduler.flags & SchedulerFlags.MacrotaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.MacrotaskPending;\n        window.postMessage(scheduler.macrotaskMessage, \"*\");\n    }\n}\n\n/**\n * Trigger next frame tasks execution.\n */\nfunction requestNextFrame(): void {\n    if ((scheduler.flags & SchedulerFlags.FrametaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.FrametaskPending;\n        requestAnimationFrame(handleNextFrame);\n    }\n}\n\n/**\n * Macrotask scheduler event handler.\n *\n * @param ev Message event.\n */\nfunction handleWindowMessage(ev: MessageEvent): void {\n    if (ev.source === window && ev.data === scheduler.macrotaskMessage) {\n        runMacrotasks();\n    }\n}\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nfunction handleNextFrame(_t: number): void {\n    const updateComponents = scheduler.updateComponents;\n    let tasks: SchedulerTask[];\n    let i: number;\n    let j: number;\n\n    scheduler.flags &= ~SchedulerFlags.FrametaskPending;\n    scheduler.flags |= SchedulerFlags.CurrentFrameReady;\n\n    scheduler.time = Date.now();\n\n    const frame = scheduler.nextFrame;\n    scheduler.nextFrame = scheduler.currentFrame;\n    scheduler.currentFrame = frame;\n\n    scheduler.currentFrame._rwUnlock();\n    scheduler.nextFrame._rwUnlock();\n\n    // Mark all update components as dirty. But don't update until all write tasks are finished. It is possible that we\n    // won't need to update component if it is removed.\n    for (i = 0; i < updateComponents.length; i++) {\n        updateComponents[i].flags |= ComponentFlags.DirtyState;\n    }\n\n    // Perform read/write batching. Start with executing read DOM tasks, then update components, execute write DOM tasks\n    // and repeat until all read and write tasks are executed.\n    do {\n        while ((frame._flags & FrameTasksGroupFlags.Read) !== 0) {\n            frame._flags &= ~FrameTasksGroupFlags.Read;\n            tasks = frame._readTasks!;\n            frame._readTasks = null;\n\n            for (i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        }\n\n        while ((frame._flags & (FrameTasksGroupFlags.Component | FrameTasksGroupFlags.Write)) !== 0) {\n            if ((frame._flags & FrameTasksGroupFlags.Component) !== 0) {\n                frame._flags &= ~FrameTasksGroupFlags.Component;\n                const componentGroups = frame._componentTasks;\n\n                for (i = 0; i < componentGroups.length; i++) {\n                    const componentGroup = componentGroups[i];\n                    if (componentGroup !== null) {\n                        componentGroups[i] = null;\n                        for (j = 0; j < componentGroup.length; j++) {\n                            updateComponent(componentGroup[j]);\n                        }\n                    }\n                }\n            }\n\n            if ((frame._flags & FrameTasksGroupFlags.Write) !== 0) {\n                frame._flags &= ~FrameTasksGroupFlags.Write;\n                tasks = frame._writeTasks!;\n                frame._writeTasks = null;\n                for (i = 0; i < tasks.length; i++) {\n                    tasks[i]();\n                }\n            }\n        }\n\n        // Update components registered for updating on each frame.\n        // Remove components that doesn't have UPDATE_EACH_FRAME flag.\n        i = 0;\n        j = updateComponents.length;\n\n        while (i < j) {\n            const component = updateComponents[i++];\n            if ((component.flags & ComponentFlags.UpdateEachFrame) === 0) {\n                component.flags &= ~ComponentFlags.InUpdateEachFrameQueue;\n                if (i === j) {\n                    updateComponents.pop();\n                } else {\n                    updateComponents[--i] = updateComponents.pop() !;\n                }\n            } else {\n                updateComponent(component);\n            }\n        }\n    } while ((frame._flags & (FrameTasksGroupFlags.Component |\n        FrameTasksGroupFlags.Write |\n        FrameTasksGroupFlags.Read)) !== 0);\n\n    scheduler.flags &= ~SchedulerFlags.CurrentFrameReady;\n\n    // Lock current from adding read and write tasks in debug mode.\n    scheduler.currentFrame._rwLock();\n\n    // Perform tasks that should be executed when all DOM ops are finished.\n    while ((frame._flags & FrameTasksGroupFlags.After) !== 0) {\n        frame._flags &= ~FrameTasksGroupFlags.After;\n\n        tasks = frame._afterTasks!;\n        frame._afterTasks = null;\n        for (i = 0; i < tasks.length; i++) {\n            tasks[i]();\n        }\n    }\n\n    if (updateComponents.length > 0) {\n        requestNextFrame();\n    }\n\n    scheduler.clock++;\n}\n\nfunction runMicrotasks(): void {\n    scheduler.time = Date.now();\n\n    while (scheduler.microtasks.length > 0) {\n        const tasks = scheduler.microtasks;\n        scheduler.microtasks = [];\n        for (let i = 0; i < tasks.length; i++) {\n            tasks[i]();\n        }\n        scheduler.clock++;\n    }\n\n    scheduler.flags &= ~SchedulerFlags.MicrotaskPending;\n}\n\nfunction runMacrotasks(): void {\n    scheduler.flags &= ~SchedulerFlags.MacrotaskPending;\n    scheduler.time = Date.now();\n\n    let tasks = scheduler.macrotasks;\n    scheduler.macrotasks = [];\n    for (let i = 0; i < tasks.length; i++) {\n        tasks[i]();\n    }\n\n    scheduler.clock++;\n}\n\n/**\n * Add task to the microtask queue.\n *\n * @param task\n */\nexport function scheduleMicrotask(task: () => void): void {\n    requestMicrotaskExecution();\n    scheduler.microtasks.push(task);\n}\n\n/**\n * Add task to the macrotask queue.\n *\n * @param task\n */\nexport function scheduleMacrotask(task: () => void): void {\n    requestMacrotaskExecution();\n    scheduler.macrotasks.push(task);\n}\n\n/**\n * Get task list for the next frame.\n *\n * @returns Frame tasks group.\n */\nexport function nextFrame(): FrameTasksGroup {\n    requestNextFrame();\n    return scheduler.nextFrame;\n}\n\n/**\n * Get task list for the current frame.\n *\n * @returns Frame tasks group.\n */\nexport function currentFrame(): FrameTasksGroup {\n    if (scheduler.flags & SchedulerFlags.CurrentFrameReady) {\n        return scheduler.currentFrame;\n    }\n    return nextFrame();\n}\n\n/**\n * Add component to the list of components that will be updated each frame.\n *\n * @param component\n */\nexport function startUpdateComponentEachFrame(component: Component<any>): void {\n    requestNextFrame();\n    scheduler.updateComponents.push(component);\n}\n","import { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * Abstract Event Dispatcher.\n *\n * Event Dispatch API is in EXPERIMENTAL phase, there is a high chance that this API will be changed in the future.\n */\nexport abstract class EventDispatcher<I, O extends SyntheticEvent<any>> {\n    /**\n     * Number of registered event handlers or other dependencies.\n     */\n    counter: number;\n    /**\n     * Event Dispatcher dependencies.\n     */\n    dependencies: EventDispatcher<any, SyntheticEvent<any>>[] | null;\n    /**\n     * Event Dispatcher dependents will receive all events produced by this event handler.\n     */\n    dependents: EventDispatcher<any, SyntheticEvent<any>>[] | null;\n\n    constructor() {\n        this.counter = 0;\n        this.dependencies = null;\n        this.dependents = null;\n    }\n\n    /**\n     * Dispatch Event.\n     *\n     * @param ev Event to dispatch.\n     */\n    dispatch(_ev: I): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Dispatch Event to all dependents.\n     *\n     * @param events Events to dispatch.\n     */\n    dispatchEventsToDependents(events: O): void {\n        if (events && this.dependents) {\n            for (let i = 0; i < this.dependents.length; i++) {\n                this.dependents[i].dispatch!(events);\n            }\n        }\n    }\n\n    /**\n     * Lifecycle method `activate` is invoked when Event Dispatcher is activated.\n     */\n    activate(): void {\n        if (this.dependencies) {\n            for (let i = 0; this.dependencies.length; i++) {\n                this.dependencies[i].registerDispatcher(this);\n            }\n        }\n    }\n\n    /**\n     * Lifecycle method `deactivate` is invoked when Event Dispatcher is deactivated.\n     */\n    deactivate(): void {\n        if (this.dependencies) {\n            for (let i = 0; this.dependencies.length; i++) {\n                this.dependencies[i].unregisterDispatcher(this);\n            }\n        }\n    }\n\n    /**\n     * Register an active Event Dispatcher.\n     *\n     * @param dispatcher Event Dispatcher.\n     */\n    registerDispatcher(dispatcher: EventDispatcher<any, SyntheticEvent<any>>): void {\n        if (this.counter++ === 0) {\n            this.activate();\n        }\n        if (this.dependents === null) {\n            this.dependents = [];\n        }\n        this.dependents.push(dispatcher);\n    }\n\n    /**\n     * Unregister a deactivated Event Dispatcher.\n     *\n     * @param dispatcher Event Dispatcher.\n     */\n    unregisterDispatcher(dispatcher: EventDispatcher<any, SyntheticEvent<any>>): void {\n        if (--this.counter === 0) {\n            this.deactivate();\n        }\n        if (this.dependents!.length > 1) {\n            this.dependents![this.dependents!.indexOf(dispatcher)] = this.dependents!.pop() !;\n        } else {\n            this.dependents = null;\n        }\n    }\n\n    /**\n     * Register an Event Handler.\n     *\n     * @param handler Event Handler.\n     */\n    registerHandler(handler: (ev: O) => void): void {\n        if (this.counter++ === 0) {\n            this.activate();\n        }\n        this.didRegisterHandler(handler);\n    }\n\n    /**\n     * Unregister an Event Handler.\n     *\n     * @param handler Event Handler.\n     */\n    unregisterHandler(handler: (ev: O) => void): void {\n        if (--this.counter === 0) {\n            this.deactivate();\n        }\n        this.didUnregisterHandler(handler);\n    }\n\n    /**\n     * Lifecycle method `didRegisterHandler` is invoked after Event Handler registration.\n     *\n     * @param handler Event Handler.\n     */\n    didRegisterHandler(_handler: (ev: O) => void): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didUnregisterHandler` is invoked after Event Handler unregistration.\n     *\n     * @param handler Event Handler.\n     */\n    didUnregisterHandler(_handler: (ev: O) => void): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n}\n","import { EventHandlerFlags, SyntheticEventFlags } from \"./flags\";\nimport { SyntheticEvent } from \"./synthetic_event\";\nimport { DispatchTarget } from \"./traverse_dom\";\n\n/**\n * Dispatch event to local(on the same DOM Node) Event Handlers.\n *\n * It will stop dispatching when event has `StopImmediatePropagation` flag.\n *\n * @param localHandlers Local Event Handlers.\n * @param event Synthetic Event.\n */\nfunction dispatchEventToLocalEventHandlers<E extends SyntheticEvent<any>>(\n    dispatchTarget: DispatchTarget,\n    event: E,\n    matchFlags: EventHandlerFlags,\n): void {\n    event.currentTarget = dispatchTarget.target;\n\n    for (let j = 0; j < dispatchTarget.handlers.length; j++) {\n        const handler = dispatchTarget.handlers[j];\n        if (handler.flags & matchFlags) {\n            handler.fn(event);\n            if (event._flags & SyntheticEventFlags.StoppedImmediatePropagation) {\n                return;\n            }\n        }\n    }\n}\n\n/**\n * Dispatch event to Dispatch Targets.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param dispatchTarget Dispatch Targets.\n * @param event Event to dispatch.\n */\nexport function dispatchEvent<E extends SyntheticEvent<any>>(\n    dispatchTargets: DispatchTarget[],\n    event: E,\n    bubble: boolean,\n): void {\n    let i = dispatchTargets.length - 1;\n    let dispatchTarget;\n\n    // capture phase\n    while (i >= 0) {\n        dispatchTarget = dispatchTargets[i];\n        if (dispatchTarget.target !== event.target) {\n            dispatchEventToLocalEventHandlers(dispatchTargets[i--], event, EventHandlerFlags.Capture);\n            if (event._flags & SyntheticEventFlags.StoppedPropagation) {\n                return;\n            }\n        } else {\n            break;\n        }\n    }\n\n    // target phase\n    dispatchTarget = dispatchTargets[0];\n    if (dispatchTarget.target === event.target) {\n        event._flags |= SyntheticEventFlags.AtTargetPhase;\n        dispatchEventToLocalEventHandlers(dispatchTarget, event,\n            EventHandlerFlags.Capture | EventHandlerFlags.Bubble);\n        if (event._flags & SyntheticEventFlags.StoppedPropagation) {\n            return;\n        }\n        event._flags &= ~SyntheticEventFlags.AtTargetPhase;\n        i = 1;\n    } else {\n        i = 0;\n    }\n\n    // bubble phase\n    if (bubble) {\n        event._flags |= SyntheticEventFlags.BubblePhase;\n        while (i < dispatchTargets.length) {\n            dispatchEventToLocalEventHandlers(dispatchTargets[i++], event, EventHandlerFlags.Bubble);\n            if (event._flags & SyntheticEventFlags.StoppedPropagation) {\n                return;\n            }\n        }\n    }\n}\n","import { NativeEventDispatcherFlags } from \"./flags\";\nimport { SyntheticEvent, SyntheticEventClass } from \"./synthetic_event\";\nimport { EventDispatcher } from \"./event_dispatcher\";\nimport { accumulateDispatchTargets } from \"./traverse_dom\";\nimport { dispatchEvent } from \"./dispatch_event\";\nimport { getEventTarget, getEventOptions } from \"./utils\";\nimport { scheduleMacrotask } from \"../scheduler/scheduler\";\n\n/**\n * Native Event Dispatcher.\n */\nexport class NativeEventDispatcher<I extends Event, O extends SyntheticEvent<I>> extends EventDispatcher<I, O> {\n    /**\n     * See `EventDispatcherFlags` for details.\n     */\n    readonly flags: NativeEventDispatcherFlags;\n    /**\n     * Event name.\n     */\n    readonly name: string;\n    /**\n     * Synthetic Event Constructor.\n     */\n    readonly eventType: SyntheticEventClass<I, O>;\n    /**\n     * `dispatch` method with bounded context.\n     */\n    private readonly _dispatch: (ev: I) => void;\n    /**\n     * Flag indicating that Event Dispatcher will be deactivated in the macrotask.\n     */\n    private _deactivating: boolean;\n\n    constructor(flags: NativeEventDispatcherFlags, name: string, eventType: SyntheticEventClass<I, O>) {\n        super();\n        this.flags = flags;\n        this.name = name;\n        this.eventType = eventType;\n        this._dispatch = this.dispatch.bind(this);\n        this._deactivating = false;\n    }\n\n    dispatch(ev: I): void {\n        const deps = this.dependents;\n        const handlers = accumulateDispatchTargets(getEventTarget(ev) as Element, this);\n\n        let s: O | undefined;\n        if (handlers || deps) {\n            s = new this.eventType(0, ev, getEventTarget(ev));\n        }\n\n        if (handlers.length > 0) {\n            dispatchEvent(handlers, s!, !!(this.flags & NativeEventDispatcherFlags.Bubbles));\n        }\n\n        if (s) {\n            this.dispatchEventsToDependents(s);\n        }\n    }\n\n    activate(): void {\n        if (this._deactivating) {\n            this._deactivating = false;\n        } else {\n            super.activate();\n            document.addEventListener(\n                this.name,\n                this._dispatch as any as (ev: Event) => void,\n                getEventOptions(this.flags) as boolean);\n        }\n    }\n\n    deactivate(): void {\n        if (!this._deactivating) {\n            this._deactivating = true;\n            scheduleMacrotask(() => {\n                if (this._deactivating) {\n                    document.removeEventListener(\n                        this.name,\n                        this._dispatch as any as (ev: Event) => void,\n                        getEventOptions(this.flags) as boolean);\n                    super.deactivate();\n                    this._deactivating = false;\n                }\n            });\n        }\n    }\n}\n","import { nodeDepth } from \"../common/dom\";\nimport { EventDispatcher } from \"./event_dispatcher\";\nimport { EventHandler } from \"./event_handler\";\nimport { getEventHandlerListFromDOMNode } from \"./utils\";\n\n/**\n * Dispatch Target.\n */\nexport interface DispatchTarget {\n    /**\n     * Target Element.\n     */\n    target: Element;\n    /**\n     * Matched Event Handlers.\n     */\n    handlers: EventHandler<any, any>[];\n}\n\n/**\n * Accumulate Event Handlers that has a matching Event Dispatcher.\n *\n * @param result Result array.\n * @param target Target Element.\n * @param dispatcher Event Dispatcher.\n */\nexport function accumulateDispatchTargetsFromElement(\n    result: DispatchTarget[],\n    target: Element,\n    dispatcher: EventDispatcher<any, any>,\n): void {\n    const events = getEventHandlerListFromDOMNode(target);\n    if (events) {\n        let matches: EventHandler<any, any>[] | undefined;\n        const keys = Object.keys(events);\n        for (let i = 0; i < keys.length; i++) {\n            const ev = events[keys[i]];\n            if (ev.dispatcher === dispatcher) {\n                if (!matches) {\n                    matches = [ev];\n                } else {\n                    matches.push(ev);\n                }\n            }\n        }\n        if (matches) {\n            result.push({\n                target: target,\n                handlers: matches,\n            });\n        }\n    }\n}\n\n/**\n * Traverses the DOM tree from the target Element to the document top and accumulates Dispatch Targets that has matching\n * Event Dispatcher.\n *\n * @param target DOM Element.\n * @param dispatcher Event Dispatcher instance.\n * @returns An array of Dispatch Targets.\n */\nexport function accumulateDispatchTargets(\n    target: Element | null,\n    dispatcher: EventDispatcher<any, any>,\n): DispatchTarget[] {\n    const result: DispatchTarget[] = [];\n\n    while (target) {\n        accumulateDispatchTargetsFromElement(result, target, dispatcher);\n        target = target.parentElement;\n    }\n\n    return result;\n}\n\n/**\n * Dispatch targets beneath common ancestor.\n */\nexport interface DispatchTargetsWithCommonAncestor {\n    /**\n     * Left subtree.\n     */\n    a: DispatchTarget[];\n    /**\n     * Right subtree.\n     */\n    b: DispatchTarget[];\n}\n\n/**\n * Traverses the DOM from the two targets and accumulates Dispatch Targets that has matching Event Dispatchers until it\n * finds the common ancestor.\n *\n * @param a Left element.\n * @param b Right element.\n * @param aDispatcher Left Event Dispatcher.\n * @param bDispatcher Right Event Dispatcher.\n * @returns Object with a collection of DispatchTargets for left and right subtree.\n */\nexport function accumulateDispatchTargetsUntilCommonAncestor(\n    a: Element,\n    b: Element,\n    aDispatcher: EventDispatcher<any, any>,\n    bDispatcher: EventDispatcher<any, any>,\n): DispatchTargetsWithCommonAncestor {\n\n    const result: DispatchTargetsWithCommonAncestor = {\n        a: [],\n        b: [],\n    };\n\n    let aDepth = nodeDepth(a);\n    let bDepth = nodeDepth(b);\n\n    while (aDepth - bDepth > 0) {\n        accumulateDispatchTargetsFromElement(result.a, a, aDispatcher);\n        a = a.parentNode as Element;\n        aDepth--;\n    }\n\n    while (bDepth - aDepth > 0) {\n        accumulateDispatchTargetsFromElement(result.b, b, bDispatcher);\n        b = b.parentNode as Element;\n        bDepth--;\n    }\n\n    while (aDepth-- > 0) {\n        if (a === b) {\n            break;\n        }\n        accumulateDispatchTargetsFromElement(result.a, a, aDispatcher);\n        accumulateDispatchTargetsFromElement(result.b, b, bDispatcher);\n        a = a.parentNode as Element;\n        b = b.parentNode as Element;\n    }\n\n    return result;\n}\n","import { SyntheticEventFlags } from \"./flags\";\n\n/**\n * Synthetic Event.\n */\nexport abstract class SyntheticEvent<D> {\n    _flags: SyntheticEventFlags;\n    _data: D;\n    readonly target: EventTarget;\n    currentTarget: EventTarget;\n    timeStamp: number;\n\n    constructor(flags: SyntheticEventFlags, data: D, target: EventTarget) {\n        this._flags = flags;\n        this._data = data;\n        this.target = target;\n        this.currentTarget = target;\n    }\n\n    get defaultPrevented(): boolean {\n        return !!(this._flags & SyntheticEventFlags.PreventedDefault);\n    }\n\n    get bubbles(): boolean {\n        return !!(this._flags & SyntheticEventFlags.Bubbles);\n    }\n\n    get cancelable(): boolean {\n        return !!(this._flags & SyntheticEventFlags.Cancelable);\n    }\n\n    get isTrusted(): boolean {\n        return !!(this._flags & SyntheticEventFlags.IsTrusted);\n    }\n\n    get eventPhase(): number {\n        if (this._flags & SyntheticEventFlags.AtTargetPhase) {\n            return 2;\n        } else if (this._flags & SyntheticEventFlags.BubblePhase) {\n            return 3;\n        }\n        return 1;\n    }\n\n    stopPropagation() {\n        this._flags |= SyntheticEventFlags.StoppedPropagation;\n    }\n\n    stopImmediatePropagation() {\n        this._flags |= SyntheticEventFlags.StoppedPropagation | SyntheticEventFlags.StoppedImmediatePropagation;\n    }\n\n    preventDefault() {\n        this._flags |= SyntheticEventFlags.PreventedDefault;\n    }\n\n}\n\nexport interface SyntheticEventClass<D, E extends SyntheticEvent<any>> {\n    new (flags: SyntheticEventFlags, data: D, target: EventTarget): E;\n}\n\nexport class SyntheticDOMEvent<D extends Event> extends SyntheticEvent<D> implements Event {\n    /**\n     * @deprecated\n     */\n    initEvent: (eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean) => void;\n\n    /**\n     * Old IE Property.\n     *\n     * @deprecated\n     */\n    cancelBubble: boolean;\n    /**\n     * Old IE Property.\n     *\n     * @deprecated\n     */\n    returnValue: boolean;\n    /**\n     * Old IE Property.\n     *\n     * @deprecated\n     */\n    readonly srcElement: Element | null;\n\n    get timeStamp() {\n        return this._data.timeStamp;\n    }\n\n    get type() {\n        return this._data.type;\n    }\n\n    get AT_TARGET(): number {\n        return this._data.AT_TARGET;\n    }\n\n    get BUBBLING_PHASE(): number {\n        return this._data.BUBBLING_PHASE;\n    }\n\n    get CAPTURING_PHASE(): number {\n        return this._data.CAPTURING_PHASE;\n    }\n\n    preventDefault() {\n        this._flags |= SyntheticEventFlags.PreventedDefault;\n        this._data.preventDefault();\n    }\n}\n\nexport class SyntheticUIEvent<T extends UIEvent> extends SyntheticDOMEvent<T> implements UIEvent {\n    /**\n     * @deprecated\n     */\n    initUIEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        detailArg: number,\n    ) => void;\n\n    get detail() {\n        return this._data.detail;\n    }\n\n    get view() {\n        return this._data.view;\n    }\n}\n\nexport class SyntheticKeyboardEvent extends SyntheticUIEvent<KeyboardEvent> implements KeyboardEvent {\n    /**\n     * @deprecated\n     */\n    initKeyboardEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        keyArg: string,\n        locationArg: number,\n        modifiersListArg: string,\n        repeat: boolean,\n        locale: string,\n    ) => void;\n\n    get altKey(): boolean {\n        return this._data.altKey;\n    }\n\n    get char(): string | null {\n        return this._data.char;\n    }\n\n    get charCode(): number {\n        return this._data.charCode;\n    }\n\n    get ctrlKey(): boolean {\n        return this._data.ctrlKey;\n    }\n\n    get key(): string {\n        return this._data.key;\n    }\n\n    get keyCode(): number {\n        return this._data.keyCode;\n    }\n\n    get locale(): string {\n        return this._data.locale;\n    }\n\n    get location(): number {\n        return this._data.location;\n    }\n\n    get metaKey(): boolean {\n        return this._data.metaKey;\n    }\n\n    get repeat(): boolean {\n        return this._data.repeat;\n    }\n\n    get shiftKey(): boolean {\n        return this._data.shiftKey;\n    }\n\n    get which(): number {\n        return this._data.which;\n    }\n\n    get code(): string {\n        return this._data.code;\n    }\n\n    get DOM_KEY_LOCATION_JOYSTICK(): number {\n        return this._data.DOM_KEY_LOCATION_JOYSTICK;\n    }\n\n    get DOM_KEY_LOCATION_LEFT(): number {\n        return this._data.DOM_KEY_LOCATION_LEFT;\n    }\n\n    get DOM_KEY_LOCATION_MOBILE(): number {\n        return this._data.DOM_KEY_LOCATION_MOBILE;\n    }\n\n    get DOM_KEY_LOCATION_NUMPAD(): number {\n        return this._data.DOM_KEY_LOCATION_NUMPAD;\n    }\n\n    get DOM_KEY_LOCATION_RIGHT(): number {\n        return this._data.DOM_KEY_LOCATION_RIGHT;\n    }\n\n    get DOM_KEY_LOCATION_STANDARD(): number {\n        return this._data.DOM_KEY_LOCATION_STANDARD;\n    }\n\n    getModifierState(keyArg: string): boolean {\n        return this._data.getModifierState(keyArg);\n    }\n}\n\nexport class SyntheticMouseEvent<T extends MouseEvent> extends SyntheticUIEvent<T> implements MouseEvent {\n    /**\n     * @deprecated\n     */\n    initMouseEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        detailArg: number,\n        screenXArg: number,\n        screenYArg: number,\n        clientXArg: number,\n        clientYArg: number,\n        ctrlKeyArg: boolean,\n        altKeyArg: boolean,\n        shiftKeyArg: boolean,\n        metaKeyArg: boolean,\n        buttonArg: number,\n        relatedTargetArg: EventTarget | null,\n    ) => void;\n\n    get altKey(): boolean {\n        return this._data.altKey;\n    }\n\n    get button(): number {\n        return this._data.button;\n    }\n\n    get buttons(): number {\n        return this._data.buttons;\n    }\n\n    get clientX(): number {\n        return this._data.clientX;\n    }\n\n    get clientY(): number {\n        return this._data.clientY;\n    }\n\n    get ctrlKey(): boolean {\n        return this._data.ctrlKey;\n    }\n\n    get fromElement(): Element {\n        return this._data.fromElement;\n    }\n\n    get layerX(): number {\n        return this._data.layerX;\n    }\n\n    get layerY(): number {\n        return this._data.layerY;\n    }\n\n    get metaKey(): boolean {\n        return this._data.metaKey;\n    }\n\n    get movementX(): number {\n        return this._data.movementX;\n    }\n\n    get movementY(): number {\n        return this._data.movementY;\n    }\n\n    get offsetX(): number {\n        return this._data.offsetX;\n    }\n\n    get offsetY(): number {\n        return this._data.offsetY;\n    }\n\n    get pageX(): number {\n        return this._data.pageX;\n    }\n\n    get pageY(): number {\n        return this._data.pageY;\n    }\n\n    get relatedTarget(): EventTarget {\n        return this._data.relatedTarget;\n    }\n\n    get screenX(): number {\n        return this._data.screenX;\n    }\n\n    get screenY(): number {\n        return this._data.screenY;\n    }\n\n    get shiftKey(): boolean {\n        return this._data.shiftKey;\n    }\n\n    get toElement(): Element {\n        return this._data.toElement;\n    }\n\n    get which(): number {\n        return this._data.which;\n    }\n\n    get x(): number {\n        return this._data.x;\n    }\n\n    get y(): number {\n        return this._data.y;\n    }\n\n    getModifierState(keyArg: string): boolean {\n        return this._data.getModifierState(keyArg);\n    }\n}\n\nexport class SyntheticTouchEvent extends SyntheticUIEvent<TouchEvent> implements TouchEvent {\n    get altKey(): boolean {\n        return this._data.altKey;\n    }\n\n    get changedTouches(): TouchList {\n        return this._data.changedTouches;\n    }\n\n    get ctrlKey(): boolean {\n        return this._data.ctrlKey;\n    }\n\n    get metaKey(): boolean {\n        return this._data.metaKey;\n    }\n\n    get shiftKey(): boolean {\n        return this._data.shiftKey;\n    }\n\n    get targetTouches(): TouchList {\n        return this._data.targetTouches;\n    }\n\n    get touches(): TouchList {\n        return this._data.touches;\n    }\n}\n\nexport class SyntheticPointerEvent extends SyntheticMouseEvent<PointerEvent> implements PointerEvent {\n    /**\n     * @deprecated\n     */\n    initPointerEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        detailArg: number,\n        screenXArg: number,\n        screenYArg: number,\n        clientXArg: number,\n        clientYArg: number,\n        ctrlKeyArg: boolean,\n        altKeyArg: boolean,\n        shiftKeyArg: boolean,\n        metaKeyArg: boolean,\n        buttonArg: number,\n        relatedTargetArg: EventTarget,\n        offsetXArg: number,\n        offsetYArg: number,\n        widthArg: number,\n        heightArg: number,\n        pressure: number,\n        rotation: number,\n        tiltX: number,\n        tiltY: number,\n        pointerIdArg: number,\n        pointerType: any,\n        hwTimestampArg: number,\n        isPrimary: boolean,\n    ) => void;\n\n    get currentPoint(): any {\n        return this._data.currentPoint;\n    }\n\n    get height(): number {\n        return this._data.height;\n    }\n\n    get hwTimestamp(): number {\n        return this._data.hwTimestamp;\n    }\n\n    get intermediatePoints(): any {\n        return this._data.intermediatePoints;\n    }\n\n    get isPrimary(): boolean {\n        return this._data.isPrimary;\n    }\n\n    get pointerId(): number {\n        return this._data.pointerId;\n    }\n\n    get pointerType(): any {\n        return this._data.pointerType;\n    }\n\n    get pressure(): number {\n        return this._data.pressure;\n    }\n\n    get rotation(): number {\n        return this._data.rotation;\n    }\n\n    get tiltX(): number {\n        return this._data.tiltX;\n    }\n\n    get tiltY(): number {\n        return this._data.tiltY;\n    }\n\n    get width(): number {\n        return this._data.width;\n    }\n\n    getCurrentPoint(element: Element): void {\n        return this._data.getCurrentPoint(element);\n    }\n\n    getIntermediatePoints(element: Element): void {\n        return this._data.getIntermediatePoints(element);\n    }\n}\n\nexport class SyntheticDragEvent extends SyntheticMouseEvent<DragEvent> implements DragEvent {\n    /**\n     * @deprecated\n     */\n    initDragEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        detailArg: number,\n        screenXArg: number,\n        screenYArg: number,\n        clientXArg: number,\n        clientYArg: number,\n        ctrlKeyArg: boolean,\n        altKeyArg: boolean,\n        shiftKeyArg: boolean,\n        metaKeyArg: boolean,\n        buttonArg: number,\n        relatedTargetArg: EventTarget,\n        dataTransferArg: DataTransfer,\n    ) => void;\n\n    msConvertURL: (\n        file: File,\n        targetType: string,\n        targetURL?: string,\n    ) => void;\n\n    get dataTransfer(): DataTransfer {\n        return this._data.dataTransfer;\n    }\n}\n\nexport class SyntheticWheelEvent extends SyntheticMouseEvent<WheelEvent> implements WheelEvent {\n    /**\n     * @deprecated\n     */\n    initWheelEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window, detailArg:\n            number, screenXArg: number,\n        screenYArg: number,\n        clientXArg: number,\n        clientYArg: number,\n        buttonArg: number,\n        relatedTargetArg: EventTarget,\n        modifiersListArg: string,\n        deltaXArg: number,\n        deltaYArg: number,\n        deltaZArg: number,\n        deltaMode: number,\n    ) => void;\n\n    getCurrentPoint: (element: Element) => void;\n\n    readonly wheelDelta: number;\n    readonly wheelDeltaX: number;\n    readonly wheelDeltaY: number;\n\n    get deltaMode(): number {\n        return this._data.deltaMode;\n    }\n\n    get deltaX(): number {\n        return this._data.deltaX;\n    }\n\n    get deltaY(): number {\n        return this._data.deltaY;\n    }\n\n    get deltaZ(): number {\n        return this._data.deltaZ;\n    }\n\n    get DOM_DELTA_LINE(): number {\n        return this._data.DOM_DELTA_LINE;\n    }\n    get DOM_DELTA_PAGE(): number {\n        return this._data.DOM_DELTA_PAGE;\n    }\n    get DOM_DELTA_PIXEL(): number {\n        return this._data.DOM_DELTA_PIXEL;\n    }\n}\n\nexport class SyntheticFocusEvent extends SyntheticUIEvent<FocusEvent> implements FocusEvent {\n    /**\n     * @deprecated\n     */\n    initFocusEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        viewArg: Window,\n        detailArg: number,\n        relatedTargetArg: EventTarget,\n    ) => void;\n\n    get relatedTarget(): EventTarget {\n        return this._data.relatedTarget;\n    }\n}\n\nexport class SyntheticAriaRequestEvent extends SyntheticDOMEvent<AriaRequestEvent> implements AriaRequestEvent {\n    get attributeName(): string {\n        return this._data.attributeName;\n    }\n\n    get attributeValue(): string | null {\n        return this._data.attributeValue;\n    }\n    set attributeValue(value: string | null) {\n        this._data.attributeValue = value;\n    }\n}\n\nexport class SyntheticClipboardEvent extends SyntheticDOMEvent<ClipboardEvent> implements ClipboardEvent {\n    get clipboardData(): DataTransfer {\n        return this._data.clipboardData;\n    }\n}\n\nexport class SyntheticErrorEvent extends SyntheticDOMEvent<ErrorEvent> implements ErrorEvent {\n    /**\n     * @deprecated\n     */\n    initErrorEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        messageArg: string,\n        filenameArg: string,\n        linenoArg: number,\n    ) => void;\n\n    get colno(): number {\n        return this._data.colno;\n    }\n\n    get error(): any {\n        return this._data.error;\n    }\n\n    get filename(): string {\n        return this._data.filename;\n    }\n\n    get lineno(): number {\n        return this._data.lineno;\n    }\n\n    get message(): string {\n        return this._data.message;\n    }\n}\n\nexport class SyntheticMediaEncryptedEvent extends SyntheticDOMEvent<MediaEncryptedEvent>\n    implements MediaEncryptedEvent {\n\n    get initData(): ArrayBuffer | null {\n        return this._data.initData;\n    }\n\n    get initDataType(): string {\n        return this._data.initDataType;\n    }\n}\n\nexport class SyntheticMediaStreamErrorEvent extends SyntheticDOMEvent<MediaStreamErrorEvent>\n    implements MediaStreamErrorEvent {\n\n    get error(): MediaStreamError | null {\n        return this._data.error;\n    }\n}\n\nexport class SyntheticProgressEvent extends SyntheticDOMEvent<ProgressEvent> implements ProgressEvent {\n    /**\n     * @deprecated\n     */\n    initProgressEvent: (\n        typeArg: string,\n        canBubbleArg: boolean,\n        cancelableArg: boolean,\n        lengthComputableArg: boolean,\n        loadedArg: number,\n        totalArg: number,\n    ) => void;\n\n    get lengthComputable(): boolean {\n        return this._data.lengthComputable;\n    }\n\n    get loaded(): number {\n        return this._data.loaded;\n    }\n\n    get total(): number {\n        return this._data.total;\n    }\n}\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { EventHandlerFlags, NativeEventDispatcherFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\nimport { EventDispatcher } from \"./event_dispatcher\";\nimport { NativeEventDispatcher } from \"./native_event_dispatcher\";\nimport {\n    SyntheticEvent, SyntheticUIEvent, SyntheticDOMEvent, SyntheticDragEvent, SyntheticErrorEvent,\n    SyntheticKeyboardEvent, SyntheticFocusEvent, SyntheticMediaEncryptedEvent, SyntheticMediaStreamErrorEvent,\n    SyntheticMouseEvent, SyntheticAriaRequestEvent, SyntheticClipboardEvent, SyntheticPointerEvent,\n    SyntheticTouchEvent, SyntheticWheelEvent, SyntheticProgressEvent,\n} from \"./synthetic_event\";\n\n/**\n * Helper function that creates Event Handler objects.\n *\n * @param dispatcher Dispatcher instance.\n * @param fn Event Handler function.\n * @param options Event Options. Value with a boolean type indicates that events of this type should use capture mode\n *   and it will be dispatched to the registered listener before being dispatched to any EventTarget beneath it in the\n *   DOM tree.\n * @returns EventHandler object.\n */\nexport function createEventHandler<I, O extends SyntheticEvent<I>>(\n    dispatcher: EventDispatcher<I, O>,\n    fn: (ev: O) => void,\n    capture?: boolean): EventHandler<I, O> {\n\n    return {\n        dispatcher: dispatcher,\n        flags: capture ? EventHandlerFlags.Capture : EventHandlerFlags.Bubble,\n        fn: fn,\n    } as EventHandler<I, O>;\n}\n\nexport interface NativeEventDispatchersList {\n    abort: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    activate: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    ariarequest: EventDispatcher<AriaRequestEvent, SyntheticAriaRequestEvent>;\n    beforeactivate: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    beforecopy: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    beforecut: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    beforedeactivate: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    beforepaste: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    blur: EventDispatcher<FocusEvent, SyntheticFocusEvent>;\n    canplay: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    canplaythrough: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    change: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    click: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    contextmenu: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    copy: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    cuechange: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    cut: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    dblclick: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    deactivate: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    drag: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    dragend: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    dragenter: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    dragleave: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    dragover: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    dragstart: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    drop: EventDispatcher<DragEvent, SyntheticDragEvent>;\n    durationchange: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    emptied: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    encrypted: EventDispatcher<MediaEncryptedEvent, SyntheticMediaEncryptedEvent>;\n    ended: EventDispatcher<MediaStreamErrorEvent, SyntheticMediaStreamErrorEvent>;\n    error: EventDispatcher<ErrorEvent, SyntheticErrorEvent>;\n    focus: EventDispatcher<FocusEvent, SyntheticFocusEvent>;\n    gotpointercapture: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    input: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    invalid: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    keydown: EventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>;\n    keypress: EventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>;\n    keyup: EventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>;\n    load: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    loadeddata: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    loadedmetadata: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    loadstart: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    lostpointercapture: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    mousedown: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseenter: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseleave: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mousemove: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseout: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseover: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseup: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    paste: EventDispatcher<ClipboardEvent, SyntheticClipboardEvent>;\n    pause: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    play: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    playing: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    pointercancel: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerdown: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerenter: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerleave: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointermove: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerout: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerover: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    pointerup: EventDispatcher<PointerEvent, SyntheticPointerEvent>;\n    progress: EventDispatcher<ProgressEvent, SyntheticProgressEvent>;\n    ratechange: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    reset: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    scroll: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    seeked: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    seeking: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    select: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    selectstart: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    stalled: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    submit: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    suspend: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    timeupdate: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    touchcancel: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchend: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchmove: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchstart: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    unload: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    volumechange: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    waiting: EventDispatcher<Event, SyntheticDOMEvent<Event>>;\n    wheel: EventDispatcher<WheelEvent, SyntheticWheelEvent>;\n};\n\n\n/* tslint:disable:max-line-length */\nexport const NativeEventDispatchers: NativeEventDispatchersList = {\n    abort: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture, \"abort\", SyntheticUIEvent),\n    activate: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"activate\", SyntheticUIEvent),\n    ariarequest: new NativeEventDispatcher<AriaRequestEvent, SyntheticAriaRequestEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"ariarequest\", SyntheticAriaRequestEvent),\n    beforeactivate: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"beforeactivate\", SyntheticUIEvent),\n    beforecopy: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture, \"beforecopy\", SyntheticClipboardEvent),\n    beforecut: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"beforecut\", SyntheticClipboardEvent),\n    beforedeactivate: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"beforedeactivate\", SyntheticUIEvent),\n    beforepaste: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"beforepaste\", SyntheticClipboardEvent),\n    blur: new NativeEventDispatcher<FocusEvent, SyntheticFocusEvent>(NativeEventDispatcherFlags.Capture, \"blur\", SyntheticFocusEvent),\n    canplay: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"canplay\", SyntheticDOMEvent),\n    canplaythrough: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"canplaythrough\", SyntheticDOMEvent),\n    change: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"change\", SyntheticDOMEvent),\n    click: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"click\", SyntheticMouseEvent),\n    contextmenu: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"contextmenu\", SyntheticPointerEvent),\n    copy: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"copy\", SyntheticClipboardEvent),\n    cuechange: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"cuechange\", SyntheticDOMEvent),\n    cut: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"cut\", SyntheticClipboardEvent),\n    dblclick: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dblclick\", SyntheticMouseEvent),\n    deactivate: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"deactivate\", SyntheticUIEvent),\n    drag: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"drag\", SyntheticDragEvent),\n    dragend: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dragend\", SyntheticDragEvent),\n    dragenter: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dragenter\", SyntheticDragEvent),\n    dragleave: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dragleave\", SyntheticDragEvent),\n    dragover: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dragover\", SyntheticDragEvent),\n    dragstart: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"dragstart\", SyntheticDragEvent),\n    drop: new NativeEventDispatcher<DragEvent, SyntheticDragEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"drop\", SyntheticDragEvent),\n    durationchange: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"durationchange\", SyntheticDOMEvent),\n    emptied: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"emptied\", SyntheticDOMEvent),\n    encrypted: new NativeEventDispatcher<MediaEncryptedEvent, SyntheticMediaEncryptedEvent>(NativeEventDispatcherFlags.Capture, \"encrypted\", SyntheticMediaEncryptedEvent),\n    ended: new NativeEventDispatcher<MediaStreamErrorEvent, SyntheticMediaStreamErrorEvent>(NativeEventDispatcherFlags.Capture, \"ended\", SyntheticMediaStreamErrorEvent),\n    error: new NativeEventDispatcher<ErrorEvent, SyntheticErrorEvent>(NativeEventDispatcherFlags.Capture, \"error\", SyntheticErrorEvent),\n    focus: new NativeEventDispatcher<FocusEvent, SyntheticFocusEvent>(NativeEventDispatcherFlags.Capture, \"focus\", SyntheticFocusEvent),\n    gotpointercapture: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture, \"gotpointercapture\", SyntheticPointerEvent),\n    input: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"input\", SyntheticDOMEvent),\n    invalid: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"invalid\", SyntheticDOMEvent),\n    keydown: new NativeEventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"keydown\", SyntheticKeyboardEvent),\n    keypress: new NativeEventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"keypress\", SyntheticKeyboardEvent),\n    keyup: new NativeEventDispatcher<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"keyup\", SyntheticKeyboardEvent),\n    load: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"load\", SyntheticDOMEvent),\n    loadeddata: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"loadeddata\", SyntheticDOMEvent),\n    loadedmetadata: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"loadedmetadata\", SyntheticDOMEvent),\n    loadstart: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"loadstart\", SyntheticDOMEvent),\n    lostpointercapture: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture, \"lostpointercapture\", SyntheticPointerEvent),\n    mousedown: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"mousedown\", SyntheticMouseEvent),\n    mouseenter: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Passive, \"mouseenter\", SyntheticMouseEvent),\n    mouseleave: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Passive, \"mouseleave\", SyntheticMouseEvent),\n    mousemove: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"mousemove\", SyntheticMouseEvent),\n    mouseout: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"mouseout\", SyntheticMouseEvent),\n    mouseover: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"mouseover\", SyntheticMouseEvent),\n    mouseup: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"mouseup\", SyntheticMouseEvent),\n    paste: new NativeEventDispatcher<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"paste\", SyntheticClipboardEvent),\n    pause: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"pause\", SyntheticDOMEvent),\n    play: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"play\", SyntheticDOMEvent),\n    playing: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"playing\", SyntheticDOMEvent),\n    pointercancel: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointercancel\", SyntheticPointerEvent),\n    pointerdown: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointerdown\", SyntheticPointerEvent),\n    pointerenter: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture, \"pointerenter\", SyntheticPointerEvent),\n    pointerleave: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture, \"pointerleave\", SyntheticPointerEvent),\n    pointermove: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointermove\", SyntheticPointerEvent),\n    pointerout: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointerout\", SyntheticPointerEvent),\n    pointerover: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointerover\", SyntheticPointerEvent),\n    pointerup: new NativeEventDispatcher<PointerEvent, SyntheticPointerEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"pointerup\", SyntheticPointerEvent),\n    progress: new NativeEventDispatcher<ProgressEvent, SyntheticProgressEvent>(NativeEventDispatcherFlags.Capture, \"progress\", SyntheticProgressEvent),\n    ratechange: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"ratechange\", SyntheticDOMEvent),\n    reset: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"reset\", SyntheticDOMEvent),\n    scroll: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Passive, \"scroll\", SyntheticUIEvent),\n    seeked: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"seeked\", SyntheticDOMEvent),\n    seeking: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"seeking\", SyntheticDOMEvent),\n    select: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"select\", SyntheticUIEvent),\n    selectstart: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"selectstart\", SyntheticDOMEvent),\n    stalled: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"stalled\", SyntheticDOMEvent),\n    submit: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"submit\", SyntheticDOMEvent),\n    suspend: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"suspend\", SyntheticDOMEvent),\n    timeupdate: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"timeupdate\", SyntheticDOMEvent),\n    touchcancel: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"touchcancel\", SyntheticTouchEvent),\n    touchend: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"touchend\", SyntheticTouchEvent),\n    touchmove: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"touchmove\", SyntheticTouchEvent),\n    touchstart: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"touchstart\", SyntheticTouchEvent),\n    unload: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"unload\", SyntheticDOMEvent),\n    volumechange: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"volumechange\", SyntheticDOMEvent),\n    waiting: new NativeEventDispatcher<Event, SyntheticDOMEvent<Event>>(NativeEventDispatcherFlags.Capture, \"waiting\", SyntheticDOMEvent),\n    wheel: new NativeEventDispatcher<WheelEvent, SyntheticWheelEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles | NativeEventDispatcherFlags.Passive, \"wheel\", SyntheticWheelEvent),\n};\n\nexport interface NativeActiveEventDispatchersList {\n    mousedown: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseenter: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseleave: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mousemove: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseout: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseover: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    mouseup: EventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>;\n    scroll: EventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>;\n    touchcancel: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchend: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchmove: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    touchstart: EventDispatcher<TouchEvent, SyntheticTouchEvent>;\n    wheel: EventDispatcher<WheelEvent, SyntheticWheelEvent>;\n}\n\nexport const NativeActiveEventDispatchers = {\n    mousedown: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"mousedown\", SyntheticMouseEvent),\n    mouseenter: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture, \"mouseenter\", SyntheticMouseEvent),\n    mouseleave: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture, \"mouseleave\", SyntheticMouseEvent),\n    mousemove: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"mousemove\", SyntheticMouseEvent),\n    mouseout: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"mouseout\", SyntheticMouseEvent),\n    mouseover: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"mouseover\", SyntheticMouseEvent),\n    mouseup: new NativeEventDispatcher<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"mouseup\", SyntheticMouseEvent),\n    scroll: new NativeEventDispatcher<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatcherFlags.Capture, \"scroll\", SyntheticUIEvent),\n    touchcancel: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"touchcancel\", SyntheticTouchEvent),\n    touchend: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"touchend\", SyntheticTouchEvent),\n    touchmove: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"touchmove\", SyntheticTouchEvent),\n    touchstart: new NativeEventDispatcher<TouchEvent, SyntheticTouchEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"touchstart\", SyntheticTouchEvent),\n    wheel: new NativeEventDispatcher<WheelEvent, SyntheticWheelEvent>(NativeEventDispatcherFlags.Capture | NativeEventDispatcherFlags.Bubbles, \"wheel\", SyntheticWheelEvent),\n};\n\n/**\n * Events.\n */\nexport const Events = {\n    onAbort: function createAbortEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.abort, handler, capture);\n    },\n    onActivate: function createActivateEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.activate, handler, capture);\n    },\n    onAriaRequest: function createAriarequestEventHandler(\n        handler: (ev: SyntheticAriaRequestEvent) => void,\n        capture = false,\n    ): EventHandler<AriaRequestEvent, SyntheticAriaRequestEvent> {\n        return createEventHandler<AriaRequestEvent, SyntheticAriaRequestEvent>(NativeEventDispatchers.ariarequest, handler, capture);\n    },\n    onBeforeActivate: function createBeforeactivateEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.beforeactivate, handler, capture);\n    },\n    onBeforeCopy: function createBeforecopyEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.beforecopy, handler, capture);\n    },\n    onBeforeCut: function createBeforecutEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.beforecut, handler, capture);\n    },\n    onBeforeDeactivate: function createBeforedeactivateEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.beforedeactivate, handler, capture);\n    },\n    onBeforePaste: function createBeforepasteEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.beforepaste, handler, capture);\n    },\n    onBlur: function createBlurEventHandler(\n        handler: (ev: SyntheticFocusEvent) => void,\n        capture = false,\n    ): EventHandler<FocusEvent, SyntheticFocusEvent> {\n        return createEventHandler<FocusEvent, SyntheticFocusEvent>(NativeEventDispatchers.blur, handler, capture);\n    },\n    onCanPlay: function createCanplayEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.canplay, handler, capture);\n    },\n    onCanPlaythrough: function createCanplaythroughEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.canplaythrough, handler, capture);\n    },\n    onChange: function createChangeEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.change, handler, capture);\n    },\n    onClick: function createClickEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.click, handler, capture);\n    },\n    onContextMenu: function createContextmenuEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.contextmenu, handler, capture);\n    },\n    onCopy: function createCopyEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.copy, handler, capture);\n    },\n    onCueChange: function createCuechangeEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.cuechange, handler, capture);\n    },\n    onCut: function createCutEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.cut, handler, capture);\n    },\n    onDoubleClick: function createDblclickEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.dblclick, handler, capture);\n    },\n    onDeactivate: function createDeactivateEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.deactivate, handler, capture);\n    },\n    onDrag: function createDragEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.drag, handler, capture);\n    },\n    onDragEnd: function createDragendEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.dragend, handler, capture);\n    },\n    onDragEnter: function createDragenterEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.dragenter, handler, capture);\n    },\n    onDragLeave: function createDragleaveEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.dragleave, handler, capture);\n    },\n    onDragOver: function createDragoverEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.dragover, handler, capture);\n    },\n    onDragStart: function createDragstartEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.dragstart, handler, capture);\n    },\n    onDrop: function createDropEventHandler(\n        handler: (ev: SyntheticDragEvent) => void,\n        capture = false,\n    ): EventHandler<DragEvent, SyntheticDragEvent> {\n        return createEventHandler<DragEvent, SyntheticDragEvent>(NativeEventDispatchers.drop, handler, capture);\n    },\n    onDurationChange: function createDurationchangeEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.durationchange, handler, capture);\n    },\n    onEmptied: function createEmptiedEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.emptied, handler, capture);\n    },\n    onEncrypted: function createEncryptedEventHandler(\n        handler: (ev: SyntheticMediaEncryptedEvent) => void,\n        capture = false,\n    ): EventHandler<MediaEncryptedEvent, SyntheticMediaEncryptedEvent> {\n        return createEventHandler<MediaEncryptedEvent, SyntheticMediaEncryptedEvent>(NativeEventDispatchers.encrypted, handler, capture);\n    },\n    onEnded: function createEndedEventHandler(\n        handler: (ev: SyntheticMediaStreamErrorEvent) => void,\n        capture = false,\n    ): EventHandler<MediaStreamErrorEvent, SyntheticMediaStreamErrorEvent> {\n        return createEventHandler<MediaStreamErrorEvent, SyntheticMediaStreamErrorEvent>(NativeEventDispatchers.ended, handler, capture);\n    },\n    onError: function createErrorEventHandler(\n        handler: (ev: SyntheticErrorEvent) => void,\n        capture = false,\n    ): EventHandler<ErrorEvent, SyntheticErrorEvent> {\n        return createEventHandler<ErrorEvent, SyntheticErrorEvent>(NativeEventDispatchers.error, handler, capture);\n    },\n    onFocus: function createFocusEventHandler(\n        handler: (ev: SyntheticFocusEvent) => void,\n        capture = false,\n    ): EventHandler<FocusEvent, SyntheticFocusEvent> {\n        return createEventHandler<FocusEvent, SyntheticFocusEvent>(NativeEventDispatchers.focus, handler, capture);\n    },\n    onGotPointerCapture: function createGotpointercaptureEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.gotpointercapture, handler, capture);\n    },\n    onInput: function createInputEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.input, handler, capture);\n    },\n    onInvalid: function createInvalidEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.invalid, handler, capture);\n    },\n    onKeyDown: function createKeydownEventHandler(\n        handler: (ev: SyntheticKeyboardEvent) => void,\n        capture = false,\n    ): EventHandler<KeyboardEvent, SyntheticKeyboardEvent> {\n        return createEventHandler<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatchers.keydown, handler, capture);\n    },\n    onKeyPress: function createKeypressEventHandler(\n        handler: (ev: SyntheticKeyboardEvent) => void,\n        capture = false,\n    ): EventHandler<KeyboardEvent, SyntheticKeyboardEvent> {\n        return createEventHandler<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatchers.keypress, handler, capture);\n    },\n    onKeyUp: function createKeyupEventHandler(\n        handler: (ev: SyntheticKeyboardEvent) => void,\n        capture = false,\n    ): EventHandler<KeyboardEvent, SyntheticKeyboardEvent> {\n        return createEventHandler<KeyboardEvent, SyntheticKeyboardEvent>(NativeEventDispatchers.keyup, handler, capture);\n    },\n    onLoad: function createLoadEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.load, handler, capture);\n    },\n    onLoadedData: function createLoadeddataEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.loadeddata, handler, capture);\n    },\n    onLoadedMetadata: function createLoadedmetadataEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.loadedmetadata, handler, capture);\n    },\n    onLoadStart: function createLoadstartEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.loadstart, handler, capture);\n    },\n    onLostPointerCapture: function createLostpointercaptureEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.lostpointercapture, handler, capture);\n    },\n    onMouseDown: function createMousedownEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mousedown, handler, capture);\n    },\n    onMouseEnter: function createMouseenterEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mouseenter, handler, capture);\n    },\n    onMouseLeave: function createMouseleaveEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mouseleave, handler, capture);\n    },\n    onMouseMove: function createMousemoveEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mousemove, handler, capture);\n    },\n    onMouseOut: function createMouseoutEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mouseout, handler, capture);\n    },\n    onMouseOver: function createMouseoverEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mouseover, handler, capture);\n    },\n    onMouseUp: function createMouseupEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeEventDispatchers.mouseup, handler, capture);\n    },\n    onPaste: function createPasteEventHandler(\n        handler: (ev: SyntheticClipboardEvent) => void,\n        capture = false,\n    ): EventHandler<ClipboardEvent, SyntheticClipboardEvent> {\n        return createEventHandler<ClipboardEvent, SyntheticClipboardEvent>(NativeEventDispatchers.paste, handler, capture);\n    },\n    onPause: function createPauseEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.pause, handler, capture);\n    },\n    onPlay: function createPlayEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.play, handler, capture);\n    },\n    onPlaying: function createPlayingEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.playing, handler, capture);\n    },\n    onPointerCancel: function createPointercancelEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointercancel, handler, capture);\n    },\n    onPointerDown: function createPointerdownEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerdown, handler, capture);\n    },\n    onPointerEnter: function createPointerenterEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerenter, handler, capture);\n    },\n    onPointerLeave: function createPointerleaveEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerleave, handler, capture);\n    },\n    onPointerMove: function createPointermoveEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointermove, handler, capture);\n    },\n    onPointerOut: function createPointeroutEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerout, handler, capture);\n    },\n    onPointerOver: function createPointeroverEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerover, handler, capture);\n    },\n    onPointerUp: function createPointerupEventHandler(\n        handler: (ev: SyntheticPointerEvent) => void,\n        capture = false,\n    ): EventHandler<PointerEvent, SyntheticPointerEvent> {\n        return createEventHandler<PointerEvent, SyntheticPointerEvent>(NativeEventDispatchers.pointerup, handler, capture);\n    },\n    onProgress: function createProgressEventHandler(\n        handler: (ev: SyntheticProgressEvent) => void,\n        capture = false,\n    ): EventHandler<ProgressEvent, SyntheticProgressEvent> {\n        return createEventHandler<ProgressEvent, SyntheticProgressEvent>(NativeEventDispatchers.progress, handler, capture);\n    },\n    onRateChange: function createRatechangeEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.ratechange, handler, capture);\n    },\n    onReset: function createResetEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.reset, handler, capture);\n    },\n    onScroll: function createScrollEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.scroll, handler, capture);\n    },\n    onSeeked: function createSeekedEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.seeked, handler, capture);\n    },\n    onSeeking: function createSeekingEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.seeking, handler, capture);\n    },\n    onSelect: function createSelectEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeEventDispatchers.select, handler, capture);\n    },\n    onSelectStart: function createSelectstartEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.selectstart, handler, capture);\n    },\n    onStalled: function createStalledEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.stalled, handler, capture);\n    },\n    onSubmit: function createSubmitEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.submit, handler, capture);\n    },\n    onSuspend: function createSuspendEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.suspend, handler, capture);\n    },\n    onTimeUpdate: function createTimeupdateEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.timeupdate, handler, capture);\n    },\n    onTouchCancel: function createTouchcancelEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeEventDispatchers.touchcancel, handler, capture);\n    },\n    onTouchEnd: function createTouchendEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeEventDispatchers.touchend, handler, capture);\n    },\n    onTouchMove: function createTouchmoveEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeEventDispatchers.touchmove, handler, capture);\n    },\n    onTouchStart: function createTouchstartEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeEventDispatchers.touchstart, handler, capture);\n    },\n    onUnload: function createUnloadEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.unload, handler, capture);\n    },\n    onVolumeChange: function createVolumechangeEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.volumechange, handler, capture);\n    },\n    onWaiting: function createWaitingEventHandler(\n        handler: (ev: SyntheticDOMEvent<Event>) => void,\n        capture = false,\n    ): EventHandler<Event, SyntheticDOMEvent<Event>> {\n        return createEventHandler<Event, SyntheticDOMEvent<Event>>(NativeEventDispatchers.waiting, handler, capture);\n    },\n    onWheel: function createWheelEventHandler(\n        handler: (ev: SyntheticWheelEvent) => void,\n        capture = false,\n    ): EventHandler<WheelEvent, SyntheticWheelEvent> {\n        return createEventHandler<WheelEvent, SyntheticWheelEvent>(NativeEventDispatchers.wheel, handler, capture);\n    },\n};\n\n/**\n * List of Events with disabled passive flag.\n */\nexport const ActiveEvents = {\n    onScroll: function createScrollEventHandler(\n        handler: (ev: SyntheticUIEvent<UIEvent>) => void,\n        capture = false,\n    ): EventHandler<UIEvent, SyntheticUIEvent<UIEvent>> {\n        return createEventHandler<UIEvent, SyntheticUIEvent<UIEvent>>(NativeActiveEventDispatchers.scroll, handler, capture);\n    },\n    onMouseDown: function createMousedownEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mousedown, handler, capture);\n    },\n    onMouseEnter: function createMouseenterEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mouseenter, handler, capture);\n    },\n    onMouseLeave: function createMouseleaveEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mouseleave, handler, capture);\n    },\n    onMouseMove: function createMousemoveEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mousemove, handler, capture);\n    },\n    onMouseOut: function createMouseoutEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mouseout, handler, capture);\n    },\n    onMouseOver: function createMouseoverEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mouseover, handler, capture);\n    },\n    onMouseUp: function createMouseupEventHandler(\n        handler: (ev: SyntheticMouseEvent<MouseEvent>) => void,\n        capture = false,\n    ): EventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>> {\n        return createEventHandler<MouseEvent, SyntheticMouseEvent<MouseEvent>>(NativeActiveEventDispatchers.mouseup, handler, capture);\n    },\n    onTouchCancel: function createTouchcancelEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeActiveEventDispatchers.touchcancel, handler, capture);\n    },\n    onTouchEnd: function createTouchendEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeActiveEventDispatchers.touchend, handler, capture);\n    },\n    onTouchMove: function createTouchmoveEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeActiveEventDispatchers.touchmove, handler, capture);\n    },\n    onTouchStart: function createTouchstartEventHandler(\n        handler: (ev: SyntheticTouchEvent) => void,\n        capture = false,\n    ): EventHandler<TouchEvent, SyntheticTouchEvent> {\n        return createEventHandler<TouchEvent, SyntheticTouchEvent>(NativeActiveEventDispatchers.touchstart, handler, capture);\n    },\n    onWheel: function createWheelEventHandler(\n        handler: (ev: SyntheticWheelEvent) => void,\n        capture = false,\n    ): EventHandler<WheelEvent, SyntheticWheelEvent> {\n        return createEventHandler<WheelEvent, SyntheticWheelEvent>(NativeActiveEventDispatchers.wheel, handler, capture);\n    },\n};\n/* tslint:enable:max-line-length */\n","import { isPropsNotIdentical, isPropsNotShallowEqual } from \"../common/equality\";\nimport { AncestorFlags } from \"../common/html_nesting_rules\";\nimport { ComponentFlags } from \"./flags\";\nimport { Context } from \"./context\";\nimport { VNode } from \"./vnode\";\nimport { currentFrame } from \"../scheduler/scheduler\";\n\n/**\n * Component function constructor.\n */\nexport interface ComponentFunction<P> {\n    (props: P, context?: Context): VNode<any> | undefined;\n    isPropsChanged?: (oldProps: P, newProps: P) => boolean;\n}\n\n/**\n * Component class constructor.\n */\nexport interface ComponentClass<P> {\n    new (props: P, context: Context, owner: Component<any> | undefined): Component<P>;\n}\n\n/**\n * Component is the main building block that is used to build UI applications.\n *\n * Component class has a parametric type `P` to specify `props` type.\n *\n * Example:\n *\n *     class Hello extends Component<string> {\n *       render() {\n *         return $t(`Hello ${this.props}`);\n *       }\n *     }\n *\n *     render($c(Hello, \"world\"), document.getElementById(\"App\")!);\n */\nexport abstract class Component<P> {\n    /**\n     * Flags, see `ComponentFlags` for details.\n     *\n     * Lowest 16 bits are reserved for ivi flags, other bits can be used for user flags.\n     */\n    flags: ComponentFlags;\n    /**\n     * Depth in the components tree.\n     *\n     * Depth property is used by scheduler to determine component priority when updating components.\n     */\n    readonly depth: number;\n    /**\n     * Component properties.\n     */\n    _props: P;\n    /**\n     * Parent context.\n     *\n     * Context that was used to create this component.\n     */\n    _parentContext: Context;\n    /**\n     * Current context.\n     */\n    _context: Context;\n    /**\n     * Owner component.\n     *\n     * Parent component. When owner is an undefined, it means that this component is a root component.\n     */\n    readonly owner: Component<any> | undefined;\n    /**\n     * Virtual DOM root node.\n     */\n    root: VNode<any> | null;\n    /**\n     * Parent DOM node.\n     *\n     * It is used because when root node is changed we will need to replace old DOM node with a new one, and right now\n     * browsers doesn't provide a nice API that doesn't require to know parent nodes.\n     */\n    _parentDOMNode: Node | null;\n    /**\n     * Root DOM node.\n     *\n     * When component is returning another component, they'll share the same DOM node.\n     */\n    _rootDOMNode: Node | null;\n    /**\n     * Ancestor Flags are used to check child nesting violations.\n     */\n    _ancestorFlags: AncestorFlags;\n\n    constructor(props: P, context: Context, owner: Component<any> | undefined) {\n        this.flags = 0;\n        this.depth = owner ? owner.depth + 1 : 0;\n        this._props = props;\n        this._parentContext = context;\n        this._context = context;\n        this.owner = owner;\n        this.root = null;\n        this._parentDOMNode = null;\n        this._rootDOMNode = null;\n    }\n\n    /**\n     * Get current context.\n     *\n     * @returns Current context.\n     */\n    get context(): Context {\n        this.flags |= ComponentFlags.CheckUsingContext;\n        return this._context;\n    }\n\n    /**\n     * Get props.\n     *\n     * @returns Current props.\n     */\n    get props(): P {\n        this.flags |= ComponentFlags.CheckUsingProps;\n        return this._props;\n    }\n\n    /**\n     * Is Component mounted.\n     *\n     * `isMounted` should be used only in one case, to prevent unnecessary work in asynchronous tasks.\n     *\n     * @returns `true` when Component is mounted.\n     */\n    get isMounted(): boolean {\n        return !!(this.flags & ComponentFlags.Mounted);\n    }\n\n    /**\n     * Lifecycle method `isPropsChanged` is used as a hint that can reduce unnecessary updates.\n     *\n     * By default all props changes returns `true`.\n     *\n     * @param oldProps Old props.\n     * @param newProps New props.\n     * @returns `true` when props should be updated.\n     */\n    isPropsChanged(oldProps: P, newProps: P): boolean {\n        return true;\n    }\n\n    /**\n     * Lifecycle method `didReceiveNewProps` is invoked after new props are assigned.\n     *\n     * @param oldProps Old props.\n     * @param newProps New props.\n     */\n    didReceiveNewProps(oldProps: P, newProps: P): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didReceiveNewContext` is invoked after new context is assigned.\n     *\n     * @param oldContext Old context.\n     * @param newContext New Context.\n     */\n    didReceiveNewContext(oldContext: Context, newContext: Context): void {\n        // TODO: this lifecycle method might be slightly confusing because it actually works with parent contexts.\n        // Maybe rename it to something more appropriate?\n        //\n        // NOTE: `willReceiveNewContext` will be even more confusing because components provide an API to get current\n        // context with `this.context`. `willReceiveNewProps` were changed to `didReceiveNewProps` to make it look like\n        // this lifecycle method.\n\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `updateContext` is used to modify current context.\n     *\n     * It will be invoked when component is created, each time when parent context is changed, each time when props are\n     * changed, and when component is updated with invalidated context.\n     *\n     * @returns Context data.\n     */\n    updateContext<C>(): C | undefined {\n        return;\n    }\n\n    /**\n     * Lifecycle method `didMount` is invoked when component is mounted to the document.\n     */\n    didMount(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didUnmount` is invoked when component is unmounted from the document.\n     */\n    didUnmount(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `willUpdate` is invoked before update.\n     */\n    willUpdate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `updated` is invoked after update.\n     */\n    didUpdate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didInvalidate` is invoked after `invalidate` method is invoked.\n     */\n    didInvalidate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * When render method returns `undefined` value, it will create an empty text node.\n     */\n    render(): VNode<any> | undefined {\n        return;\n    }\n\n    /**\n     * Invalidate view.\n     */\n    invalidate(): void {\n        invalidateComponent(this, ComponentFlags.DirtyState);\n    }\n\n    /**\n     * Invalidate context.\n     */\n    invalidateContext(): void {\n        invalidateComponent(this, ComponentFlags.DirtyContext);\n    }\n}\n\n/**\n * Invalidate Component.\n *\n * @param component\n * @param dirtyFlags\n */\nexport function invalidateComponent<P>(component: Component<P>, dirtyFlags: number): void {\n    if (component.flags & ComponentFlags.Mounted) {\n        component.flags |= dirtyFlags;\n        component.didInvalidate();\n        if (!(component.flags & ComponentFlags.InUpdateQueue)) {\n            currentFrame().updateComponent(component);\n        }\n    }\n}\n\n/**\n * Checks props for identity.\n *\n * This function can be used as a wrapper for function expression, or as a class decorator.\n *\n *     const MyComponent = checkPropsIdentity(function(text: string) {\n *         return $h(\"div\").children(text);\n *     });\n *\n *     @checkPropsIdentity\n *     class MyClassComponent extends Component<string> {\n *         render() {\n *             return $h(\"div\").children(this.props);\n *         }\n *     }\n *\n * @param target Component constructor.\n * @returns Component constructor with identity check.\n */\nexport function checkPropsIdentity<P extends ComponentClass<any> | ComponentFunction<any>>(target: P): P {\n    if (target.prototype.render) {\n        target.prototype.isPropsChanged = isPropsNotIdentical;\n    } else {\n        (target as ComponentFunction<any>).isPropsChanged = isPropsNotIdentical;\n    }\n    return target;\n}\n\n/**\n * Checks props for shallow equality.\n *\n * This function can be used as a wrapper for function expression, or as a class decorator.\n *\n *     const MyComponent = checkPropsShallowEquality(function(props: { text: string }) {\n *         return $h(\"div\").children(props.text);\n *     });\n *\n *     @checkPropsShallowEquality\n *     class MyClassComponent extends Component<{ text: string }> {\n *         render() {\n *             return $h(\"div\").children(this.props.text);\n *         }\n *     }\n *\n * @param target Component constructor.\n * @returns Component constructor with identity check.\n */\nexport function checkPropsShallowEquality<P extends ComponentClass<any> | ComponentFunction<any>>(target: P): P {\n    if (target.prototype.render) {\n        target.prototype.isPropsChanged = isPropsNotShallowEqual;\n    } else {\n        (target as ComponentFunction<any>).isPropsChanged = isPropsNotShallowEqual;\n    }\n    return target;\n}\n","import { USER_AGENT, UserAgentFlags } from \"../common/user_agent\";\nimport { NOOP } from \"../common/noop\";\nimport { Context, ROOT_CONTEXT } from \"./context\";\nimport { VNode } from \"./vnode\";\nimport { renderVNode, syncVNode, removeVNode, augmentVNode } from \"./implementation\";\n\n/**\n * Root.\n */\nexport interface Root {\n    container: Element;\n    vNode: VNode<any>;\n    domNode: Node;\n}\n\nconst roots = [] as Root[];\n\n/**\n * Find Root node in container.\n *\n * @param container DOM Node that contains root node.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport function findRoot(container: Element): Root | undefined {\n    for (let i = 0; i < roots.length; i++) {\n        const r = roots[i];\n        if (r.container === container) {\n            return r;\n        }\n    }\n\n    return;\n}\n\n/**\n * Render VNode into container.\n *\n * @param node VNode to render.\n * @param container DOM Node that will contain rendered node.\n * @param context root context, all root contexts should be created from the `ROOT_CONTEXT` instance.\n * @returns rendered Node.\n */\nexport function render<T extends Node>(\n    node: VNode<any> | null,\n    container: Element,\n    context: Context = ROOT_CONTEXT,\n): T | undefined {\n    if (__IVI_DEV__) {\n        if (container === document.body) {\n            throw new Error(\"Rendering in the <body> aren't allowed because of browsers bugs that can't be solved \" +\n                +\"when root container is a body element.\");\n        }\n    }\n\n    let result: Node | undefined;\n    const root = findRoot(container);\n    if (node) {\n        if (root) {\n            result = syncVNode(container, root.vNode, node, context);\n            root.vNode = node;\n            root.domNode = result;\n        } else {\n            result = renderVNode(container, null, node, context);\n            roots.push({\n                container: container,\n                vNode: node,\n                domNode: result,\n            });\n            /**\n             * Fix for the Mouse Event bubbling on iOS devices.\n             *\n             * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n             */\n            if (USER_AGENT & UserAgentFlags.iOS) {\n                (container as HTMLElement).onclick = NOOP;\n            }\n        }\n    } else if (root) {\n        removeVNode(container, root.vNode);\n        const last = roots.pop();\n        if (last !== root && roots.length) {\n            roots[roots.indexOf(root)] = last!;\n        }\n        result = root.domNode;\n    }\n\n    return result as T | undefined;\n}\n\n/**\n * Augment existing DOM tree with a Virtual DOM tree.\n *\n * Augmentation is separated from `render` function to reduce code size when web application doesn't use augmentation.\n * Optimizing javascript compiler should remove all code associated with augmentation when it isn't used.\n *\n * @param node Root VNode.\n * @param container Container DOM Node.\n * @param context root context, all root contexts should be created from the `ROOT_CONTEXT` instance.\n */\nexport function augment(node: VNode<any> | null, container: Element, context: Context = ROOT_CONTEXT): void {\n    if (__IVI_DEV__) {\n        if (container === document.body) {\n            throw new Error(\"Rendering in the <body> aren't allowed because of browsers bugs that can't be solved \" +\n                +\"when root container is a body element.\");\n        }\n    }\n\n    if (node) {\n        augmentVNode(container, container.firstChild!, node, context)\n        roots.push({\n            container: container,\n            vNode: node,\n            domNode: container.firstChild!,\n        });\n        /**\n         * Fix for the Mouse Event bubbling on iOS devices.\n         *\n         * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n         */\n        if (USER_AGENT & UserAgentFlags.iOS) {\n            (container as HTMLElement).onclick = NOOP;\n        }\n    }\n}\n"]}