{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/operations.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/factories.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/array.ts","webpack:////home/void/w/ts/ivi/packages/ivi-scheduler/src/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/namespaces.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/state.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/context.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/reconciler.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/scheduler/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/accumulate_dispatch_targets.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/dispatch_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/synthetic_native_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_event_dispatcher.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createOpType","flags","descriptor","EVENTS","TRACK_BY_KEY","createOpNode","type","data","Events","child","operations_key","k","v","TrackByKey","items","factories_element","tag","svg","className","attrs","children","htmlElement","statelessComponent","shouldUpdate","props","unorderedArrayDeleteByIndex","array","index","length","last","pop","unorderedArrayDelete","item","indexOf","rAF","cb","requestAnimationFrame","runRepeatableTasks","tasks","NOOP","ERROR_HANDLERS","catchError","fn","apply","arguments","e","forEach","h","opts","[object Object]","window","addEventListener","KeyboardEvent","MouseEvent","IOS_GESTURE_EVENT","nodeProto","Node","shortcuts_elementProto","Element","objectHasOwnProperty","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","replaceChild","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","setAttributeNS","removeAttribute","_","SVG_NAMESPACE","createStateNode","op","state","getDOMNode","node","_nextNode","_index","_deepStateFlags","_dirtyContext","_context","setContext","context","tmp","restoreContext","getContext","_moveNode","_singleChild","_pushDeepState","_popDeepState","prev","current","_dirtyCheck","parentElement","stateNode","domNode","deepState","hooks","dirtyCheck","_update","update","assign","prevContext","_unmountWalk","unmountHooks","unmount","_unmount","_unmountTrackByKeysChildren","childrenState","textContent","_mountText","document","createTextNode","_createElement","opType","tagName","createElementNS","createElement","_updateAttrs","_mountObject","opData","opFlags","deepStateFlags","root","_mount","proto","nextNode","Array","_mountChildren","result","j","push","nextOp","prevOp","stateFlags","nodeValue","stateChildren","prevData","nextData","nextClassName","nextChildren","_updateChildren","updateChildrenTrackByKeys","dirtyContext","a","b","sNode","aStartNode","bStartNode","aEnd","bEnd","aEndNode","bEndNode","start","outer","aLength","bLength","nullableState","sources","pos","updated","keyIndex","Map","set","opNode","seq","lis","slice","u","updateStyle","element","style","bValue","setProperty","removeProperty","matchCount","keys","_updateAttr","next","ROOTS","findRoot","container","find","onclick","run","_flags","_microtasks","_mutationEffects","_domLayoutEffects","_beforeMutations","_afterMutations","_frameStartTime","withSchedulerTick","inner","runMicrotasks","withNextFrame","time","performance","now","_handleNextFrame","requestNextFrame","task","Promise","resolve","then","requestDirtyCheck","render","accumulateDispatchTargets","target","match","contains","visitUp","parentNode","visitDown","accumulateDispatchTargetsFromEventsOpNode","events","handlers","count","dispatchEvent","targets","event","bubble","dispatch","dispatchEventToLocalEventHandlers","matchFlags","handler","_dispatch","createNativeEvent","timestamp","native","createNativeEventDispatcher","options","source","before","after","matchEventSource","src","ev","syntheticEvent","timeStamp","dispatchToListeners","preventDefault","listeners","cbs","createNativeEventHandler","bubbleDescriptor","captureDescriptor","capture","onClick","div","li","pre","table","tbody","td","tr","ul","TableCell","console","log","TableRow","id","active","data-id","map","Table","AnimBox","background","border-radius","Anim","TreeLeaf","TreeNode","Tree","route","location","anim","tree","Main","uibench","init","querySelector","samples","JSON","stringify","undefined"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","import { Box } from \"../core/box\";\nimport { EventHandler } from \"../events/event_handler\";\nimport { NodeFlags } from \"./node_flags\";\nimport { StateNode } from \"./state\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, StatelessComponentDescriptor } from \"./component\";\n\n/**\n * Operation type.\n */\nexport interface OpType {\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  readonly flags: NodeFlags;\n  /**\n   * Operation type descriptor.\n   */\n  readonly descriptor: StatelessComponentDescriptor | ComponentDescriptor | ElementProtoDescriptor | string | null;\n}\n\n/**\n * createOpType creates {@link OpType} instances.\n *\n * @param flags See {@link NodeFlags} for details.\n * @param descriptor Operation type descriptor.\n * @returns {@link OpType} instance.\n */\nexport const createOpType = (\n  flags: NodeFlags,\n  descriptor: StatelessComponentDescriptor | ComponentDescriptor | ElementProtoDescriptor | string | null,\n): OpType => ({ flags, descriptor });\n\n/**\n * OpType for Events nodes.\n */\nexport const EVENTS = createOpType(NodeFlags.Events, null);\n\n/**\n * OpType for Ref nodes.\n */\nexport const REF = createOpType(NodeFlags.Ref, null);\n\n/**\n * OpType for Context nodes.\n */\nexport const CONTEXT = createOpType(NodeFlags.Context, null);\n\n/**\n * OpType for TrackByKey nodes.\n */\nexport const TRACK_BY_KEY = createOpType(NodeFlags.TrackByKey | NodeFlags.MultipleChildren, null);\n\n/**\n * Operation node.\n */\nexport interface OpNode<T = any> {\n  /**\n   * Operation type.\n   */\n  readonly type: OpType;\n  /**\n   * Operation data.\n   */\n  readonly data: T;\n}\n\n/**\n * createOpNode creates an {@link OpNode} instance.\n *\n * @param type Operation type.\n * @param data Operation data.\n * @returns {@link OpNode} instance.\n */\nexport const createOpNode = <T>(type: OpType, data: T): OpNode<T> => ({ type, data });\n\n/**\n * Operation data for element operations.\n */\nexport interface ElementData<T = any> {\n  /**\n   * Element class name.\n   */\n  readonly className: string | undefined;\n  /**\n   * Element attributes.\n   */\n  readonly attrs: T | undefined;\n  /**\n   * Children operations.\n   */\n  readonly children: OpChildren;\n}\n\n/**\n * Children operations supported by element nodes.\n */\nexport type OpChildren = string | number | OpNode | RecursiveOpChildrenArray | null;\n\n/**\n * Recursive children array operations supported by element nodes.\n */\nexport interface RecursiveOpChildrenArray extends Array<OpChildren> { }\n\n/**\n * Generic operation data for simple operations.\n */\nexport interface OpData<T = any> {\n  /**\n   * Generic data.\n   */\n  readonly data: T;\n  /**\n   * Child operation.\n   */\n  readonly child: OpNode | string | number | null;\n}\n\n/**\n * Operation data for Events operations.\n */\nexport type EventsData = OpData<EventHandler | Array<EventHandler | null> | null>;\n\n/**\n * Operation data for Ref operations.\n */\nexport type RefData = OpData<Box<StateNode | null>>;\n\n/**\n * Operation data for Context operations.\n */\nexport type ContextData = OpData<{}>;\n\n/**\n * Operation factory for event handlers.\n *\n * @example\n *\n *     render(\n *       Events(onClick(() => { console.log(\"clicked\"); }),\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param data Event handlers.\n * @param child Child operation.\n * @returns Event handler OpNode.\n */\nexport const Events = /* istanbul ignore else */ DEBUG ?\n  (\n    data: EventHandler | Array<EventHandler | null> | null,\n    child: OpNode | string | number | null,\n  ): OpNode<EventsData> => {\n    if (child !== null && typeof child === \"object\" && child.type === TRACK_BY_KEY) {\n      throw new Error(`Invalid child OpNode, Events can't have TrackByKey as a child`);\n    }\n    return createOpNode(EVENTS, { data, child });\n  } :\n  (\n    data: EventHandler | Array<EventHandler | null> | null,\n    child: OpNode | string | number | null,\n  ): OpNode<EventsData> => (\n      createOpNode(EVENTS, { data, child })\n    );\n\n/**\n * Operation factory for ref nodes.\n *\n * @example\n *\n *     const _ref = box();\n *\n *     render(\n *       Ref(_ref,\n *         div(),\n *       ),\n *       DOMContainer,\n *     );\n *\n *     getDOMNode(_ref);\n *\n * @param data Boxed value.\n * @param child Child operation.\n * @returns Ref OpNode.\n */\nexport const Ref = /* istanbul ignore else */ DEBUG ?\n  (\n    data: Box<StateNode | null>,\n    child: OpNode | string | number | null,\n  ): OpNode<RefData> => {\n    if (child !== null && typeof child === \"object\" && child.type === TRACK_BY_KEY) {\n      throw new Error(`Invalid child OpNode, Ref can't have TrackByKey as a child`);\n    }\n    return createOpNode(REF, { data, child });\n  } :\n  (\n    data: Box<StateNode | null>,\n    child: OpNode | string | number | null,\n  ): OpNode<RefData> => createOpNode(REF, { data, child });\n\n/**\n * Operation factory for context nodes.\n *\n * @example\n *\n *     render(\n *       Context({ key: 123 },\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param data Context object.\n * @param child Child operation.\n * @returns Context OpNode.\n */\nexport const Context = /* istanbul ignore else */ DEBUG ?\n  (data: {}, child: OpNode | string | number | null): OpNode<ContextData> => {\n    if (child !== null && typeof child === \"object\" && child.type === TRACK_BY_KEY) {\n      throw new Error(`Invalid child OpNode, Context can't have TrackByKey as a child`);\n    }\n    return createOpNode(CONTEXT, { data, child });\n  } :\n  (data: {}, child: OpNode | string | number | null): OpNode<ContextData> => createOpNode(CONTEXT, { data, child });\n\n/**\n * Key is an object that is used by TrackByKey operations to track operations.\n */\nexport interface Key<K, V> {\n  /**\n   * Key.\n   */\n  readonly k: K;\n  /**\n   * Value.\n   */\n  readonly v: V;\n}\n\n/**\n * key creates a {@link Key} instance.\n *\n * @param k Key.\n * @param v Value.\n * @returns {@link Key} instance.\n */\nexport const key = <K, V>(k: K, v: V): Key<K, V> => ({ k, v });\n\n/**\n * Operation factory for track by key nodes.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *     render(\n *       TrackByKey(items.map((item) => key(item, div(_, _, item))),\n *       DOMContainer,\n *     );\n *\n * @param items Keyed operations.\n * @returns Track by key OpNode.\n */\nexport const TrackByKey = DEBUG ?\n  <T>(items: Key<T, OpNode | number | string>[]) => {\n    /* istanbul ignore else */\n    if (DEBUG) {\n      const keys = new Set<T>();\n      for (let i = 0; i < items.length; i++) {\n        const { k, v } = items[i];\n        if (keys.has(k)) {\n          throw new Error(`Invalid key, found duplicated key: ${k}`);\n        }\n        keys.add(k);\n        if (typeof v === \"object\" && v !== null && v.type === TRACK_BY_KEY) {\n          throw new Error(`Invalid child OpNode, TrackByKey can't have TrackByKey children`);\n        }\n      }\n    }\n    return createOpNode(TRACK_BY_KEY, items);\n  } :\n  <T>(items: Key<T, OpNode | number | string>[]) => createOpNode(TRACK_BY_KEY, items);\n","// import { CSSStyleProps } from \"../dom/style\";\nimport { NodeFlags } from \"./node_flags\";\nimport { OpNode, OpChildren, ElementData, createOpNode, createOpType } from \"./operations\";\nimport { StateNode } from \"./state\";\n\nfunction element<T, U>(tag: string, svg: boolean) {\n  const type = createOpType(\n    svg === true ? (NodeFlags.Element | NodeFlags.Svg) : NodeFlags.Element,\n    tag,\n  );\n  return (\n    className?: string,\n    attrs?: {},\n    children: OpChildren = null,\n  ) => (\n      createOpNode<ElementData>(type, { className, attrs, children })\n    );\n}\n\n/**\n * htmlElement create a HTML element operation factories.\n *\n * @param tag HTML element tag name.\n * @returns HTML element operation factory.\n */\nexport const htmlElement: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: {},\n  children?: OpChildren,\n) => OpNode<ElementData<T>> = (tag: string) => element(tag, false);\n\n/**\n * htmlElement create a SVG element operation factories.\n *\n * @param tag SVG element tag name.\n * @returns SVG element operation factory.\n */\nexport const svgElement: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: {},\n  children?: OpChildren,\n) => OpNode<ElementData<T>> = (tag: string) => element(tag, true);\n\n/**\n * `elementProto()` creates a factory that produces elements with predefined attributes.\n *\n * @example\n *\n *     const DivWithIdAttribute = element(div(_, { id: \"predefined-id\" }));\n *\n *     render(\n *       DivWithIdAttribute(\"class-name\", { title: \"Title\" }, \"Hello World\"),\n *       document.getElementById(\"app\")!,\n *     );\n *\n * @param proto Element prototype.\n * @returns Factory that produces elements with predefined attributes.\n */\nexport function elementProto<P>(proto: OpNode<ElementData<P>>) {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (proto.data.children !== null) {\n      throw new Error(`Invalid OpNode, element prototypes can't have any children`);\n    }\n  }\n  const type = createOpType(proto.type.flags | NodeFlags.ElementProto, { node: null, proto });\n  return (\n    className?: string,\n    attrs?: {},\n    children: OpChildren = null,\n  ) => createOpNode<ElementData>(type, { className, attrs, children });\n}\n\n/**\n * component creates an OpNode factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component(\n  c: (c: StateNode) => () => OpNode | string | number | null,\n): () => OpNode<undefined>;\n\n/**\n * component creates an OpNode factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: StateNode) => (props: P) => OpNode | string | number | null,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => OpNode<P> : (props: P) => OpNode<P>;\n\n/**\n * component creates an OpNode factory that produces nodes for components.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: StateNode) => (props: P) => OpNode | string | number | null,\n  shouldUpdate?: (prev: P, next: P) => boolean,\n): (props: P) => OpNode<P> {\n  const type = createOpType(NodeFlags.Component | NodeFlags.Stateful | NodeFlags.DirtyCheck, { c, shouldUpdate });\n  return (props: P) => createOpNode(type, props);\n}\n\n/**\n * statelessComponent creates an OpNode factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent(\n  update: () => OpNode | string | number | null,\n): () => OpNode<undefined>;\n\n/**\n * statelessComponent creates an OpNode factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  update: (props: P) => OpNode | string | number | null,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => OpNode<P> : (props: P) => OpNode<P>;\n\n/**\n * statelessComponent creates an OpNode factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param c Update function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  c: (props: P) => OpNode | string | number | null,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): (props: P) => OpNode<P> {\n  const type = createOpType(NodeFlags.Component, { c, shouldUpdate });\n  return (props: P) => createOpNode(type, props);\n}\n","/**\n * append pushes item to an array and automatically creates a new array when it doesn't exist.\n *\n * @param array - Array\n * @param item - Item\n * @returns Array\n */\nexport const append = <T>(array: T[] | null, item: T) => array === null ? [item] : (array.push(item), array);\n\n/**\n * unorderedArrayDeleteIndex deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and removes the last one.\n *\n * @param array - Array\n * @param index - Index of an item to delete\n */\nexport function unorderedArrayDeleteByIndex<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n\n/**\n * unorderedArrayDelete deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and deletes the last one.\n *\n * @param array - Array\n * @param item - Item to delete\n */\nexport function unorderedArrayDelete<T>(array: T[], item: T): void {\n  const index = array.indexOf(item);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (index === -1) {\n      throw new Error(`Failed to delete an item from an array, item doesn't exist in the array`);\n    }\n  }\n  unorderedArrayDeleteByIndex(array, index);\n}\n","export function rAF(cb: (time?: number) => void): void {\n  requestAnimationFrame(cb);\n}\n\nexport function sMT(cb: () => void): void {\n  Promise.resolve().then(cb);\n}\n","import { unorderedArrayDeleteByIndex } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | void>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks - Repeatable tasks\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDeleteByIndex(tasks, i--);\n    }\n  }\n}\n","/**\n * NOOP function.\n */\nexport const NOOP = () => { /**/ };\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport const NOOP_FALSE = () => false;\n\n/**\n * NOOP_TRUE function always returns `true` value.\n *\n * @returns `true` value.\n */\nexport const NOOP_TRUE = () => true;\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn - Function to decorate\n * @returns function decorated with a catchError\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T;\nexport function catchError<T>(fn: () => T): (...args: any[]) => T {\n  return function () {\n    try {\n      return fn.apply(void 0, arguments);\n    } catch (e) {\n      ERROR_HANDLERS.forEach((h) => { h(e); });\n      throw e;\n    }\n  };\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = /*#__PURE__*/((TARGET === \"electron\") ? true :\n  (() => {\n    let v = false;\n    try {\n      // Test via a getter in the options object to see if the passive property is accessed\n      const opts = Object.defineProperty({}, \"passive\", {\n        get() {\n          v = true;\n        },\n      });\n      window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n    } catch (e) {\n      // ignore\n    }\n    return v;\n  })());\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = /*#__PURE__*/(\n  (TARGET === \"electron\") ||\n  (TARGET === \"evergreen\") ||\n  KeyboardEvent.prototype.hasOwnProperty(\"key\")\n);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = /*#__PURE__*/(\n  (TARGET === \"electron\") ||\n  (TARGET === \"evergreen\") ||\n  MouseEvent.prototype.hasOwnProperty(\"buttons\")\n);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\"ontouchstart\" in window);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = ((TARGET === \"electron\") || (\"PointerEvent\" in window));\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = ((TARGET === \"electron\") || \"InputDeviceCapabilities\" in window);\n\n/* istanbul ignore next */\n/**\n * iOS proprietary GestureEvent.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent}\n */\nexport const IOS_GESTURE_EVENT = (TARGET !== \"electron\") && (\"GestureEvent\" in window);\n","const nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\n/**\n * Shortcut for an `Object.prototype.hasOwnProperty`.\n */\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Shortcut for a `Node.prototype.insertBefore`.\n */\nexport const nodeInsertBefore = nodeProto.insertBefore;\n\n/**\n * Shortcut for a `Node.prototype.removeChild`.\n */\nexport const nodeRemoveChild = nodeProto.removeChild;\n\n/**\n * Shortcut for a `Node.prototype.replaceChild`.\n */\nexport const nodeReplaceChild = nodeProto.replaceChild;\n\n/**\n * Shortcut for a `Node.prototype.cloneNode`.\n */\nexport const nodeCloneNode = nodeProto.cloneNode;\n\n/**\n * Shortcut for an `Element.prototype.setAttribute`.\n */\nexport const elementSetAttribute = elementProto.setAttribute;\n\n/**\n * Shortcut for an `Element.prototype.setAttributeNS`.\n */\nexport const elementSetAttributeNS = elementProto.setAttributeNS;\n\n/**\n * Shortcut for an `Element.prototype.removeAttribute`.\n */\nexport const elementRemoveAttribute = elementProto.removeAttribute;\n\n/**\n * Shortcut for an `undefined` value.\n */\nexport const _ = void 0;\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n","import { NodeFlags } from \"./node_flags\";\nimport { OpNode } from \"./operations\";\nimport { ComponentHooks } from \"./component\";\n\n/**\n * Operation state.\n */\nexport interface StateNode {\n  /**\n   * Operation.\n   */\n  op: OpNode | string | number;\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  flags: NodeFlags;\n  /**\n   * State for children operations.\n   */\n  children: StateNode | Array<StateNode | null> | null;\n  /**\n   * Current state.\n   */\n  state: Node | ComponentHooks | {} | null;\n}\n\n/**\n * createStateNode creates a {@link StateNode} instance.\n *\n * @param op Operation.\n * @returns {@link StateNode} instance.\n */\nexport const createStateNode = (op: OpNode | string | number): StateNode => (\n  { op, flags: 0, children: null, state: null }\n);\n\n/**\n * getDOMNode retrieves closest DOM node from the node state.\n *\n * @param node State node.\n * @return DOM node.\n */\nexport function getDOMNode(node: StateNode): Node | null {\n  if ((node.flags & (NodeFlags.Element | NodeFlags.Text)) === 0) {\n    const c = node.children;\n    if (c === null) {\n      return null;\n    }\n    return getDOMNode(c as StateNode);\n  }\n  return node.state as Node;\n}\n","/**\n * Current context.\n */\nlet _context = {};\n\n/**\n * setContext assigns current context.\n *\n * Should be executed before going deeper into Context node.\n *\n * @param context - Current context.\n * @returns previous context\n */\nexport function setContext(context: {}): {} {\n  const tmp = _context;\n  _context = context;\n  return tmp;\n}\n\n/**\n * restoreContext restores previous context.\n *\n * Should be executed after processing Context node.\n *\n * @param context - Previous context.\n */\nexport function restoreContext(context: {}): void {\n  _context = context;\n}\n\n/**\n * getContext retrieves current context.\n *\n * @returns current context\n */\nexport function getContext(): {} {\n  return _context;\n}\n","import {\n  objectHasOwnProperty, nodeInsertBefore, nodeRemoveChild, elementSetAttribute, nodeCloneNode, elementRemoveAttribute,\n} from \"../core/shortcuts\";\nimport { SVG_NAMESPACE } from \"../dom/namespaces\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { NodeFlags } from \"./node_flags\";\nimport { AttributeDirective } from \"./attribute_directive\";\nimport { OpNode, ElementData, RecursiveOpChildrenArray, Key, OpData, ContextData, TRACK_BY_KEY } from \"./operations\";\nimport { StateNode, createStateNode, getDOMNode } from \"./state\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, ComponentHooks, StatelessComponentDescriptor } from \"./component\";\nimport { getContext, setContext, restoreContext } from \"./context\";\n\nlet _nextNode!: Node | null;\nlet _index!: number;\nlet _deepStateFlags!: NodeFlags;\nlet _dirtyContext!: boolean;\nlet _moveNode = false;\nlet _singleChild = false;\n\nexport function _resetState(): void {\n  _nextNode = null;\n  _deepStateFlags = 0;\n  _dirtyContext = false;\n}\n\nfunction _pushDeepState(): NodeFlags {\n  const s = _deepStateFlags;\n  _deepStateFlags = 0;\n  return s;\n}\n\nfunction _popDeepState(prev: NodeFlags, current: NodeFlags): NodeFlags {\n  const r = current | _deepStateFlags;\n  _deepStateFlags |= prev;\n  return r;\n}\n\nexport function _dirtyCheck(parentElement: Element, stateNode: StateNode): void {\n  const { flags, children } = stateNode;\n  let domNode;\n  let deepState;\n  let i;\n\n  if ((flags & NodeFlags.Component) !== 0) {\n    const hooks = stateNode.state as ComponentHooks;\n    deepState = _pushDeepState();\n    if (\n      ((flags & NodeFlags.Stateful) !== 0) && (\n        ((flags & NodeFlags.Dirty) !== 0) ||\n        (hooks.dirtyCheck !== null && hooks.dirtyCheck(getContext()) === true)\n      )\n    ) {\n      stateNode.children = _update(\n        parentElement,\n        children as StateNode,\n        hooks.update!((stateNode.op as OpNode).data),\n      );\n    } else if ((flags & NodeFlags.DeepStateDirtyCheck) !== 0) {\n      _dirtyCheck(parentElement, children as StateNode);\n    } else {\n      domNode = getDOMNode(stateNode);\n      if (domNode !== null) {\n        if (_moveNode === true) {\n          _moveNode = false;\n          /* istanbul ignore else */\n          if (DEBUG) {\n            parentElement.insertBefore(domNode, _nextNode);\n          } else {\n            nodeInsertBefore.call(parentElement, domNode, _nextNode);\n          }\n        }\n        _nextNode = domNode;\n      }\n    }\n    stateNode.flags = (stateNode.flags & NodeFlags.SelfFlags) | _deepStateFlags;\n    _deepStateFlags |= deepState | ((stateNode.flags & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else if ((flags & NodeFlags.DeepStateDirtyCheck) !== 0) {\n    deepState = _pushDeepState();\n    if ((flags & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n      domNode = stateNode.state as Node;\n      if (_moveNode === true) {\n        _moveNode = false;\n        /* istanbul ignore else */\n        if (DEBUG) {\n          parentElement.insertBefore(domNode, _nextNode);\n        } else {\n          nodeInsertBefore.call(parentElement, domNode, _nextNode);\n        }\n      }\n      if (children !== null) {\n        if ((flags & NodeFlags.MultipleChildren) !== 0) {\n          for (i = 0; i < (children as Array<StateNode | null>).length; i++) {\n            const c = (children as Array<StateNode | null>)[i];\n            if (c !== null) {\n              _dirtyCheck(domNode as Element, c);\n            }\n          }\n        } else {\n          _singleChild = true;\n          _dirtyCheck(domNode as Element, children as StateNode);\n          _singleChild = false;\n        }\n      }\n      _nextNode = domNode;\n    } else if ((flags & NodeFlags.TrackByKey) !== 0) {\n      i = (children as Array<StateNode>).length;\n      while (--i >= 0) {\n        _dirtyCheck(parentElement, (children as Array<StateNode>)[i]);\n      }\n    } else if ((flags & (NodeFlags.Events | NodeFlags.Ref)) !== 0) {\n      _dirtyCheck(parentElement, stateNode.children as StateNode);\n    } else {\n      if (_dirtyContext === true) {\n        stateNode.state = { ...getContext(), ...(stateNode.op as OpNode<ContextData>).data.data };\n      }\n      const prevContext = setContext(stateNode.state as {});\n      _dirtyCheck(parentElement, stateNode.children as StateNode);\n      restoreContext(prevContext);\n    }\n    stateNode.flags = _popDeepState(deepState, stateNode.flags);\n  } else {\n    domNode = getDOMNode(stateNode);\n    if (domNode !== null) {\n      if (_moveNode === true) {\n        _moveNode = false;\n        /* istanbul ignore else */\n        if (DEBUG) {\n          parentElement.insertBefore(domNode, _nextNode);\n        } else {\n          nodeInsertBefore.call(parentElement, domNode, _nextNode);\n        }\n      }\n      _nextNode = domNode;\n    }\n  }\n}\n\nfunction _unmountWalk(stateNode: StateNode): void {\n  const flags = stateNode.flags;\n  let i;\n\n  if ((flags & NodeFlags.DeepStateUnmount) !== 0) {\n    const children = stateNode.children;\n    if (children !== null) {\n      if ((flags & NodeFlags.MultipleChildren) !== 0) {\n        for (i = 0; i < (children as Array<StateNode | null>).length; i++) {\n          const c = (children as Array<StateNode | null>)[i];\n          if (typeof c === \"object\" && c !== null) {\n            _unmountWalk(c);\n          }\n        }\n      } else {\n        _unmountWalk(children as StateNode);\n      }\n    }\n  }\n\n  if ((flags & NodeFlags.Unmount) !== 0) {\n    const hooks = (stateNode.state as ComponentHooks);\n    const unmountHooks = hooks.unmount;\n    if (unmountHooks !== null) {\n      if (typeof unmountHooks === \"function\") {\n        unmountHooks();\n      } else {\n        for (i = 0; i < unmountHooks.length; i++) {\n          unmountHooks[i](true);\n        }\n      }\n    }\n  }\n}\n\nexport function _unmount(parentElement: Element, stateNode: StateNode): void {\n  let n;\n  if ((stateNode.flags & NodeFlags.TrackByKey) !== 0) {\n    _unmountTrackByKeysChildren(parentElement, stateNode.children as StateNode[]);\n  } else {\n    if ((n = getDOMNode(stateNode)) !== null) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        parentElement.removeChild(n);\n      } else {\n        nodeRemoveChild.call(parentElement, n);\n      }\n    }\n    _unmountWalk(stateNode);\n  }\n}\n\nfunction _unmountTrackByKeysChildren(parentElement: Element, childrenState: StateNode[]): void {\n  let i = 0;\n  if (_singleChild === true) {\n    parentElement.textContent = \"\";\n    while (i < childrenState.length) {\n      _unmountWalk(childrenState[i++]);\n    }\n  } else {\n    while (i < childrenState.length) {\n      _unmount(parentElement, childrenState[i++]);\n    }\n  }\n}\n\nfunction _mountText(\n  parentElement: Element,\n  stateNode: StateNode,\n  op: string | number,\n) {\n  const node = document.createTextNode(op as string);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parentElement.insertBefore(node, _nextNode);\n  } else {\n    nodeInsertBefore.call(parentElement, node, _nextNode);\n  }\n  _nextNode = node;\n  stateNode.state = node;\n  stateNode.flags = NodeFlags.Text;\n}\n\nfunction _createElement(node: Element | undefined, op: OpNode<ElementData>): Element {\n  const opType = op.type;\n  const svg = (opType.flags & NodeFlags.Svg) !== 0;\n  if (node === void 0) {\n    const tagName = opType.descriptor as string;\n    node = svg ?\n      document.createElementNS(SVG_NAMESPACE, tagName) :\n      document.createElement(tagName);\n  }\n\n  const { className, attrs } = op.data;\n  if (className) {\n    /**\n     * SVGElement.className returns `SVGAnimatedString`\n     */\n    if (svg) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        (node as SVGElement).setAttribute(\"class\", className);\n      } else {\n        elementSetAttribute.call(node, \"class\", className);\n      }\n    } else {\n      (node as HTMLElement).className = className;\n    }\n  }\n\n  if (attrs !== void 0) {\n    _updateAttrs(node, void 0, attrs);\n  }\n\n  return node;\n}\n\nfunction _mountObject(\n  parentElement: Element,\n  stateNode: StateNode,\n  op: OpNode,\n): void {\n  const opType = op.type;\n  const opData = op.data;\n  const opFlags = opType.flags;\n  let deepStateFlags;\n\n  if ((opFlags & NodeFlags.Component) !== 0) {\n    deepStateFlags = _pushDeepState();\n    let update;\n    if ((opFlags & NodeFlags.Stateful) !== 0) {\n      const hooks: ComponentHooks = stateNode.state = { update: null, dirtyCheck: null, unmount: null };\n      update = hooks.update = (op.type.descriptor as ComponentDescriptor).c(stateNode);\n    } else {\n      update = (op.type.descriptor as StatelessComponentDescriptor).c;\n    }\n    const root = update(opData);\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if (root !== null && typeof root === \"object\" && root.type === TRACK_BY_KEY) {\n        throw new Error(`Invalid root OpNode, Component can't have TrackByKey as a child`);\n      }\n    }\n    stateNode.children = _mount(parentElement, root);\n    stateNode.flags = (stateNode.flags & NodeFlags.SelfFlags) | opFlags | _deepStateFlags;\n    _deepStateFlags |= deepStateFlags | ((stateNode.flags & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else {\n    deepStateFlags = _pushDeepState();\n    if ((opFlags & NodeFlags.Element) !== 0) {\n      let node: Element | undefined;\n      const descriptor = opType.descriptor;\n      if ((opFlags & NodeFlags.ElementProto) !== 0) {\n        node = (descriptor as ElementProtoDescriptor).node as Element;\n        if (node === null) {\n          (descriptor as ElementProtoDescriptor).node = node = _createElement(\n            void 0,\n            (descriptor as ElementProtoDescriptor).proto,\n          );\n        }\n        /* istanbul ignore else */\n        if (DEBUG) {\n          node = node.cloneNode(false) as Element;\n        } else {\n          node = nodeCloneNode.call(node, false) as Element;\n        }\n      }\n      node = _createElement(node, op);\n\n      let childrenState: StateNode | Array<StateNode | null> | null = null;\n      const children = opData.children;\n      const nextNode = _nextNode;\n      _nextNode = null;\n      if (children !== null) {\n        if (children instanceof Array) {\n          stateNode.flags |= NodeFlags.MultipleChildren;\n          _mountChildren(node, children, childrenState = []);\n        } else {\n          childrenState = _mount(node, children);\n        }\n      }\n      /* istanbul ignore else */\n      if (DEBUG) {\n        parentElement.insertBefore(node, nextNode);\n      } else {\n        nodeInsertBefore.call(parentElement, node, nextNode);\n      }\n      stateNode.children = childrenState;\n      stateNode.state = node;\n      _nextNode = node;\n    } else if ((opFlags & (NodeFlags.Events | NodeFlags.Ref | NodeFlags.Context)) !== 0) {\n      if ((opFlags & NodeFlags.Context) !== 0) {\n        const prevContext = setContext(\n          stateNode.state = { ...getContext(), ...(opData as OpData<ContextData>).data },\n        );\n        stateNode.children = _mount(parentElement, (opData as OpData<ContextData>).child);\n        restoreContext(prevContext);\n      } else {\n        if ((opFlags & NodeFlags.Ref) !== 0) {\n          opData.data.v = stateNode;\n        }\n        stateNode.children = _mount(parentElement, opData.child);\n      }\n    } else { // ((opFlags & NodeFlags.TrackByKey) !== 0)\n      let i = (opData as Key<any, OpNode>[]).length;\n      const result = Array(i);\n      stateNode.children = result;\n      while (--i >= 0) {\n        result[i] = _mount(parentElement, (opData as Key<any, OpNode>[])[i].v);\n      }\n    }\n    stateNode.flags = _popDeepState(deepStateFlags, stateNode.flags | opFlags);\n  }\n}\n\nfunction _mountChildren(\n  parentElement: Element,\n  children: RecursiveOpChildrenArray,\n  result: Array<StateNode | null>,\n): void {\n  let j = children.length;\n  while (--j >= 0) {\n    const c = children[j];\n    if (c instanceof Array) {\n      _mountChildren(parentElement, c, result);\n    } else {\n      result.push(_mount(parentElement, c));\n    }\n  }\n}\n\nexport function _mount(\n  parentElement: Element,\n  op: OpNode | string | number | null,\n): StateNode | null {\n  if (op !== null) {\n    const stateNode = createStateNode(op);\n    if (typeof op === \"object\") {\n      _mountObject(parentElement, stateNode, op);\n    } else {\n      _mountText(parentElement, stateNode, op);\n    }\n    return stateNode;\n  }\n  return null;\n}\n\n/**\n * _update updates a stateNode with a next operation.\n *\n * @param parentElement - Parent DOM Element\n * @param stateNode - State Node\n * @param nextOp - Next Operation\n * @returns State Node\n */\nexport function _update(\n  parentElement: Element,\n  stateNode: StateNode | null,\n  nextOp: OpNode | string | number | null,\n): StateNode | null {\n  if (nextOp === null) {\n    if (stateNode !== null) {\n      _unmount(parentElement, stateNode);\n    }\n    return null;\n  }\n  if (stateNode === null) {\n    return _mount(parentElement, nextOp);\n  }\n  const prevOp = stateNode.op;\n  if (prevOp === nextOp) {\n    _dirtyCheck(parentElement, stateNode);\n    return stateNode;\n  }\n  if (\n    (typeof prevOp !== typeof nextOp) ||\n    (typeof prevOp === \"object\" && prevOp.type !== (nextOp as OpNode).type)\n  ) {\n    // prevOp can't be === null (stateNode === null)\n    _unmount(parentElement, stateNode);\n    return _mount(parentElement, nextOp);\n  }\n  stateNode.op = nextOp;\n\n  const stateFlags = stateNode.flags;\n  const state = stateNode.state;\n  let deepStateFlags;\n\n  if ((stateFlags & NodeFlags.Text) !== 0) {\n    (state as Node).nodeValue = nextOp as string;\n  } else {\n    const stateChildren = stateNode.children;\n    const prevData = (prevOp as OpNode).data;\n    const nextData = (nextOp as OpNode).data;\n    if ((stateFlags & NodeFlags.Component) !== 0) {\n      const descriptor = ((nextOp as OpNode).type.descriptor as StatelessComponentDescriptor | ComponentDescriptor);\n      if (\n        ((stateFlags & NodeFlags.Dirty) !== 0) ||\n        (\n          (prevData !== nextData) &&\n          (descriptor.shouldUpdate === void 0 || descriptor.shouldUpdate(prevData, nextData) === true)\n        )\n      ) {\n        deepStateFlags = _pushDeepState();\n        const root = ((stateFlags & NodeFlags.Stateful) !== 0) ?\n          (stateNode.state as ComponentHooks).update!(nextData) :\n          (descriptor as StatelessComponentDescriptor).c(nextData);\n        /* istanbul ignore else */\n        if (DEBUG) {\n          if (root !== null && typeof root === \"object\" && root.type === TRACK_BY_KEY) {\n            throw new Error(`Invalid root OpNode, Component can't have TrackByKey as a child`);\n          }\n        }\n\n        stateNode.children = _update(\n          parentElement,\n          stateChildren as StateNode,\n          root,\n        );\n        stateNode.flags = (stateNode.flags & NodeFlags.SelfFlags) | _deepStateFlags;\n        _deepStateFlags |= deepStateFlags | ((stateNode.flags & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n      } else {\n        _dirtyCheck(parentElement, stateNode);\n      }\n    } else {\n      deepStateFlags = _pushDeepState();\n      if ((stateFlags & NodeFlags.Element) !== 0) {\n        if (_moveNode === true) {\n          _moveNode = false;\n          /* istanbul ignore else */\n          if (DEBUG) {\n            parentElement.insertBefore(state as Node, _nextNode);\n          } else {\n            nodeInsertBefore.call(parentElement, state, _nextNode);\n          }\n        }\n\n        let nextClassName = nextData.className;\n        if (prevData.className !== nextClassName) {\n          if (nextClassName === void 0) {\n            nextClassName = \"\";\n          }\n          if ((stateFlags & NodeFlags.Svg) !== 0) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (state as Element).setAttribute(\"class\", nextClassName);\n            } else {\n              elementSetAttribute.call(state, \"class\", nextClassName);\n            }\n          } else {\n            (state as Element).className = nextClassName;\n          }\n        }\n\n        if (prevData.attrs !== nextData.attrs) {\n          _updateAttrs(state as Element, prevData.attrs, nextData.attrs);\n        }\n\n        const nextChildren = nextData.children;\n        if (prevData.children !== nextChildren) {\n          _nextNode = null;\n          /* istanbul ignore else */\n          if (DEBUG) {\n            if ((stateFlags & NodeFlags.MultipleChildren) !== 0) {\n              if (nextChildren !== null && nextChildren instanceof Array) {\n                checkElementChildrenShape(\n                  prevData.children as RecursiveOpChildrenArray,\n                  nextChildren as RecursiveOpChildrenArray,\n                );\n              } else {\n                throw new Error(\"Invalid element, children array has a dynamic shape\");\n              }\n            } else {\n              if (nextChildren !== null && nextChildren instanceof Array) {\n                throw new Error(\"Invalid element, children array has a dynamic shape\");\n              }\n            }\n          }\n          if ((stateFlags & NodeFlags.MultipleChildren) !== 0) {\n            _index = 0;\n            _updateChildren(state as Element, stateChildren as Array<StateNode | null>, nextChildren);\n          } else {\n            _singleChild = true;\n            stateNode.children = stateChildren === null ?\n              _mount(state as Element, nextChildren) :\n              _update(state as Element, stateChildren as StateNode, nextChildren);\n            _singleChild = false;\n          }\n        }\n\n        _nextNode = state as Node;\n      } else if ((stateFlags & NodeFlags.TrackByKey) !== 0) {\n        updateChildrenTrackByKeys(parentElement, stateNode, prevData, nextData);\n      } else if ((stateFlags & (NodeFlags.Events | NodeFlags.Ref)) !== 0) {\n        stateNode.children = _update(parentElement, stateChildren as StateNode, nextData.child);\n      } else { // if ((stateFlags & NodeFlags.Context) !== 0) {\n        const dirtyContext = _dirtyContext;\n        if (prevData.data !== nextData.data || _dirtyContext === true) {\n          stateNode.state = { ...getContext(), ...nextData.data };\n          _dirtyContext = true;\n        }\n        const context = setContext(stateNode.state as {});\n        _update(parentElement, stateChildren as StateNode, nextData.child);\n        restoreContext(context);\n        _dirtyContext = dirtyContext;\n      }\n      stateNode.flags = _popDeepState(deepStateFlags, stateNode.flags);\n    }\n  }\n\n  return stateNode;\n}\n\n/**\n * Update children list with a static shape.\n *\n * @param parentElement - Parent DOM Element\n * @param a - Stateful nodes\n * @param b - Next children operations\n */\nfunction _updateChildren(\n  parentElement: Element,\n  a: Array<StateNode | null>,\n  b: RecursiveOpChildrenArray,\n): void {\n  let j = b.length;\n  while (--j >= 0) {\n    let i = _index;\n    const nextOp = b[j];\n    if (nextOp instanceof Array) {\n      _updateChildren(parentElement, a, nextOp);\n    } else {\n      const stateNode = a[i];\n      a[i] = (stateNode === null) ?\n        _mount(parentElement, nextOp) :\n        _update(parentElement, stateNode, nextOp);\n      _index = ++i;\n    }\n  }\n}\n\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function (slightly outdated, but the key ideas are\n * the same).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parentElement Parent DOM element.\n * @param stateNode TrackByKey state.\n * @param a Previous operations.\n * @param b Next operations.\n */\nfunction updateChildrenTrackByKeys(\n  parentElement: Element,\n  stateNode: StateNode,\n  a: Key<any, OpNode>[],\n  b: Key<any, OpNode>[],\n): void {\n  const childrenState = stateNode.children as StateNode[];\n  const result = Array(b.length);\n  stateNode.children = result;\n  let i: number;\n\n  if (b.length === 0) {\n    if (childrenState.length > 0) {\n      _unmountTrackByKeysChildren(parentElement, childrenState);\n    }\n  } else if (childrenState.length === 0) {\n    i = b.length;\n    while (--i >= 0) {\n      result[i] = _mount(parentElement, b[i].v);\n    }\n  } else {\n    let aStartNode = a[0];\n    let bStartNode = b[0];\n    let aEnd = a.length - 1;\n    let bEnd = b.length - 1;\n    let aEndNode = a[aEnd];\n    let bEndNode = b[bEnd];\n    let start = 0;\n    let j: number | undefined;\n    let sNode: StateNode | null;\n\n    // Step 1\n    outer: while (true) {\n      // Sync nodes with the same key at the end.\n      while (aEndNode.k === bEndNode.k) {\n        result[bEnd] = _update(parentElement, childrenState[aEnd--], bEndNode.v);\n        if (start > --bEnd || start > aEnd) {\n          break outer;\n        }\n        aEndNode = a[aEnd];\n        bEndNode = b[bEnd];\n      }\n\n      // Sync nodes with the same key at the beginning.\n      while (aStartNode.k === bStartNode.k) {\n        // delayed update (all updates should be performed from right-to-left)\n        if (++start > aEnd || start > bEnd) {\n          break outer;\n        }\n        aStartNode = a[start];\n        bStartNode = b[start];\n      }\n\n      break;\n    }\n\n    if (start > aEnd) {\n      // All nodes from a are synced, insert the rest from b.\n      while (bEnd >= start) {\n        result[bEnd] = _mount(parentElement, b[bEnd--].v);\n      }\n    } else if (start > bEnd) {\n      // All nodes from b are synced, remove the rest from a.\n      i = start;\n      do {\n        sNode = childrenState[i++];\n        _unmount(parentElement, sNode);\n      } while (i <= aEnd);\n    } else { // Step 2\n      const aLength = aEnd - start + 1;\n      const bLength = bEnd - start + 1;\n      const nullableState = childrenState as Array<StateNode | null>;\n\n      // Mark all nodes as inserted.\n      const sources = Array(bLength);\n      for (i = 0; i < bLength; ++i) {\n        sources[i] = -1;\n      }\n\n      // When pos === 1000000, it means that one of the nodes in the wrong position.\n      let pos = 0;\n      let updated = 0;\n\n      const keyIndex = new Map<any, number>();\n      // Build an index that maps keys to their locations in the new children list.\n      for (j = start; j <= bEnd; ++j) {\n        keyIndex.set(b[j].k, j);\n      }\n\n      for (i = start; i <= aEnd && updated < bLength; ++i) {\n        j = keyIndex.get(a[i].k);\n        if (j !== void 0) {\n          pos = (pos > j) ? 1000000 : j;\n          ++updated;\n          sources[j - start] = i;\n          result[j] = childrenState[i];\n          nullableState[i] = null;\n        }\n      }\n\n      if (aLength === a.length && updated === 0) {\n        // Noone is synced.\n        _unmountTrackByKeysChildren(parentElement, childrenState);\n        while (bEnd >= 0) {\n          result[bEnd] = _mount(parentElement, b[bEnd--].v);\n        }\n      } else {\n        // Step 3\n        for (i = start; i <= aEnd; i++) {\n          sNode = childrenState[i];\n          if (sNode !== null) {\n            _unmount(parentElement, sNode);\n          }\n        }\n\n        let opNode;\n        if (pos === 1000000) {\n          const seq = lis(sources);\n          j = seq.length - 1;\n          i = bLength;\n          while (--i >= 0) {\n            pos = start + i;\n            opNode = b[pos].v;\n            if (sources[i] === -1) {\n              result[pos] = _mount(parentElement, opNode);\n            } else {\n              sNode = result[pos];\n              if (j < 0 || i !== seq[j]) {\n                _moveNode = true;\n              } else {\n                --j;\n              }\n              result[pos] = _update(parentElement, sNode, opNode);\n              _moveNode = false;\n            }\n          }\n        } else {\n          i = bLength;\n          while (--i >= 0) {\n            pos = start + i;\n            opNode = b[pos].v;\n            result[pos] = (sources[i] === -1) ?\n              _mount(parentElement, opNode) :\n              _update(parentElement, result[pos], opNode);\n          }\n        }\n      }\n    }\n\n    // update nodes from Step 1 (prefix only)\n    while (--start >= 0) {\n      result[start] = _update(parentElement, childrenState[start], b[start].v);\n    }\n  }\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @param a - Array of numbers\n * @returns Longest increasing subsequence\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  const result: number[] = [];\n  result[0] = 0;\n  let n = 0;\n  let u: number;\n  let v: number;\n  let j: number;\n\n  for (let i = 0; i < a.length; ++i) {\n    const k = a[i];\n    if (k === -1) {\n      continue;\n    }\n\n    j = result[n];\n    if (a[j] < k) {\n      p[i] = j;\n      result[++n] = i;\n      continue;\n    }\n\n    u = 0;\n    v = n;\n\n    while (u < v) {\n      j = ((u + v) / 2) | 0;\n      if (a[result[j]] < k) {\n        u = j + 1;\n      } else {\n        v = j;\n      }\n    }\n\n    if (k < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  v = result[n];\n\n  while (n >= 0) {\n    result[n--] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Update DOM styles.\n *\n * @param element - HTML or SVG Element\n * @param a - Prev styles\n * @param b - Next styles\n */\nfunction updateStyle(\n  element: HTMLElement | SVGElement,\n  a: CSSStyleProps | undefined,\n  b: CSSStyleProps | undefined,\n): void {\n  const style = element.style;\n  let key: string;\n  let bValue;\n\n  if (a === void 0) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== void 0) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all styles from a\n    for (key in a) {\n      style.removeProperty(key);\n    }\n  } else {\n    let matchCount = 0;\n    for (key in a) {\n      bValue = void 0;\n      if (objectHasOwnProperty.call(b, key) === true) {\n        bValue = b[key];\n        matchCount++;\n      }\n      const aValue = a[key];\n      if (aValue !== bValue) {\n        if (bValue !== void 0) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n\n    const keys = Object.keys(b);\n    for (let i = 0; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        style.setProperty(key, b[key]);\n        ++matchCount;\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attribute.\n *\n * @param element - DOM Element\n * @param key - Attribute name\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction _updateAttr(\n  element: Element,\n  key: string,\n  prev: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n  next: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n): void {\n  if (key !== \"style\") {\n    if (typeof next === \"object\") {\n      next.u(\n        element,\n        key,\n        prev === void 0 ? void 0 : (prev as AttributeDirective<any>).v,\n        next.v,\n      );\n    } else if (prev !== next) {\n      if (typeof prev === \"object\") {\n        prev.u(\n          element,\n          key,\n          (prev as AttributeDirective<any>).v,\n          void 0,\n        );\n      } else {\n        if (typeof next === \"boolean\") {\n          next = next ? \"\" : void 0;\n        }\n        if (next === void 0) {\n          /* istanbul ignore else */\n          if (DEBUG) {\n            element.removeAttribute(key);\n          } else {\n            elementRemoveAttribute.call(element, key);\n          }\n        } else {\n          /* istanbul ignore else */\n          if (DEBUG) {\n            element.setAttribute(key, next as string);\n          } else {\n            elementSetAttribute.call(element, key, next);\n          }\n        }\n      }\n    }\n  } else if (prev !== next) {\n    updateStyle(element as HTMLElement, prev as CSSStyleProps, next as CSSStyleProps);\n  }\n}\n\n/**\n * Update DOM attributes.\n *\n * @param element - DOM element\n * @param a - Prev DOM attributes\n * @param b - Next DOM attributes\n */\nfunction _updateAttrs(\n  element: Element,\n  a: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n  b: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n): void {\n  let key: string;\n\n  if (a === void 0) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      _updateAttr(element, key, void 0, b![key]);\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all attributes from a.\n    for (key in a) {\n      _updateAttr(element, key, a[key], void 0);\n    }\n  } else {\n    let matchCount = 0;\n    for (key in a) {\n      let bValue: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined = void 0;\n      if (objectHasOwnProperty.call(b, key) === true) {\n        bValue = b[key];\n        matchCount++;\n      }\n      _updateAttr(element, key, a[key], bValue);\n    }\n\n    const keys = Object.keys(b);\n    for (let i = 0; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        _updateAttr(element, key, void 0, b[key]);\n        ++matchCount;\n      }\n    }\n  }\n}\n\nfunction checkElementChildrenShape(a: RecursiveOpChildrenArray, b: RecursiveOpChildrenArray) {\n  if (a.length !== b.length) {\n    throw new Error(`Invalid element, children array has a dynamic shape`);\n  }\n  for (let i = 0; i < a.length; i++) {\n    const ai = a[i];\n    const bi = b[i];\n    if (ai instanceof Array) {\n      if (!(bi instanceof Array)) {\n        throw new Error(`Invalid element, children array has a dynamic shape`);\n      }\n      checkElementChildrenShape(ai, bi);\n    } else if (bi instanceof Array) {\n      throw new Error(`Invalid element, children array has a dynamic shape`);\n    }\n  }\n}\n","import { IOS_GESTURE_EVENT } from \"../core/feature_detection\";\nimport { NOOP } from \"../core/noop\";\nimport { unorderedArrayDelete } from \"../core/array\";\nimport { checkNestingViolations } from \"../debug/html_nesting_rules\";\nimport { OpNode } from \"./operations\";\nimport { StateNode } from \"./state\";\nimport { _mount, _update, _unmount, _dirtyCheck, _resetState } from \"./reconciler\";\n\n/**\n * Root.\n */\nexport interface Root {\n  /**\n   * Container element.\n   */\n  container: Element;\n  /**\n   * Next virtual DOM node.\n   */\n  next: OpNode | string | number | null | undefined;\n  /**\n   * Current virtual DOM node.\n   */\n  state: StateNode | null;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Find root node of a container.\n *\n * @param container - DOM Node that contains root node\n * @returns root node or undefined when root node doesn't exist\n */\nexport const findRoot = (container: Element) => ROOTS.find((r) => r.container === container);\n\n/**\n * Performs a dirty checking.\n */\nexport function dirtyCheck() {\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const root = ROOTS[i];\n    const { container, state, next } = root;\n    root.next = void 0;\n    _resetState();\n\n    if (next) {\n      if (state) {\n        root.state = _update(container, state, next);\n      } else {\n        root.state = _mount(container, next);\n        /* istanbul ignore if */\n        /**\n         * Fix for the Mouse Event bubbling on iOS devices.\n         *\n         * #quirks\n         *\n         * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n         */\n        if (TARGET === \"browser\" && IOS_GESTURE_EVENT) {\n          (container as HTMLElement).onclick = NOOP;\n        }\n      }\n    } else if (state) {\n      if (next === null) {\n        _unmount(container, state);\n        unorderedArrayDelete(ROOTS, root);\n        --i;\n      } else {\n        _dirtyCheck(container, state);\n      }\n    }\n\n    /* istanbul ignore else */\n    if (DEBUG) {\n      if (root.state) {\n        checkNestingViolations(container, root.state);\n      }\n    }\n  }\n}\n","import { sMT, rAF } from \"ivi-scheduler\";\nimport { runRepeatableTasks, RepeatableTaskList } from \"../core/repeatable_task_list\";\nimport { NOOP } from \"../core/noop\";\nimport { catchError } from \"../core/error\";\nimport { printWarn } from \"../debug/print\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { OpNode } from \"../vdom/operations\";\nimport { StateNode } from \"../vdom/state\";\nimport { ROOTS, findRoot, dirtyCheck } from \"../vdom/root\";\n\n/**\n * Update flags.\n */\nexport const enum UpdateFlags {\n  /**\n   * Forces synchronous update.\n   */\n  RequestSyncUpdate = 1,\n}\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  /**\n   * Running inside of a scheduler context.\n   */\n  Running = 1,\n  /**\n   * Scheduler tick is pending for an execution.\n   */\n  TickPending = 1 << 1,\n  /**\n   * Frame update is pending for an execution.\n   */\n  NextFramePending = 1 << 2,\n  /**\n   * Sync Frame update is pending for an execution.\n   */\n  NextSyncFramePending = 1 << 3,\n  /**\n   * Running inside of a frame update context.\n   */\n  UpdatingFrame = 1 << 4,\n  /**\n   * Dirty checking is pending for an execution.\n   */\n  DirtyCheckPending = 1 << 5,\n}\n\nconst enum SchedulerDebugFlags {\n  DirtyCheckingFinished = 1,\n  MutationsFinished = 1 << 1,\n  LayoutFinished = 1 << 2,\n}\n\n/**\n * Task list.\n */\ninterface TaskList { v: Array<() => void>; }\n\n/**\n * createTaskList creates a task list.\n *\n * @returns task list\n */\nconst createTaskList = () => ({ v: [] }) as TaskList;\n\n/**\n * Execute tasks from the `TaskList`.\n *\n * @param t - Task list\n */\nfunction run(t: TaskList) {\n  while (t.v.length > 0) {\n    const tasks = t.v;\n    let i = 0;\n    t.v = [];\n    do {\n      tasks[i++]();\n    } while (i < tasks.length);\n  }\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _debugFlags: SchedulerDebugFlags;\n/** istanbul ignore else */\nif (DEBUG) {\n  _debugFlags = 0;\n}\nlet _clock = 1;\nconst _microtasks = createTaskList();\nconst _mutationEffects = createTaskList();\nconst _domLayoutEffects = createTaskList();\nconst _beforeMutations = [] as RepeatableTaskList;\nconst _afterMutations = [] as RepeatableTaskList;\nlet _frameStartTime = 0;\n\n/**\n * withSchedulerTick wraps `inner` function into a scheduler context execution.\n *\n * @param inner - Inner function.\n * @returns function that will be executed in a scheduler context.\n */\nexport const withSchedulerTick = <T extends any[]>(inner: (...args: T) => void) => (\n  catchError(function () {\n    _flags |= SchedulerFlags.Running;\n    inner.apply(void 0, arguments);\n    run(_microtasks);\n    _flags &= ~(SchedulerFlags.Running | SchedulerFlags.TickPending);\n    ++_clock;\n  })\n) as (...args: T) => void;\n\nconst runMicrotasks = withSchedulerTick(NOOP);\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport const clock = () => _clock;\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task - Microtask.\n */\nexport function scheduleMicrotask(task: () => void): void {\n  _microtasks.v.push(task);\n  if ((_flags & (SchedulerFlags.Running | SchedulerFlags.TickPending)) === 0) {\n    _flags |= SchedulerFlags.TickPending;\n    sMT(runMicrotasks);\n  }\n}\n\n/**\n * beforeMutations adds a hook that will be executed before DOM mutations.\n *\n * @param fn - hook.\n */\nexport function beforeMutations(fn: () => boolean | void): void {\n  _beforeMutations.push(fn);\n}\n\n/**\n * afterMutations adds a hook that will be executed after DOM mutations.\n *\n * @param fn - hook.\n */\nexport function afterMutations(fn: () => boolean | void): void {\n  _afterMutations.push(fn);\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport const frameStartTime = () => _frameStartTime;\n\n/**\n * withNextFrame wraps `inner` function into a scheduler frame update context.\n *\n * @param inner - Inner function.\n * @returns function that will be executed in a frame update context.\n */\nexport const withNextFrame = (inner: (time?: number) => void) => (\n  withSchedulerTick((time?: number) => {\n    _flags |= SchedulerFlags.UpdatingFrame;\n    inner(time);\n\n    if ((_flags & SchedulerFlags.NextFramePending) !== 0) {\n      _frameStartTime = time === void 0 ? performance.now() : time;\n\n      runRepeatableTasks(_beforeMutations);\n      if ((_flags & SchedulerFlags.DirtyCheckPending) !== 0) {\n        dirtyCheck();\n      }\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.DirtyCheckingFinished;\n      }\n      run(_mutationEffects);\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.MutationsFinished;\n      }\n      runRepeatableTasks(_afterMutations);\n      run(_domLayoutEffects);\n      /** istanbul ignore else */\n      if (DEBUG) {\n        _debugFlags |= SchedulerDebugFlags.LayoutFinished;\n      }\n    }\n    _flags &= ~(\n      SchedulerFlags.UpdatingFrame |\n      SchedulerFlags.NextFramePending |\n      SchedulerFlags.NextSyncFramePending |\n      SchedulerFlags.DirtyCheckPending\n    );\n    /** istanbul ignore else */\n    if (DEBUG) {\n      _debugFlags &= ~(\n        SchedulerDebugFlags.DirtyCheckingFinished |\n        SchedulerDebugFlags.MutationsFinished |\n        SchedulerDebugFlags.LayoutFinished\n      );\n    }\n  })\n);\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = withNextFrame(NOOP);\n\n/**\n * requestNextFrame requests an update for next frame.\n */\nexport function requestNextFrame(flags?: UpdateFlags): void {\n  if (\n    (flags !== void 0) &&\n    ((flags & UpdateFlags.RequestSyncUpdate) !== 0) &&\n    ((_flags & SchedulerFlags.NextSyncFramePending) === 0)\n  ) {\n    _flags |= SchedulerFlags.NextFramePending | SchedulerFlags.NextSyncFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      scheduleMicrotask(_handleNextFrame);\n    }\n  } else if ((_flags & SchedulerFlags.NextFramePending) === 0) {\n    _flags |= SchedulerFlags.NextFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      rAF(_handleNextFrame);\n    }\n  }\n}\n\n/**\n * Adds a write DOM task to the queue.\n *\n * @param fn - Write DOM task\n */\nexport function scheduleMutationEffect(fn: () => void, flags?: UpdateFlags): void {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Mutation effect is scheduled after mutations were finished\");\n      }\n    }\n  }\n  _mutationEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Adds a DOM layout task to the queue.\n *\n * @param fn - Read DOM task\n */\nexport function scheduleLayoutEffect(fn: () => void, flags?: UpdateFlags): void {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Layout effect is scheduled after layout were finished\");\n      }\n    }\n  }\n  _domLayoutEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\nexport function requestDirtyCheck(flags?: UpdateFlags) {\n  /** istanbul ignore else */\n  if (DEBUG) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Dirty checking is scheduled after dirty checking were finished\");\n      }\n    }\n  }\n  _flags |= SchedulerFlags.DirtyCheckPending;\n  requestNextFrame(flags);\n}\n\n/**\n * Invalidate component.\n *\n * @param c - Component instance\n * @param flags - See {@link UpdateFlags} for details.\n */\nexport function invalidate(c: StateNode, flags?: UpdateFlags): void {\n  c.flags |= NodeFlags.Dirty;\n  requestDirtyCheck(flags);\n}\n\n/**\n * dirty requests a dirty checking and returns current monotonic clock value.\n *\n * @param flags - See {@link UpdateFlags} for details.\n * @returns current monotonic clock value.\n */\nexport const dirty = (flags?: UpdateFlags) => (requestDirtyCheck(flags), _clock);\n\n/**\n * Render virtual DOM node into the container.\n *\n * @param next - Virtual DOM node to render\n * @param container - DOM Node that will contain rendered node\n * @param flags - See {@link UpdateFlags} for details\n */\nexport function render(next: OpNode | string | number | null, container: Element, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    /**\n     * Rendering into the <body> element is disabled to make it possible to fix iOS quirk with click events.\n     */\n    if (container === document.body) {\n      throw new Error(\"Rendering into the <body> element aren't allowed\");\n    }\n    if (!document.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document\");\n    }\n  }\n\n  const root = findRoot(container);\n  if (root) {\n    root.next = next;\n  } else {\n    ROOTS.push({ container, next, state: null });\n  }\n\n  requestDirtyCheck(flags);\n}\n","import { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandler } from \"./event_handler\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { StateNode } from \"../vdom/state\";\nimport { ROOTS } from \"../vdom/root\";\nimport { OpNode, OpData } from \"../vdom/operations\";\n\n/**\n * accumulateDispatchTargets traverses the DOM tree from the `target` Element to the document top, then goes down\n * through Virtual DOM tree and accumulates matching Event Handlers in `result` array.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching function.\n */\nexport function accumulateDispatchTargets(\n  result: DispatchTarget[],\n  target: Element,\n  match: (h: EventHandler) => boolean,\n): void {\n  for (let i = 0; i < ROOTS.length; i++) {\n    const { container, state } = ROOTS[i];\n    if (container.contains(target)) {\n      if (container !== target) {\n        visitUp(result, match, target, container, state!);\n      }\n      break;\n    }\n  }\n}\n\nfunction visitUp(\n  result: DispatchTarget[],\n  match: (h: EventHandler) => boolean,\n  element: Element,\n  root: Element,\n  stateNode: StateNode | null,\n): StateNode | null {\n  const parentElement = element.parentNode! as Element;\n  return (parentElement === root || (stateNode = visitUp(result, match, parentElement, root, stateNode)) !== null) ?\n    visitDown(result, match, element, stateNode!) :\n    null;\n}\n\nfunction visitDown(\n  result: DispatchTarget[],\n  match: (h: EventHandler) => boolean,\n  element: Element,\n  stateNode: StateNode | null,\n): StateNode | null {\n  if (stateNode === null) {\n    return null;\n  }\n  const { flags, children } = stateNode;\n  let i;\n  let r;\n  if ((flags & NodeFlags.Element) !== 0) {\n    if (stateNode.state === element) {\n      return stateNode;\n    }\n    if ((flags & NodeFlags.MultipleChildren) !== 0) {\n      i = (children as Array<StateNode | null>).length;\n      while (--i >= 0) {\n        if ((r = visitDown(result, match, element, (children as StateNode[])[i])) !== null) {\n          return r;\n        }\n      }\n    } else if (children !== null) {\n      return visitDown(result, match, element, children as StateNode);\n    }\n  } else if ((flags & (NodeFlags.Events | NodeFlags.Component | NodeFlags.Context | NodeFlags.Ref)) !== 0) {\n    if ((r = visitDown(result, match, element, stateNode.children as StateNode)) !== null) {\n      if ((flags & NodeFlags.Events) !== 0) {\n        accumulateDispatchTargetsFromEventsOpNode(result, stateNode, match);\n      }\n      return r;\n    }\n  } else if ((flags & NodeFlags.TrackByKey) !== 0) {\n    for (i = 0; i < (children as StateNode[]).length; i++) {\n      if ((r = visitDown(result, match, element, (children as StateNode[])[i])) !== null) {\n        return r;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * accumulateDispatchTargetsFromElement accumulates matching Event Handlers in `result` array from the `target`\n * Virtual DOM Element.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target Virtual DOM Element.\n * @param match Matching function.\n */\nfunction accumulateDispatchTargetsFromEventsOpNode(\n  result: DispatchTarget[],\n  target: StateNode,\n  match: (h: EventHandler) => boolean,\n): void {\n  const events = (target.op as OpNode<OpData>).data.data;\n  if (events !== null) {\n    let handlers: EventHandler[] | EventHandler | undefined;\n    if (events instanceof Array) {\n      let count = 0;\n      for (let i = 0; i < events.length; i++) {\n        const h = events[i];\n        if (h !== null && match(h) === true) {\n          if (count === 0) {\n            handlers = h;\n          } else if (count === 1) {\n            handlers = [handlers as EventHandler, h];\n          } else {\n            (handlers as EventHandler[]).push(h);\n          }\n          ++count;\n        }\n      }\n    } else if (match(events) === true) {\n      handlers = events;\n    }\n    if (handlers !== void 0) {\n      result.push({ target, handlers });\n    }\n  }\n}\n","import { StateNode } from \"../vdom/state\";\nimport { EventFlags, SyntheticEventFlags } from \"./flags\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandlerFlags, EventHandler } from \"./event_handler\";\nimport { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch callback.\n */\nexport function dispatchEvent(\n  targets: DispatchTarget[],\n  event: SyntheticEvent,\n  bubble: boolean,\n  dispatch?: (h: EventHandler, ev: SyntheticEvent) => EventFlags | void,\n): void {\n  let i = targets.length;\n\n  // capture phase\n  while (--i >= 0) {\n    dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Capture, dispatch);\n    if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n      return;\n    }\n  }\n\n  // bubble phase\n  if (bubble) {\n    while (++i < targets.length) {\n      dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Bubble, dispatch);\n      if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n        return;\n      }\n    }\n  }\n}\n\n/**\n * dispatchEventToLocalEventHandlers dispatches event to local(at the same DOM Node) event handlers.\n *\n * @param target Dispatch Target.\n * @param event Synthetic Event.\n * @param matchFlags Flags that should match to deliver event.\n * @param dispatch Dispatch callback.\n */\nfunction dispatchEventToLocalEventHandlers(\n  target: DispatchTarget,\n  event: SyntheticEvent,\n  matchFlags: EventHandlerFlags,\n  dispatch: ((h: EventHandler, ev: SyntheticEvent) => EventFlags | void) | undefined,\n): void {\n  const handlers = target.handlers;\n  let flags: EventFlags = 0;\n  event.node = target.target as StateNode;\n  if (handlers instanceof Array) {\n    for (let i = 0; i < handlers.length; ++i) {\n      const handler = handlers[i];\n      if (handler.d.flags & matchFlags) {\n        flags |= _dispatch(handler, dispatch, event);\n      }\n    }\n  } else if (handlers.d.flags & matchFlags) {\n    flags = _dispatch(handlers, dispatch, event);\n  }\n\n  event.flags |= flags;\n}\n\nfunction _dispatch(\n  handler: EventHandler,\n  dispatch: ((h: EventHandler, ev: SyntheticEvent) => EventFlags | void) | undefined,\n  event: SyntheticEvent,\n): EventFlags {\n  const flags = (dispatch === void 0) ? handler.h(event) : dispatch(handler, event);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (flags !== void 0) {\n      if (flags & ~(EventFlags.PreventDefault | EventFlags.StopPropagation)) {\n        throw new Error(`Invalid event flags: ${flags}`);\n      }\n    }\n  }\n  return (flags === void 0) ? 0 : flags;\n}\n","import { SyntheticEventFlags } from \"./flags\";\nimport { SyntheticEvent } from \"./synthetic_event\";\nimport { StateNode } from \"../vdom/state\";\n\n/**\n * SyntheticNativeEvent is a wrapper for native events.\n */\nexport interface SyntheticNativeEvent<E extends Event> extends SyntheticEvent {\n  readonly native: E;\n}\n\n/**\n * createNativeEvent creates a wrapper for a native event.\n */\nexport function createNativeEvent<E extends Event>(\n  flags: SyntheticEventFlags,\n  timestamp: number,\n  node: StateNode | null,\n  native: E,\n): SyntheticNativeEvent<E> {\n  return { flags, timestamp, node, native };\n}\n","import { append, unorderedArrayDelete } from \"../core/array\";\nimport { withSchedulerTick } from \"../scheduler\";\nimport { SyntheticEventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventHandler } from \"./event_handler\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { accumulateDispatchTargets } from \"./accumulate_dispatch_targets\";\nimport { dispatchEvent } from \"./dispatch_event\";\nimport { SyntheticNativeEvent, createNativeEvent } from \"./synthetic_native_event\";\n\n/**\n * NativeEventSource dispatches native events.\n *\n * It is using two-phase dispatching algorithm similar to native DOM events flow.\n */\nexport interface NativeEventDispatcher<E extends Event> {\n  /**\n   * See `NativeEventSourceFlags` for details.\n   */\n  flags: NativeEventSourceFlags;\n  /**\n   * Event handler options.\n   */\n  readonly options: { capture?: boolean, passive?: boolean } | boolean;\n  /**\n   * Hooks that will be executed before dispatching an event.\n   */\n  before: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  /**\n   * Hooks that will be executed after dispatching an event.\n   */\n  after: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  /**\n   * Event dispatcher.\n   */\n  dispatch: ((ev: E) => void) | null;\n}\n\n/**\n * Creates a native event dispatcher.\n *\n * @param flags - See {@link NativeEventSourceFlags} for details.\n * @param name - Event name\n * @param options - Event handler options\n * @returns {@link NativeEventDispatcher} instance\n */\nexport function createNativeEventDispatcher<E extends Event>(\n  flags: NativeEventSourceFlags,\n  name: string,\n  options?: { capture?: boolean, passive?: boolean } | boolean,\n): NativeEventDispatcher<E> {\n  const source: NativeEventDispatcher<E> = {\n    flags,\n    options: options === void 0 ? true : options,\n    before: null,\n    after: null,\n    dispatch: null,\n  };\n\n  const matchEventSource = (h: EventHandler) => h.d.src === source;\n\n  document.addEventListener(name, withSchedulerTick((ev: Event): void => {\n    const target = ev.target as Element;\n    const targets: DispatchTarget[] = [];\n\n    accumulateDispatchTargets(targets, target, matchEventSource);\n\n    if (targets.length || source.before || source.after) {\n      const syntheticEvent = createNativeEvent(0, ev.timeStamp, null, ev as E);\n\n      dispatchToListeners(source.before, syntheticEvent);\n      if (targets.length) {\n        dispatchEvent(targets, syntheticEvent, (source.flags & NativeEventSourceFlags.Bubbles) !== 0);\n      }\n      dispatchToListeners(source.after, syntheticEvent);\n\n      if (syntheticEvent.flags & SyntheticEventFlags.PreventedDefault) {\n        ev.preventDefault();\n      }\n    }\n  }));\n\n  return source;\n}\n\n/**\n * beforeNativeEvent attaches a hook that will be executed before dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function beforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.before = append(source.before, cb);\n}\n\n/**\n * afterNativeEvent attaches a hook that will be executed after dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function afterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.after = append(source.after, cb);\n}\n\n/**\n * removeBeforeNativeEvent removes a hook that is executed before dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function removeBeforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (source.before === null) {\n      throw new Error(\"removeBeforeNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.before!, cb);\n}\n\n/**\n * removeAfterNativeEvent removes a hook that is executed after dispatching an event.\n *\n * @param source - Event dispatcher source.\n * @param cb - Hook\n */\nexport function removeAfterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (source.after === null) {\n      throw new Error(\"removeAfterNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.after!, cb);\n}\n\nfunction dispatchToListeners<E extends Event>(\n  listeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null,\n  ev: SyntheticNativeEvent<E>,\n): void {\n  if (listeners !== null) {\n    ev.node = null;\n    const cbs = listeners.slice();\n    for (let i = 0; i < cbs.length; i++) {\n      cbs[i](ev);\n    }\n  }\n}\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { EventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventHandler, EventHandlerFlags } from \"./event_handler\";\nimport { NativeEventDispatcher, createNativeEventDispatcher } from \"./native_event_dispatcher\";\nimport { SyntheticNativeEvent } from \"./synthetic_native_event\";\nimport { EVENT_CAPTURE_ACTIVE_OPTIONS } from \"./utils\";\n\n/* tslint:disable:max-line-length */\nexport const EVENT_DISPATCHER_ABORT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"abort\") as NativeEventDispatcher<UIEvent>;\nexport const EVENT_DISPATCHER_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"activate\");\nexport const EVENT_DISPATCHER_ARIA_REQUEST = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"ariarequest\");\nexport const EVENT_DISPATCHER_BEFORE_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture, \"beforecopy\");\nexport const EVENT_DISPATCHER_BEFORE_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforecut\");\nexport const EVENT_DISPATCHER_BEFORE_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforedeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforepaste\");\nexport const EVENT_DISPATCHER_BLUR = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"blur\");\nexport const EVENT_DISPATCHER_CAN_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplay\");\nexport const EVENT_DISPATCHER_CAN_PLAYTHROUGH = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplaythrough\");\nexport const EVENT_DISPATCHER_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"change\");\nexport const EVENT_DISPATCHER_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"click\");\nexport const EVENT_DISPATCHER_CONTEXT_MENU = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"contextmenu\");\nexport const EVENT_DISPATCHER_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"copy\");\nexport const EVENT_DISPATCHER_CUE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"cuechange\");\nexport const EVENT_DISPATCHER_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"cut\");\nexport const EVENT_DISPATCHER_DOUBLE_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dblclick\");\nexport const EVENT_DISPATCHER_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"deactivate\");\nexport const EVENT_DISPATCHER_DRAG = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drag\");\nexport const EVENT_DISPATCHER_DRAG_END = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragend\");\nexport const EVENT_DISPATCHER_DRAG_ENTER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragenter\");\nexport const EVENT_DISPATCHER_DRAG_LEAVE = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragleave\");\nexport const EVENT_DISPATCHER_DRAG_OVER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragover\");\nexport const EVENT_DISPATCHER_DRAG_START = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragstart\");\nexport const EVENT_DISPATCHER_DROP = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drop\");\nexport const EVENT_DISPATCHER_DURATION_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"durationchange\");\nexport const EVENT_DISPATCHER_EMPTIED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"emptied\");\nexport const EVENT_DISPATCHER_ENCRYPTED = /*#__PURE__*/createNativeEventDispatcher<MediaEncryptedEvent>(NativeEventSourceFlags.Capture, \"encrypted\");\nexport const EVENT_DISPATCHER_ENDED = /*#__PURE__*/createNativeEventDispatcher<MediaStreamErrorEvent>(NativeEventSourceFlags.Capture, \"ended\");\nexport const EVENT_DISPATCHER_ERROR = /*#__PURE__*/createNativeEventDispatcher<ErrorEvent>(NativeEventSourceFlags.Capture, \"error\");\nexport const EVENT_DISPATCHER_FOCUS = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"focus\");\nexport const EVENT_DISPATCHER_GOT_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"gotpointercapture\");\nexport const EVENT_DISPATCHER_INPUT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"input\");\nexport const EVENT_DISPATCHER_INVALID = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"invalid\");\nexport const EVENT_DISPATCHER_KEY_DOWN = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keydown\");\nexport const EVENT_DISPATCHER_KEY_PRESS = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keypress\");\nexport const EVENT_DISPATCHER_KEY_UP = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keyup\");\nexport const EVENT_DISPATCHER_LOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"load\");\nexport const EVENT_DISPATCHER_LOADED_DATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadeddata\");\nexport const EVENT_DISPATCHER_LOADED_METADATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadedmetadata\");\nexport const EVENT_DISPATCHER_LOAD_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadstart\");\nexport const EVENT_DISPATCHER_LOST_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"lostpointercapture\");\nexport const EVENT_DISPATCHER_MOUSE_DOWN = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousedown\");\nexport const EVENT_DISPATCHER_MOUSE_ENTER = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseenter\");\nexport const EVENT_DISPATCHER_MOUSE_LEAVE = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture, \"mouseleave\");\nexport const EVENT_DISPATCHER_MOUSE_MOVE = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousemove\");\nexport const EVENT_DISPATCHER_MOUSE_OUT = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseout\");\nexport const EVENT_DISPATCHER_MOUSE_OVER = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseover\");\nexport const EVENT_DISPATCHER_MOUSE_UP = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseup\");\nexport const EVENT_DISPATCHER_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"paste\");\nexport const EVENT_DISPATCHER_PAUSE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"pause\");\nexport const EVENT_DISPATCHER_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"play\");\nexport const EVENT_DISPATCHER_PLAYING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"playing\");\nexport const EVENT_DISPATCHER_POINTER_CANCEL = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointercancel\");\nexport const EVENT_DISPATCHER_POINTER_DOWN = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerdown\");\nexport const EVENT_DISPATCHER_POINTER_ENTER = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerenter\");\nexport const EVENT_DISPATCHER_POINTER_LEAVE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"pointerleave\");\nexport const EVENT_DISPATCHER_POINTER_MOVE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointermove\");\nexport const EVENT_DISPATCHER_POINTER_OUT = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerout\");\nexport const EVENT_DISPATCHER_POINTER_OVER = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerover\");\nexport const EVENT_DISPATCHER_POINTER_UP = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerup\");\nexport const EVENT_DISPATCHER_PROGRESS = /*#__PURE__*/createNativeEventDispatcher<ProgressEvent>(NativeEventSourceFlags.Capture, \"progress\");\nexport const EVENT_DISPATCHER_RATE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"ratechange\");\nexport const EVENT_DISPATCHER_RESET = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"reset\");\nexport const EVENT_DISPATCHER_SCROLL = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"scroll\");\nexport const EVENT_DISPATCHER_SEEKED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeked\");\nexport const EVENT_DISPATCHER_SEEKING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeking\");\nexport const EVENT_DISPATCHER_SELECT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"select\");\nexport const EVENT_DISPATCHER_SELECT_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"selectstart\");\nexport const EVENT_DISPATCHER_STALLED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"stalled\");\nexport const EVENT_DISPATCHER_SUBMIT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"submit\");\nexport const EVENT_DISPATCHER_SUSPEND = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"suspend\");\nexport const EVENT_DISPATCHER_TIME_UPDATE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"timeupdate\");\nexport const EVENT_DISPATCHER_TOUCH_CANCEL = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchcancel\");\nexport const EVENT_DISPATCHER_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchend\");\nexport const EVENT_DISPATCHER_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchmove\");\nexport const EVENT_DISPATCHER_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchstart\");\nexport const EVENT_DISPATCHER_UNLOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"unload\");\nexport const EVENT_DISPATCHER_VOLUME_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"volumechange\");\nexport const EVENT_DISPATCHER_WAITING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"waiting\");\nexport const EVENT_DISPATCHER_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"wheel\");\n\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchend\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchmove\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchstart\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"wheel\", EVENT_CAPTURE_ACTIVE_OPTIONS);\n\n/**\n * Helper function that creates event handlers.\n *\n * @param d - Event source\n * @param h - Event Handler function\n * @param capture - Capture mode\n * @returns EventHandler instance\n */\nexport function createNativeEventHandler(src: NativeEventDispatcher<any>): (\n  h: (ev: SyntheticNativeEvent<any>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<any> {\n  const bubbleDescriptor = { src, flags: EventHandlerFlags.Bubble };\n  const captureDescriptor = { src, flags: EventHandlerFlags.Capture };\n  return (h, capture) => ({\n    d: capture === true ? captureDescriptor : bubbleDescriptor,\n    h,\n  });\n}\n\nexport const onAbort: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ABORT));\nexport const onActivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVATE));\nexport const onAriaRequest: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ARIA_REQUEST));\nexport const onBeforeActivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_ACTIVATE));\nexport const onBeforeCopy: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_COPY));\nexport const onBeforeCut: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_CUT));\nexport const onBeforeDeactivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_DEACTIVATE));\nexport const onBeforePaste: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_PASTE));\nexport const onBlur: <P>(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<FocusEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BLUR));\nexport const onCanPlay: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CAN_PLAY));\nexport const onCanPlaythrough: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CAN_PLAYTHROUGH));\nexport const onChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CHANGE));\nexport const onClick: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CLICK));\nexport const onContextMenu: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CONTEXT_MENU));\nexport const onCopy: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_COPY));\nexport const onCueChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CUE_CHANGE));\nexport const onCut: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CUT));\nexport const onDoubleClick: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DOUBLE_CLICK));\nexport const onDeactivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DEACTIVATE));\nexport const onDrag: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG));\nexport const onDragEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_END));\nexport const onDragEnter: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_ENTER));\nexport const onDragLeave: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_LEAVE));\nexport const onDragOver: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_OVER));\nexport const onDragStart: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_START));\nexport const onDrop: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DROP));\nexport const onDurationChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DURATION_CHANGE));\nexport const onEmptied: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_EMPTIED));\nexport const onEncrypted: <P>(\n  handler: (ev: SyntheticNativeEvent<MediaEncryptedEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MediaEncryptedEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ENCRYPTED));\nexport const onEnded: <P>(\n  handler: (ev: SyntheticNativeEvent<MediaStreamErrorEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MediaStreamErrorEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ENDED));\nexport const onError: <P>(\n  handler: (ev: SyntheticNativeEvent<ErrorEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ErrorEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ERROR));\nexport const onFocus: <P>(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<FocusEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_FOCUS));\nexport const onGotPointerCapture: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_GOT_POINTER_CAPTURE));\nexport const onInput: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_INPUT));\nexport const onInvalid: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_INVALID));\nexport const onKeyDown: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_DOWN));\nexport const onKeyPress: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_PRESS));\nexport const onKeyUp: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_UP));\nexport const onLoad: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOAD));\nexport const onLoadedData: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOADED_DATA));\nexport const onLoadedMetadata: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOADED_METADATA));\nexport const onLoadStart: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOAD_START));\nexport const onLostPointerCapture: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOST_POINTER_CAPTURE));\nexport const onMouseDown: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_DOWN));\nexport const onMouseEnter: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_ENTER));\nexport const onMouseLeave: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_LEAVE));\nexport const onMouseMove: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_MOVE));\nexport const onMouseOut: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_OUT));\nexport const onMouseOver: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_OVER));\nexport const onMouseUp: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_UP));\nexport const onPaste: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PASTE));\nexport const onPause: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PAUSE));\nexport const onPlay: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PLAY));\nexport const onPlaying: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PLAYING));\nexport const onPointerCancel: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_CANCEL));\nexport const onPointerDown: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_DOWN));\nexport const onPointerEnter: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_ENTER));\nexport const onPointerLeave: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_LEAVE));\nexport const onPointerMove: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_MOVE));\nexport const onPointerOut: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_OUT));\nexport const onPointerOver: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_OVER));\nexport const onPointerUp: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_UP));\nexport const onProgress: <P>(\n  handler: (ev: SyntheticNativeEvent<ProgressEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<ProgressEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PROGRESS));\nexport const onRateChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_RATE_CHANGE));\nexport const onReset: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_RESET));\nexport const onScroll: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SCROLL));\nexport const onSeeked: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SEEKED));\nexport const onSeeking: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SEEKING));\nexport const onSelect: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SELECT));\nexport const onSelectStart: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SELECT_START));\nexport const onStalled: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_STALLED));\nexport const onSubmit: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SUBMIT));\nexport const onSuspend: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SUSPEND));\nexport const onTimeUpdate: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TIME_UPDATE));\nexport const onTouchCancel: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_CANCEL));\nexport const onTouchEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_END));\nexport const onTouchMove: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_MOVE));\nexport const onTouchStart: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_START));\nexport const onUnload: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_UNLOAD));\nexport const onVolumeChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_VOLUME_CHANGE));\nexport const onWaiting: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_WAITING));\nexport const onWheel: <P>(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<WheelEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_WHEEL));\n\nexport const onActiveTouchEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_END));\nexport const onActiveTouchMove: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE));\nexport const onActiveTouchStart: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_START));\nexport const onActiveWheel: <P>(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandler<SyntheticNativeEvent<WheelEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_WHEEL));\n\n/* tslint:enable:max-line-length */\n","import {\n  HTMLAnchorElementAttrs, HTMLElementAttrs, HTMLAreaElementAttrs, HTMLAudioElementAttrs,\n  HTMLBaseElementAttrs, HTMLBodyElementAttrs, HTMLBRElementAttrs, HTMLButtonElementAttrs,\n  HTMLCanvasElementAttrs, HTMLQuoteElementAttrs, HTMLTableCaptionElementAttrs, HTMLTableColElementAttrs,\n  HTMLModElementAttrs, HTMLDivElementAttrs, HTMLDListElementAttrs, HTMLFieldSetElementAttrs, HTMLFormElementAttrs,\n  HTMLHeadElementAttrs, HTMLHeadingElementAttrs, HTMLHRElementAttrs, HTMLHtmlElementAttrs, HTMLIFrameElementAttrs,\n  HTMLImageElementAttrs, HTMLInputElementAttrs, HTMLLabelElementAttrs, HTMLLegendElementAttrs, HTMLLIElementAttrs,\n  HTMLLinkElementAttrs, HTMLMapElementAttrs, HTMLMenuElementAttrs, HTMLMetaElementAttrs, HTMLMeterElementAttrs,\n  HTMLOListElementAttrs, HTMLOptGroupElementAttrs, HTMLOptionElementAttrs, HTMLParagraphElementAttrs,\n  HTMLPictureElementAttrs, HTMLPreElementAttrs, HTMLProgressElementAttrs, HTMLScriptElementAttrs,\n  HTMLSelectElementAttrs, HTMLSourceElementAttrs, HTMLSpanElementAttrs, HTMLStyleElementAttrs,\n  HTMLTableDataCellElementAttrs, HTMLTableElementAttrs, HTMLTableHeaderCellElementAttrs, HTMLTableRowElementAttrs,\n  HTMLTableSectionElementAttrs, HTMLTemplateElementAttrs, HTMLTextAreaElementAttrs, HTMLTitleElementAttrs,\n  HTMLTrackElementAttrs, HTMLUListElementAttrs, HTMLVideoElementAttrs,\n\n  ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED,\n\n  AttributeDirective, htmlElement,\n} from \"ivi\";\n\n/**\n * {@link AttributeDirective} with `\"\"` value and {@link updateValue} sync function.\n */\nconst VALUE_EMPTY_STRING: AttributeDirective<string | number> = { v: \"\", u: updateValue };\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateChecked} sync function.\n */\nconst CHECKED_FALSE: AttributeDirective<boolean> = { v: false, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateChecked} sync function.\n */\nconst CHECKED_TRUE: AttributeDirective<boolean> = { v: true, u: updateChecked };\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateValue(\n  element: Element,\n  key: string,\n  prev: string | number | undefined,\n  next: string | number | undefined,\n) {\n  if (prev === void 0) {\n    if (next !== \"\") {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement | HTMLTextAreaElement).value !== next) {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link CHECKED} function.\n *\n * @param element - Target element\n * @param key - Attribute key\n * @param prev - Previous value\n * @param next - Next value\n */\nfunction updateChecked(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0) {\n    if (next) {\n      (element as HTMLInputElement).checked = next;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement).checked !== next) {\n      (element as HTMLInputElement).checked = next!;\n    }\n  }\n}\n\n/**\n * VALUE function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLInputElement or\n * HTMLTextAreaElement.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = input(\"\", { value: VALUE(\"value\") });\n *\n * @param v - Value\n * @returns {@link AttributeDirective}\n */\nexport function VALUE(v: string | number | undefined): AttributeDirective<string | number> {\n  return (v === void 0) ?\n    ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED :\n    v === \"\" ?\n      VALUE_EMPTY_STRING :\n      { v, u: updateValue };\n}\n\n/**\n * CHECKED function creates a {@link AttributeDirective} that assigns a `checked` property to an HTMLInputElement.\n *\n * `undefined` values are ignored.\n *\n * @example\n *\n *   const e = input(\"\", { checked: CHECKED(true) });\n *\n * @param v - Checked value\n * @returns {@link AttributeDirective}\n */\nexport function CHECKED(v: boolean | undefined): AttributeDirective<boolean> {\n  return (v === void 0) ?\n    ATTRIBUTE_DIRECTIVE_SKIP_UNDEFINED as any as AttributeDirective<boolean> :\n    v ? CHECKED_TRUE : CHECKED_FALSE;\n}\n\n/**\n * Creates OpNode HTML element <a>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <a>\n */\nexport const a = /*#__PURE__*/htmlElement<HTMLAnchorElementAttrs, HTMLAnchorElement>(\"a\");\n\n/**\n * Creates OpNode HTML element <abbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <abbr>\n */\nexport const abbr = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"abbr\");\n\n/**\n * Creates OpNode HTML element <address>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <address>\n */\nexport const address = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"address\");\n\n/**\n * Creates OpNode HTML element <article>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <article>\n */\nexport const article = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"article\");\n\n/**\n * Creates OpNode HTML element <aside>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <aside>\n */\nexport const aside = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"aside\");\n\n/**\n * Creates OpNode HTML element <b>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <b>\n */\nexport const b = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"b\");\n\n/**\n * Creates OpNode HTML element <base>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <base>\n */\nexport const base = /*#__PURE__*/htmlElement<HTMLBaseElementAttrs, HTMLBaseElement>(\"base\");\n\n/**\n * Creates OpNode HTML element <bdo>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <bdo>\n */\nexport const bdo = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"bdo\");\n\n/**\n * Creates OpNode HTML element <blockquote>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <blockquote>\n */\nexport const blockquote = /*#__PURE__*/htmlElement<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"blockquote\");\n\n/**\n * Creates OpNode HTML element <body>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <body>\n */\nexport const body = /*#__PURE__*/htmlElement<HTMLBodyElementAttrs, HTMLBodyElement>(\"body\");\n\n/**\n * Creates OpNode HTML element <br>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <br>\n */\nexport const br = /*#__PURE__*/htmlElement<HTMLBRElementAttrs, HTMLBRElement>(\"br\");\n\n/**\n * Creates OpNode HTML element <button>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <button>\n */\nexport const button = /*#__PURE__*/htmlElement<HTMLButtonElementAttrs, HTMLButtonElement>(\"button\");\n\n/**\n * Creates OpNode HTML element <canvas>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <canvas>\n */\nexport const canvas = /*#__PURE__*/htmlElement<HTMLCanvasElementAttrs, HTMLCanvasElement>(\"canvas\");\n\n/**\n * Creates OpNode HTML element <caption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <caption>\n */\nexport const caption = /*#__PURE__*/htmlElement<HTMLTableCaptionElementAttrs, HTMLTableCaptionElement>(\"caption\");\n\n/**\n * Creates OpNode HTML element <cite>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <cite>\n */\nexport const cite = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"cite\");\n\n/**\n * Creates OpNode HTML element <code>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <code>\n */\nexport const code = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"code\");\n\n/**\n * Creates OpNode HTML element <col>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <col>\n */\nexport const col = /*#__PURE__*/htmlElement<HTMLTableColElementAttrs, HTMLTableColElement>(\"col\");\n\n/**\n * Creates OpNode HTML element <colgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <colgroup>\n */\nexport const colgroup = /*#__PURE__*/htmlElement<HTMLTableColElementAttrs, HTMLTableColElement>(\"colgroup\");\n\n/**\n * Creates OpNode HTML element <del>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <del>\n */\nexport const del = /*#__PURE__*/htmlElement<HTMLModElementAttrs, HTMLModElement>(\"del\");\n\n/**\n * Creates OpNode HTML element <dfn>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dfn>\n */\nexport const dfn = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"dfn\");\n\n/**\n * Creates OpNode HTML element <div>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <div>\n */\nexport const div = /*#__PURE__*/htmlElement<HTMLDivElementAttrs, HTMLDivElement>(\"div\");\n\n/**\n * Creates OpNode HTML element <dd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dd>\n */\nexport const dd = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"dd\");\n\n/**\n * Creates OpNode HTML element <dl>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dl>\n */\nexport const dl = /*#__PURE__*/htmlElement<HTMLDListElementAttrs, HTMLDListElement>(\"dl\");\n\n/**\n * Creates OpNode HTML element <dt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dt>\n */\nexport const dt = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"dt\");\n\n/**\n * Creates OpNode HTML element <em>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <em>\n */\nexport const em = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"em\");\n\n/**\n * Creates OpNode HTML element <fieldset>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <fieldset>\n */\nexport const fieldset = /*#__PURE__*/htmlElement<HTMLFieldSetElementAttrs, HTMLFieldSetElement>(\"fieldset\");\n\n/**\n * Creates OpNode HTML element <figcaption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figcaption>\n */\nexport const figcaption = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"figcaption\");\n\n/**\n * Creates OpNode HTML element <figure>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figure>\n */\nexport const figure = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"figure\");\n\n/**\n * Creates OpNode HTML element <footer>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <footer>\n */\nexport const footer = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"footer\");\n\n/**\n * Creates OpNode HTML element <form>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <form>\n */\nexport const form = /*#__PURE__*/htmlElement<HTMLFormElementAttrs, HTMLFormElement>(\"form\");\n\n/**\n * Creates OpNode HTML element <h1>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h1>\n */\nexport const h1 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h1\");\n\n/**\n * Creates OpNode HTML element <h2>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h2>\n */\nexport const h2 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h2\");\n\n/**\n * Creates OpNode HTML element <h3>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h3>\n */\nexport const h3 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h3\");\n\n/**\n * Creates OpNode HTML element <h4>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h4>\n */\nexport const h4 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h4\");\n\n/**\n * Creates OpNode HTML element <h5>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h5>\n */\nexport const h5 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h5\");\n\n/**\n * Creates OpNode HTML element <h6>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h6>\n */\nexport const h6 = /*#__PURE__*/htmlElement<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h6\");\n\n/**\n * Creates OpNode HTML element <head>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <head>\n */\nexport const head = /*#__PURE__*/htmlElement<HTMLHeadElementAttrs, HTMLHeadElement>(\"head\");\n\n/**\n * Creates OpNode HTML element <header>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <header>\n */\nexport const header = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"header\");\n\n/**\n * Creates OpNode HTML element <hgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hgroup>\n */\nexport const hgroup = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"hgroup\");\n\n/**\n * Creates OpNode HTML element <hr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hr>\n */\nexport const hr = /*#__PURE__*/htmlElement<HTMLHRElementAttrs, HTMLHRElement>(\"hr\");\n\n/**\n * Creates OpNode HTML element <html>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <html>\n */\nexport const html = /*#__PURE__*/htmlElement<HTMLHtmlElementAttrs, HTMLHtmlElement>(\"html\");\n\n/**\n * Creates OpNode HTML element <i>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <i>\n */\nexport const i = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"i\");\n\n/**\n * Creates OpNode HTML element <iframe>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <iframe>\n */\nexport const iframe = /*#__PURE__*/htmlElement<HTMLIFrameElementAttrs, HTMLIFrameElement>(\"iframe\");\n\n/**\n * Creates OpNode HTML element <img>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <img>\n */\nexport const img = /*#__PURE__*/htmlElement<HTMLImageElementAttrs, HTMLImageElement>(\"img\");\n\n/**\n * Creates OpNode HTML element <area>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <area>\n */\nexport const area = /*#__PURE__*/htmlElement<HTMLAreaElementAttrs, HTMLAreaElement>(\"area\");\n\n/**\n * Creates OpNode HTML element <map>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <map>\n */\nexport const map = /*#__PURE__*/htmlElement<HTMLMapElementAttrs, HTMLMapElement>(\"map\");\n\n/**\n * Creates OpNode HTML element <ins>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ins>\n */\nexport const ins = /*#__PURE__*/htmlElement<HTMLModElementAttrs, HTMLModElement>(\"ins\");\n\n/**\n * Creates OpNode HTML element <kbd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <kbd>\n */\nexport const kbd = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"kbd\");\n\n/**\n * Creates OpNode HTML element <label>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <label>\n */\nexport const label = /*#__PURE__*/htmlElement<HTMLLabelElementAttrs, HTMLLabelElement>(\"label\");\n\n/**\n * Creates OpNode HTML element <legend>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <legend>\n */\nexport const legend = /*#__PURE__*/htmlElement<HTMLLegendElementAttrs, HTMLLegendElement>(\"legend\");\n\n/**\n * Creates OpNode HTML element <li>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <li>\n */\nexport const li = /*#__PURE__*/htmlElement<HTMLLIElementAttrs, HTMLLIElement>(\"li\");\n\n/**\n * Creates OpNode HTML element <link>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <link>\n */\nexport const link = /*#__PURE__*/htmlElement<HTMLLinkElementAttrs, HTMLLinkElement>(\"link\");\n\n/**\n * Creates OpNode HTML element <main>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <main>\n */\nexport const main = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"main\");\n\n/**\n * Creates OpNode HTML element <mark>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <mark>\n */\nexport const mark = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"mark\");\n\n/**\n * Creates OpNode HTML element <menu>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <menu>\n */\nexport const menu = /*#__PURE__*/htmlElement<HTMLMenuElementAttrs, HTMLMenuElement>(\"menu\");\n\n/**\n * Creates OpNode HTML element <meta>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meta>\n */\nexport const meta = /*#__PURE__*/htmlElement<HTMLMetaElementAttrs, HTMLMetaElement>(\"meta\");\n\n/**\n * Creates OpNode HTML element <meter>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meter>\n */\nexport const meter = /*#__PURE__*/htmlElement<HTMLMeterElementAttrs, HTMLMeterElement>(\"meter\");\n\n/**\n * Creates OpNode HTML element <nav>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <nav>\n */\nexport const nav = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"nav\");\n\n/**\n * Creates OpNode HTML element <noscript>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <noscript>\n */\nexport const noscript = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"noscript\");\n\n/**\n * Creates OpNode HTML element <ol>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ol>\n */\nexport const ol = /*#__PURE__*/htmlElement<HTMLOListElementAttrs, HTMLOListElement>(\"ol\");\n\n/**\n * Creates OpNode HTML element <optgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <optgroup>\n */\nexport const optgroup = /*#__PURE__*/htmlElement<HTMLOptGroupElementAttrs, HTMLOptGroupElement>(\"optgroup\");\n\n/**\n * Creates OpNode HTML element <option>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <option>\n */\nexport const option = /*#__PURE__*/htmlElement<HTMLOptionElementAttrs, HTMLOptionElement>(\"option\");\n\n/**\n * Creates OpNode HTML element <p>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <p>\n */\nexport const p = /*#__PURE__*/htmlElement<HTMLParagraphElementAttrs, HTMLParagraphElement>(\"p\");\n\n/**\n * Creates OpNode HTML element <picture>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <picture>\n */\nexport const picture = /*#__PURE__*/htmlElement<HTMLPictureElementAttrs, HTMLPictureElement>(\"picture\");\n\n/**\n * Creates OpNode HTML element <pre>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <pre>\n */\nexport const pre = /*#__PURE__*/htmlElement<HTMLPreElementAttrs, HTMLPreElement>(\"pre\");\n\n/**\n * Creates OpNode HTML element <progress>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <progress>\n */\nexport const progress = /*#__PURE__*/htmlElement<HTMLProgressElementAttrs, HTMLProgressElement>(\"progress\");\n\n/**\n * Creates OpNode HTML element <q>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <q>\n */\nexport const q = /*#__PURE__*/htmlElement<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"q\");\n\n/**\n * Creates OpNode HTML element <rt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <rt>\n */\nexport const rt = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"rt\");\n\n/**\n * Creates OpNode HTML element <ruby>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ruby>\n */\nexport const ruby = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"ruby\");\n\n/**\n * Creates OpNode HTML element <s>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <s>\n */\nexport const s = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"s\");\n\n/**\n * Creates OpNode HTML element <samp>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <samp>\n */\nexport const samp = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"samp\");\n\n/**\n * Creates OpNode HTML element <script>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <script>\n */\nexport const script = /*#__PURE__*/htmlElement<HTMLScriptElementAttrs, HTMLScriptElement>(\"script\");\n\n/**\n * Creates OpNode HTML element <section>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <section>\n */\nexport const section = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"section\");\n\n/**\n * Creates OpNode HTML element <select>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <select>\n */\nexport const select = /*#__PURE__*/htmlElement<HTMLSelectElementAttrs, HTMLSelectElement>(\"select\");\n\n/**\n * Creates OpNode HTML element <source>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <source>\n */\nexport const source = /*#__PURE__*/htmlElement<HTMLSourceElementAttrs, HTMLSourceElement>(\"source\");\n\n/**\n * Creates OpNode HTML element <span>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <span>\n */\nexport const span = /*#__PURE__*/htmlElement<HTMLSpanElementAttrs, HTMLSpanElement>(\"span\");\n\n/**\n * Creates OpNode HTML element <strong>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <strong>\n */\nexport const strong = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"strong\");\n\n/**\n * Creates OpNode HTML element <style>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <style>\n */\nexport const style = /*#__PURE__*/htmlElement<HTMLStyleElementAttrs, HTMLStyleElement>(\"style\");\n\n/**\n * Creates OpNode HTML element <sub>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sub>\n */\nexport const sub = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"sub\");\n\n/**\n * Creates OpNode HTML element <sup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sup>\n */\nexport const sup = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"sup\");\n\n/**\n * Creates OpNode HTML element <table>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <table>\n */\nexport const table = /*#__PURE__*/htmlElement<HTMLTableElementAttrs, HTMLTableElement>(\"table\");\n\n/**\n * Creates OpNode HTML element <tbody>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tbody>\n */\nexport const tbody = /*#__PURE__*/htmlElement<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tbody\");\n\n/**\n * Creates OpNode HTML element <td>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <td>\n */\nexport const td = /*#__PURE__*/htmlElement<HTMLTableDataCellElementAttrs, HTMLTableDataCellElement>(\"td\");\n\n/**\n * Creates OpNode HTML element <template>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <template>\n */\nexport const template = /*#__PURE__*/htmlElement<HTMLTemplateElementAttrs, HTMLTemplateElement>(\"template\");\n\n/**\n * Creates OpNode HTML element <tfoot>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tfoot>\n */\nexport const tfoot = /*#__PURE__*/htmlElement<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tfoot\");\n\n/**\n * Creates OpNode HTML element <th>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <th>\n */\nexport const th = /*#__PURE__*/htmlElement<HTMLTableHeaderCellElementAttrs, HTMLTableHeaderCellElement>(\"th\");\n\n/**\n * Creates OpNode HTML element <thead>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <thead>\n */\nexport const thead = /*#__PURE__*/htmlElement<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"thead\");\n\n/**\n * Creates OpNode HTML element <time>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <time>\n */\nexport const time = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"time\");\n\n/**\n * Creates OpNode HTML element <title>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <title>\n */\nexport const title = /*#__PURE__*/htmlElement<HTMLTitleElementAttrs, HTMLTitleElement>(\"title\");\n\n/**\n * Creates OpNode HTML element <tr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tr>\n */\nexport const tr = /*#__PURE__*/htmlElement<HTMLTableRowElementAttrs, HTMLTableRowElement>(\"tr\");\n\n/**\n * Creates OpNode HTML element <track>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <track>\n */\nexport const track = /*#__PURE__*/htmlElement<HTMLTrackElementAttrs, HTMLTrackElement>(\"track\");\n\n/**\n * Creates OpNode HTML element <u>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <u>\n */\nexport const u = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"u\");\n\n/**\n * Creates OpNode HTML element <ul>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ul>\n */\nexport const ul = /*#__PURE__*/htmlElement<HTMLUListElementAttrs, HTMLUListElement>(\"ul\");\n\n/**\n * Creates OpNode HTML element <wbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <wbr>\n */\nexport const wbr = /*#__PURE__*/htmlElement<HTMLElementAttrs, HTMLElement>(\"wbr\");\n\n/**\n * Creates OpNode HTML element <textarea>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <textarea>\n */\nexport const textarea = /*#__PURE__*/htmlElement<HTMLTextAreaElementAttrs, HTMLTextAreaElement>(\"textarea\");\n\n/**\n * Creates OpNode HTML element <input>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <input>\n */\nexport const input = /*#__PURE__*/htmlElement<HTMLInputElementAttrs, HTMLInputElement>(\"input\");\n\n/**\n * Creates OpNode HTML element <audio>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <audio>\n */\nexport const audio = /*#__PURE__*/htmlElement<HTMLAudioElementAttrs, HTMLAudioElement>(\"audio\");\n\n/**\n * Creates OpNode HTML element <video>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <video>\n */\nexport const video = /*#__PURE__*/htmlElement<HTMLVideoElementAttrs, HTMLVideoElement>(\"video\");\n","import { _, statelessComponent, withNextFrame, render, Events, onClick, TrackByKey, key } from \"ivi\";\nimport { td, tr, table, tbody, div, li, ul, pre } from \"ivi-html\";\nconst TableCell = statelessComponent((t) => (Events(onClick(() => { console.log(\"Click\", t); }), td(\"TableCell\", _, t))));\nconst TableRow = statelessComponent(({ id, active, props }) => (tr(active ? \"TableRow active\" : \"TableRow\", { \"data-id\": id }, [\n    TableCell(\"#\" + id),\n    TrackByKey(props.map((item, i) => key(i, TableCell(item)))),\n])));\nconst Table = statelessComponent((p) => (table(\"Table\", _, tbody(_, _, TrackByKey(p.items.map((item) => key(item.id, TableRow(item))))))));\nconst AnimBox = statelessComponent(({ id, time }) => (div(\"AnimBox\", {\n    \"data-id\": id,\n    style: {\n        \"background\": \"rgba(0,0,0,\" + (0.5 + ((time % 10) / 10)) + \")\",\n        \"border-radius\": (time % 10) + \"px\",\n    },\n})));\nconst Anim = statelessComponent((p) => (div(\"Anim\", _, TrackByKey(p.items.map((item) => key(item.id, AnimBox(item)))))));\nconst TreeLeaf = statelessComponent((p) => li(\"TreeLeaf\", _, p.id));\nconst TreeNode = statelessComponent((p) => (ul(\"TreeNode\", _, TrackByKey(p.children.map((n) => key(n.id, n.container ? TreeNode(n) : TreeLeaf(n)))))));\nconst Tree = statelessComponent((p) => div(\"Tree\", _, TreeNode(p.root)));\nfunction route(state) {\n    switch (state.location) {\n        case \"table\": return Table(state.table);\n        case \"anim\": return Anim(state.anim);\n        default: return Tree(state.tree);\n    }\n}\nconst Main = statelessComponent((state) => div(\"Main\", _, state ? route(state) : null));\nuibench.init(\"ivi\", \"0.18.0\");\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    const container = document.querySelector(\"#App\");\n    render(Main(), container);\n    uibench.run((state) => withNextFrame(() => { render(Main(state), container); })(), (samples) => { render(pre(_, _, JSON.stringify(samples, undefined, 2)), container); });\n});\n"],"sourceRoot":""}