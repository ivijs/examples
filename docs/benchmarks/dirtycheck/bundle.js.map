{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/clock.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/token.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/observable.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/operations.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/factories.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/box.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/context.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/reconciler.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/namespaces.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/scheduler/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/utils.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/dispatch.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/attribute_directive.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/perf-monitor/dist/es5/perf-monitor.js","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_clock","clock","advanceClock","TASK_TOKEN","DIRTY_CHECK_TOKEN","UNMOUNT_TOKEN","_deps","observable","v","watch","push","saveObservableDependencies","deps","createOpType","f","EVENTS","TRACK_BY_KEY","createContainerOp","k","htmlElementFactory","tag","flags","createDOMElementOp","elementFactory","component","e1","e2","type","p1","p2","getDescriptor","getOwnPropertyDescriptor","nodeProto","Node","Element","doc","document","objectHasOwnProperty","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","replaceChild","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","setAttributeNS","removeAttribute","elementSetClassName","set","htmlElementGetStyle","HTMLElement","svgElementGetStyle","SVGElement","box","ERROR_HANDLERS","error","NOOP","_nextNode","setContext","_dirtyCheck","parentElement","opState","moveNode","state","length","dirtyCheckWatchList","_update","_unmount","_unmountRemove","_unmountWalk","children","u","_createElement","node","op","svg","tagName","createElementNS","createElement","_updateClassName","_updateAttrs","_mount","Array","_mountFragment","opType","prevState","_mountObject","createTextNode","_mountText","nextOp","nodeValue","opStateChildren","prevData1","nextData1","prevData2","nextData2","nextValue","a","b","j","result","aEnd","bEnd","start","outer","pos","bLength","sources","Int32Array","keyIndex","Map","lo","hi","parent","index","indexLength","markLIS","_updateChildrenTrackByKeys","element","className","_updateAttr","matchCount","keys","prev","next","style","bValue","setProperty","removeProperty","aValue","_updateStyle","ROOTS","findRoot","predicate","find","run","tasks","_flags","_frameStartTime","Promise","resolve","_microtasks","_mutationEffects","_layoutEffects","withSchedulerTick","inner","fn","apply","arguments","e","forEach","h","withNextFrame","time","root","container","dirtyCheck","_handleNextFrame","requestNextFrame","requestAnimationFrame","requestDirtyCheck","invalidate","window","dispatchNativeEvent","event","currentTarget","src","createNativeEventSource","options","source","target","targets","match","contains","visitUp","stateNode","parentNode","visitDown","collectDispatchTargetsFromEventsOpState","collectDispatchTargets","descriptor","dispatchEvent","addEventListener","BLUR_EVENT","CLICK_EVENT","INPUT_EVENT","nativeEventHandlerFactory","bubbleDescriptor","captureDescriptor","capture","onBlur","onClick","onInput","_","AUTOFOCUS_TRUE","focus","VALUE_EMPTY","updateValue","VALUE","div","input","extendStatics","MonitorWidgetFlags","MonitorSamplesResult","min","max","mean","last","this","MonitorSamples","maxSamples","samples","_i","addSample","each","calc","sum","frameTasks","rafId","__extends","setPrototypeOf","__proto__","__","constructor","Widget","_this","_sync","sync","_dirty","cssText","task","Error","MonitorWidget","_super","unitName","label","textContent","text","HideMin","minText","appendChild","HideMax","maxText","HideMean","meanText","HideLast","lastText","HideGraph","canvas","width","height","ctx","getContext","scale","RoundValues","toFixed","Math","round","toString","fillStyle","fillRect","CounterWidget","counter","checkInit","body","ProfilerDetails","data","widget","startTime","profilerInstances","x","y","Field","editing","ev","autofocus","Container","range","cs","Main","w","fps","update","now","startFPSMonitor","undefined","performance","memory","usedJSHeapSize","setTimeout","startMemMonitor","profiler","initProfiler","getElementById","render","tick","endProfile"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/**\n * Monotonically increasing clock.\n */\nlet _clock = 1;\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport function clock() {\n  return _clock;\n}\n\n/**\n * advanceClock increments clock value.\n */\nexport function advanceClock() {\n  _clock++;\n}\n","export interface TaskToken {\n  readonly $$label?: \"ivi-task-token\";\n}\n\nexport interface DirtyCheckToken {\n  readonly $$label?: \"ivi-dirty-check-token\";\n}\n\nexport interface UnmountToken {\n  readonly $$label?: \"ivi-unmount-token\";\n}\n\n/**\n * Task token.\n */\nexport const TASK_TOKEN: TaskToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Dirty check token.\n */\nexport const DIRTY_CHECK_TOKEN: DirtyCheckToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Unmount token.\n */\nexport const UNMOUNT_TOKEN: UnmountToken = (\n  process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{}\n);\n\n/**\n * Empty object.\n */\nexport const EMPTY_OBJECT = process.env.NODE_ENV !== \"production\" ? Object.freeze({}) : /* istanbul ignore next */{};\n\n/**\n * Empty array.\n */\nexport const EMPTY_ARRAY = process.env.NODE_ENV !== \"production\" ? Object.freeze([]) : /* istanbul ignore next */[];\n","import { clock } from \"./clock\";\nimport { DirtyCheckToken, DIRTY_CHECK_TOKEN } from \"./token\";\n\n/**\n * Coarse-grained observables (directed graph, pull) and dirty checking.\n *\n * IMPLEMENTATION DETAILS:\n *\n * Observable (40b overhead) values are simple objects that store a time (monotonically increasing clock) `t` when\n * they were updated last time and a value `v` . Computed (~212-356b overhead) values and side effects create a\n * directed graph with edges pointing to observables and other computed values. Each time any observable value is\n * modified, dirty checking algorithm goes through all side effects and checks if any of the dependencies were modified\n * and when one of the dependencies is modified it will rerun side effect.\n *\n * Computeds and side effects automatically reset all edges every time they are reevaluated.\n *\n * CAVEATS:\n *\n * - \"memory leaking\" computed values. All glitch-free solutions that pull data in side effects are having the same\n *   issue, previous value is always stored to prevent unnecessary computations when dependencies are changed but the\n *   resulting value is the same. One of the solutions to deal with computeds that can store a lot of outdated data\n *   could be to create a custom garbage collector that will nullify outdated computed values (`lastCheck < clock()`).\n * - Large number of side effects can cause performance problems. Dirty checking algorithm checks all side effects each\n *   time something is updated.\n *\n * TRADEOFFS:\n *\n * vs redux-like selectors (directed graph, pull) (`useSelect()` in ivi < 0.28.0)\n *\n * PROS:\n *\n * - Slightly better performance.\n * - Less verbose API, especially when working with mutable data structures and normalized data.\n * - Stateless components can use context and watch observables/computeds.\n * - Composable API.\n *\n * vs fine-grained observables (undirected graph, push-pull) and autotracking (Vue, MobX)\n *\n * PROS:\n *\n * - Significantly better performance with complex data processing algorithms (especially with map/reduce algorithms).\n * - Significantly less memory consumption.\n *\n * CONS:\n *\n * - Verbose API, all edges are created explicitly with `watch()` function. Autotracking solutions implicitly create\n *   all edges.\n * - Updates trigger more updates than it is necessary.\n * - Dirty checking requires to check all side effects each time something is updated. Push-pull solutions are creating\n *   undirected graphs so that when observable value is updated they can go through the graph and find all side effects\n *   that use this observable value.\n * - Complex use cases that can be easily solved with Vue or MobX require completely different solutions. For example,\n *   when we need to sort a list of items, instead of watching every item, we will need to create a `signal()` that will\n *   be emitted each time when observable value is modified. Use cases like \"highlighting all items that match a list of\n *   rules\" would require creating custom data structures like inverted indexes, ordered maps(rb-tree), etc.\n * - Significantly higher learning curve (requires basic knowledge of data structures and algorithms).\n *\n * @example\n *     // Computed value\n *     const a = observable(1);\n *     const b = observable(2);\n *     const sum = computed(() => watch(a) + watch(b));\n *     const A = statelessComponent(() => div(_, _, watch(sum)()));\n *\n *     // Basic selector with immutable state\n *     const A = component((c) => {\n *       const getValue = selector(() => STATE.value);\n *       return () => div(_, _, watch(getValue)());\n *     });\n *\n *     // Memoized selector with immutable state\n *     const A = component((c) => {\n *       const getValue = selector((prev) => (\n *         prev !== void 0 && prev.a === STATE.a && prev.b === STATE.b ? prev :\n *           { a: STATE.a, b: STATE.b, result: STATE.a + STATE.b };\n *       ));\n *       return () => div(_, _, watch(getValue)());\n *     });\n *\n *     // Composition\n *     const a = observable(1);\n *     const A = component((c) => {\n *       const getValue = memo((i) => computed(() => watch(a) + i));\n *       return (i) => div(_, _, watch(getValue(i))());\n *     });\n */\n\n/**\n * Observable value.\n */\nexport interface Observable<T> {\n  /**\n   * Time.\n   */\n  t: number;\n  /**\n   * Value.\n   */\n  v: T;\n}\n\n/**\n * Infers observable value type.\n */\nexport type ObservableValue<T> = T extends Observable<infer U> ? U : never;\n\n/**\n * List of observable dependencies.\n *\n * First value in an array contains time of the last update.\n */\nexport type WatchList = null | [number, ...Array<Observable<any> | ((token?: DirtyCheckToken, time?: number) => any)>];\n\nlet _deps: WatchList = null;\n\n/**\n * Creates an observable value.\n *\n * @typeparam T Observable value type.\n * @param v Value.\n * @returns {@link Observable} value.\n */\nexport const observable = <T>(v: T): Observable<T> => ({ t: clock(), v });\n\n/**\n * Applies a function to an observable value.\n *\n * @example\n *     const a = observable(1);\n *     apply(a, (v) => v + 1);\n *\n * @typeparam T Observable value type.\n * @param v Observable value.\n * @param fn Function to apply.\n */\nexport function apply<T>(v: Observable<T>, fn: (v: T) => T): void {\n  v.t = clock();\n  v.v = fn(v.v);\n}\n\n/**\n * Assigns a new value to an observable value.\n *\n * @example\n *     const a = observable(1);\n *     assign(a, 2);\n *\n * @typeparam T Observable value type.\n * @param v Observable value.\n * @param n New value.\n */\nexport function assign<T>(v: Observable<T>, n: T): void {\n  v.t = clock();\n  v.v = n;\n}\n\n/**\n * Mutates observable value.\n *\n * @example\n *     const a = observable({ value: 1 });\n *     mut(a).value = 2;\n *\n * @typeparam T Observable value type.\n * @param v Observable value.\n * @returns Stored value.\n */\nexport const mut = <T>(v: Observable<T>): T => (v.t = clock(), v.v);\n\n/**\n * Creates an observable signal.\n *\n * @returns {@link Observable} value.\n */\nexport const signal = (): Observable<null> => observable(null);\n\n/**\n * Emits a signal.\n */\nexport function emit(s: Observable<null>): void {\n  s.t = clock();\n}\n\nlet watchEnabled = 0;\nexport function enableWatch() {\n  watchEnabled++;\n}\n\nexport function disableWatch() {\n  watchEnabled--;\n}\n\n/**\n * watch adds an observable to the list of dependencies.\n *\n * @typeparam T Dependency type.\n * @param v Observable or computed value.\n */\nexport function watch<T extends () => any>(v: T): T;\nexport function watch<T extends Observable<any>>(v: T): ObservableValue<T>;\nexport function watch<T extends Observable<any> | (() => any)>(v: T): any {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (watchEnabled < 1) {\n      throw Error(\"Invalid watch() invocation. watch() should be invoked in a watcher context (components, computeds)\");\n    }\n  }\n  if (_deps === null) {\n    _deps = [clock(), v];\n  } else {\n    _deps.push(v);\n  }\n  return typeof v === \"function\" ? v : (v as Observable<any>).v;\n}\n\n/**\n * saveObservableDependencies returns a {@link WatchList} and resets current dependencies.\n *\n * @returns Current {@link WatchList}.\n */\nexport function saveObservableDependencies(): WatchList {\n  const deps = _deps;\n  _deps = null;\n  return deps;\n}\n\nexport function restoreObservableDependencies(deps: WatchList): void {\n  _deps = deps;\n}\n\nexport function dirtyCheckWatchList(deps: WatchList): boolean {\n  const t = deps![0];\n  for (let i = 1; i < deps!.length; i++) {\n    const v = deps![i];\n    if (typeof v === \"object\") {\n      if (v.t > t) {\n        return true;\n      }\n    } else if ((v as (token?: DirtyCheckToken, time?: number) => any)(DIRTY_CHECK_TOKEN, t) === true) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * computed creates a computed value.\n *\n * @typeparam T Output type.\n * @param fn Computed function.\n * @returns Computed value.\n */\nexport function computed<T>(fn: (prev?: T) => T): () => T {\n  let lastCheck = 0;\n  let lastUpdate = 0;\n  let value: T | undefined = void 0;\n  let deps: WatchList = null;\n  return ((token?: DirtyCheckToken, time?: number) => {\n    const now = clock();\n    if (lastCheck < now) {\n      lastCheck = now;\n      if (deps === null || dirtyCheckWatchList(deps) === true) {\n        const prevDeps = saveObservableDependencies();\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== \"production\") {\n          enableWatch();\n        }\n        const nextValue = fn(value);\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== \"production\") {\n          disableWatch();\n        }\n        deps = saveObservableDependencies();\n        restoreObservableDependencies(prevDeps);\n        if (value !== nextValue) {\n          value = nextValue;\n          lastUpdate = now;\n        }\n      }\n    }\n    return (token === DIRTY_CHECK_TOKEN) ? lastUpdate > time! : value;\n  }) as () => T;\n}\n\n/**\n * selector creates a dirty checking selector.\n *\n * @param fn Computed function.\n * @returns Computed value.\n */\nexport function selector<T>(fn: (prev?: T) => T): () => T {\n  let lastCheck = 0;\n  let lastUpdate = 0;\n  let value: T | undefined = void 0;\n  return ((token?: DirtyCheckToken, time?: number) => {\n    const now = clock();\n    if (lastCheck < now) {\n      lastCheck = now;\n      const nextValue = fn(value);\n      if (value !== nextValue) {\n        value = nextValue;\n        lastUpdate = now;\n      }\n    }\n    return (token === DIRTY_CHECK_TOKEN) ? lastUpdate > time! : value;\n  }) as () => T;\n}\n","/**\n * Operation nodes are using several different shapes to reduce memory consumption, but it is important that we don't\n * use too many different shapes to make sure that call-sites won't switch into megamorphic state. All operations\n * are just aliases to three different shapes: `ValueOp`, `ContainerOp` and `DOMElementOp`.\n */\nimport { EventHandler } from \"../events/event_handler\";\nimport { NodeFlags } from \"./node_flags\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor } from \"./component\";\nimport { ContextDescriptor, ContextState } from \"./context\";\n\n/**\n * Key is an object that is used by TrackByKey operations to track operations.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n */\nexport interface Key<K, V> {\n  /**\n   * Key.\n   */\n  readonly k: K;\n  /**\n   * Value.\n   */\n  readonly v: V;\n}\n\n/**\n * Operation type.\n */\nexport interface OpType {\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  readonly f: NodeFlags;\n  /**\n   * Operation type descriptor.\n   */\n  readonly d:\n  | ComponentDescriptor\n  | ElementProtoDescriptor\n  | ContextDescriptor\n  | string\n  | null;\n}\n\n/**\n * createOpType creates {@link OpType} instances.\n *\n * @param f See {@link NodeFlags} for details.\n * @param d Operation type descriptor.\n * @returns {@link OpType} instance.\n */\nexport const createOpType = (\n  f: NodeFlags,\n  d: ComponentDescriptor | ElementProtoDescriptor | ContextDescriptor | string | null,\n): OpType => ({ f, d });\n\n/**\n * OpType for Events nodes.\n */\nexport const EVENTS = createOpType(NodeFlags.Events, null);\n\n/**\n * OpType for Context state nodes.\n */\nexport const SET_CONTEXT_STATE = createOpType(NodeFlags.Context | NodeFlags.SetContextState, null);\n\n/**\n * OpType for TrackByKey nodes.\n */\nexport const TRACK_BY_KEY = createOpType(NodeFlags.TrackByKey, null);\n\n/**\n * Operation with a value.\n *\n * @typeparam T Operation data type.\n */\nexport interface ValueOp<T = any> {\n  /**\n   * Operation type.\n   */\n  readonly t: OpType;\n  /**\n   * Value.\n   */\n  readonly v: T;\n}\n\n/**\n * Container operation.\n *\n * @typeparam T Operation data type.\n */\nexport interface ContainerOp<T = any, C = any> extends ValueOp<T> {\n  /**\n   * Children.\n   */\n  readonly c: C;\n}\n\n/**\n * DOM Element operation.\n *\n * @typeparam T Operation data type.\n */\nexport interface DOMElementOp<T = any> extends ContainerOp<T | undefined, Op> {\n  /**\n   * Class name.\n   */\n  readonly n: string | undefined;\n}\n\n/**\n * Events operation.\n */\nexport type EventsOp = ContainerOp<EventHandler, Op>;\n\n/**\n * Context operation.\n */\nexport type ContextOp<T = any> = ContainerOp<T, Op>;\n\n/**\n * Set context state operation.\n */\nexport type SetContextStateOp = ContainerOp<ContextState, Op>;\n\n/**\n * TrackByKey operation.\n */\nexport type TrackByKeyOp<K = any, V = any> = ValueOp<Key<K, V>[]>;\n\n/**\n * Component operation.\n */\nexport type ComponentOp<T = any, C = any> = ContainerOp<T, C>;\n\n/**\n * Operation node.\n */\nexport type OpNode =\n  | ValueOp\n  | ContainerOp\n  | DOMElementOp\n  | EventsOp\n  | ContextOp\n  | SetContextStateOp\n  | TrackByKeyOp\n  | ComponentOp;\n\n/**\n * Operation.\n */\nexport type Op = string | number | OpNode | OpArray | null;\n\n/**\n * Recursive operation array.\n */\nexport type OpArray = Array<Op>;\n\n/**\n * createValueOp creates a {@link ValueOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @returns {@link ValueOp} instance.\n */\nexport const createValueOp = <T>(t: OpType, v: T): ValueOp<T> => ({ t, v });\n\n/**\n * createContainerOp creates a {@link ContainerOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @param c Operation children.\n * @returns {@link ContainerOp} instance.\n */\nexport const createContainerOp = <T, C>(t: OpType, v: T, c: C): ContainerOp<T, C> => ({ t, v, c });\n\n/**\n * createDOMElementOp creates a {@link DOMElementOp} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param v Operation value.\n * @param c Operation children.\n * @param n Class name.\n * @returns {@link DOMElementOp} instance.\n */\nexport const createDOMElementOp = <T>(\n  t: OpType,\n  v: T,\n  c: Op,\n  n: string | undefined,\n): DOMElementOp<T> => ({ t, v, c, n });\n\n/**\n * Operation factory for event handlers.\n *\n * @example\n *\n *     render(\n *       Events(onClick(() => { console.log(\"clicked\"); }),\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param v Event handlers.\n * @param c Children operation nodes.\n * @returns Events handler operation.\n */\nexport const Events = (\n  v: EventHandler,\n  c: Op,\n): EventsOp => createContainerOp(EVENTS, v, c);\n\n/**\n * Operation factory for set context state operation.\n *\n * @param v Context state.\n * @param c Children operation nodes.\n * @returns Set context state operation.\n */\nexport const SetContextState = (\n  v: ContextState,\n  c: Op,\n): SetContextStateOp => createContainerOp(SET_CONTEXT_STATE, v, c);\n\n/**\n * key creates a {@link Key} instance.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n * @param k Key.\n * @param v Value.\n * @returns {@link Key} instance.\n */\nexport const key = <K, V>(k: K, v: V): Key<K, V> => ({ k, v });\n\n/**\n * Operation factory for track by key nodes.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *     render(\n *       TrackByKey(items.map((item) => key(item, div(_, _, item))),\n *       DOMContainer,\n *     );\n *\n * @typeparam K Key type.\n * @param items Keyed operations.\n * @returns Track by key operation.\n */\nexport const TrackByKey = process.env.NODE_ENV !== \"production\" ?\n  <T>(items: Key<T, Op>[]) => {\n    const keys = new Set<T>();\n    for (let i = 0; i < items.length; i++) {\n      const { k } = items[i];\n      if (keys.has(k)) {\n        throw new Error(`Invalid key, found duplicated key: ${k}`);\n      }\n      keys.add(k);\n    }\n    return createValueOp(TRACK_BY_KEY, items);\n  } :\n  /* istanbul ignore next */ <T>(items: Key<T, Op>[]) => createValueOp(TRACK_BY_KEY, items);\n","import { checkElement } from \"../debug/element\";\nimport { NodeFlags } from \"./node_flags\";\nimport { Op, DOMElementOp, ComponentOp, createOpType, createDOMElementOp, createContainerOp } from \"./operations\";\nimport { Component } from \"./component\";\n\n/**\n * elementFactory creates a factory for DOM elements.\n *\n * @typeparam T DOM Attributes type.\n * @typeparam U DOM Element type.\n * @param tag HTML element tag name.\n * @param flags Node flags.\n * @returns HTML element operation factory.\n */\nexport function elementFactory<T, U>(tag: string, flags: NodeFlags) {\n  const t = createOpType(flags, tag);\n  return (\n    process.env.NODE_ENV !== \"production\" ?\n      (n?: string, v?: T, c: Op = null) => {\n        checkElement(tag, v, (flags & NodeFlags.Svg) !== 0);\n        return createDOMElementOp(t, v, c, n);\n      } :\n      /* istanbul ignore next */(n?: string, v?: T, c: Op = null) => createDOMElementOp(t, v, c, n)\n  );\n}\n\n/**\n * htmlElementFactory creates a factory for HTML elements.\n *\n * @typeparam T DOM Attributes type.\n * @typeparam U DOM Element type.\n * @param tag HTML element tag name.\n * @returns HTML element operation factory.\n */\nexport const htmlElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => DOMElementOp<T | undefined> = (tag: string) => elementFactory(tag, NodeFlags.Element);\n\n/**\n * svgElementFactory creates a factory for SVG elements.\n *\n * @typeparam T DOM Attributes type.\n * @typeparam U DOM Element type.\n * @param tag SVG element tag name.\n * @returns SVG element operation factory.\n */\nexport const svgElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => DOMElementOp<T | undefined> = (tag: string) => elementFactory(tag, NodeFlags.Element | NodeFlags.Svg);\n\n/**\n * `elementProto()` creates a factory that produces elements with predefined attributes.\n *\n * @example\n *\n *     const DivWithIdAttribute = elementProto(div(_, { id: \"predefined-id\" }));\n *\n *     render(\n *       DivWithIdAttribute(\"class-name\", { title: \"Title\" }, \"Hello World\"),\n *       document.getElementById(\"app\")!,\n *     );\n *\n * @typeparam T DOM Attributes type.\n * @param p Element prototype.\n * @returns Factory that produces elements with predefined attributes.\n */\nexport function elementProto<T>(p: DOMElementOp<T>) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (p.c !== null) {\n      throw new Error(`Invalid OpNode, element prototypes can't have any children`);\n    }\n    checkElement(p.t.d as string, p.v, (p.t.f & NodeFlags.Svg) !== 0);\n  }\n  const t = createOpType(p.t.f | NodeFlags.ElementProto, { n: null, p });\n  return (n?: string, v?: T, c: Op = null) => createDOMElementOp(t, v, c, n);\n}\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @returns Factory that produces component nodes.\n */\nexport function component(\n  c: (c: Component) => () => Op,\n): () => ComponentOp<undefined>;\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @typeparam P1 First property type.\n * @typeparam P2 Second property type.\n * @param c Component function.\n * @param e1 `areEqual` function that checks `p1` for equality.\n * @param e2 `areEqual` function that checks `p2` for equality.\n * @returns Factory that produces component nodes.\n */\nexport function component<P1, P2 = undefined>(\n  c: (c: Component) => (p1: P1, p2: P2) => Op,\n  areEqual1?: undefined extends P1 ? undefined : (prev: P1, next: P1) => boolean,\n  areEqual2?: undefined extends P2 ? undefined : (prev: P2, next: P2) => boolean,\n): undefined extends P1 ?\n  (undefined extends P2 ? (p1?: P1, p2?: P2) => ComponentOp<P1, P2> : (p1: P1, p2: P2) => ComponentOp<P1, P2>) :\n  (undefined extends P2 ? (p1?: P1, p2?: P2) => ComponentOp<P1, P2> : (p1: P1, p2: P2) => ComponentOp<P1, P2>);\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @typeparam P1 First property type.\n * @typeparam P2 Second property type.\n * @param c Component function.\n * @param e1 `areEqual` function that checks `p1` for equality.\n * @param e2 `areEqual` function that checks `p2` for equality.\n * @returns Factory that produces component nodes.\n */\nexport function component<P1, P2 = undefined>(\n  c: (c: Component) => (p1: P1, p2: P2) => Op,\n  e1?: (prev: P1, next: P1) => boolean,\n  e2?: (prev: P2, next: P2) => boolean,\n): (p1: P1, p2: P2) => ComponentOp<P1, P2> {\n  const type = createOpType(NodeFlags.Component, { c, e1, e2 });\n  return (p1: P1, p2: P2) => createContainerOp(type, p1, p2);\n}\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent(\n  update: () => Op,\n): () => ComponentOp<undefined>;\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @typeparam P1 First property type.\n * @typeparam P2 Second property type.\n * @param update Update function.\n * @param areEqual1 `areEqual` function that checks `p1` for equality.\n * @param areEqual1 `areEqual` function that checks `p2` for equality.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P1, P2 = undefined>(\n  update: (p1: P1, p2: P2) => Op,\n  areEqual1?: undefined extends P1 ? undefined : (prev: P1, next: P1) => boolean,\n  areEqual2?: undefined extends P2 ? undefined : (prev: P2, next: P2) => boolean,\n): undefined extends P1 ?\n  (undefined extends P2 ? (p1?: P1, p2?: P2) => ComponentOp<P1, P2> : (p1: P1, p2: P2) => ComponentOp<P1, P2>) :\n  (undefined extends P2 ? (p1?: P1, p2?: P2) => ComponentOp<P1, P2> : (p1: P1, p2: P2) => ComponentOp<P1, P2>);\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @typeparam P1 First property type.\n * @typeparam P2 Second property type.\n * @param c Update function.\n * @param e1 `areEqual` function that checks `p1` for equality.\n * @param e2 `areEqual` function that checks `p2` for equality.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P1, P2 = undefined>(\n  c: (p1: P1, p2: P2) => Op,\n  e1?: undefined extends P1 ? undefined : (prev: P1, next: P1) => boolean,\n  e2?: undefined extends P2 ? undefined : (prev: P2, next: P2) => boolean,\n): (p1: P1, p2: P2) => ComponentOp<P1, P2> {\n  const f = (_: Component) => c;\n  return component(f, e1, e2);\n}\n","/**\n * Shortcuts for DOM methods and properties are used to reduce megamorphic callsites in the codebase.\n *\n * In many synthetic microbenchmarks it is most likely will be slower, unless synthetic benchmark is implemented with\n * many different html/svg elements. But it is definitely should make it faster in complex real applications.\n *\n * Since Chrome 74, issue with native accessors is finally fixed: https://bugs.chromium.org/p/v8/issues/detail?id=8820\n */\n\n/**\n * `Object.getOwnPropertyDescriptor(o, p)`\n *\n * @param o Object.\n * @param p Property name.\n * @returns Property Descriptor.\n */\nconst getDescriptor = (o: any, p: string | number | symbol) => Object.getOwnPropertyDescriptor(o, p);\n\nconst nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\n/**\n * Shortcut for a `Document`.\n */\nexport const doc = document;\n\n/**\n * Shortcut for an `Object.prototype.hasOwnProperty`.\n */\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Shortcut for a `Node.prototype.insertBefore`.\n */\nexport const nodeInsertBefore = nodeProto.insertBefore;\n\n/**\n * Shortcut for a `Node.prototype.removeChild`.\n */\nexport const nodeRemoveChild = nodeProto.removeChild;\n\n/**\n * Shortcut for a `Node.prototype.replaceChild`.\n */\nexport const nodeReplaceChild = nodeProto.replaceChild;\n\n/**\n * Shortcut for a `Node.prototype.cloneNode`.\n */\nexport const nodeCloneNode = nodeProto.cloneNode;\n\n/**\n * Shortcut for an `Element.prototype.setAttribute`.\n */\nexport const elementSetAttribute = elementProto.setAttribute;\n\n/**\n * Shortcut for an `Element.prototype.setAttributeNS`.\n */\nexport const elementSetAttributeNS = elementProto.setAttributeNS;\n\n/**\n * Shortcut for an `Element.prototype.removeAttribute`.\n */\nexport const elementRemoveAttribute = elementProto.removeAttribute;\n\n/**\n * Shortcut for an `Element.className = value`.\n */\nexport const elementSetClassName = getDescriptor(elementProto, \"className\")!.set;\n\n/**\n * Shortcut for a `HTMLElement.style`.\n */\nexport const htmlElementGetStyle = getDescriptor(HTMLElement.prototype, \"style\")!.get;\n\n/**\n * Shortcut for a `SVGElement.style`.\n */\nexport const svgElementGetStyle = getDescriptor(SVGElement.prototype, \"style\")!.get;\n","/**\n * Boxed value.\n *\n * @typeparam T Value type.\n */\nexport interface Box<T> {\n  v: T;\n}\n\n/**\n * box creates a boxed value.\n *\n * @typeparam T Value type.\n * @param v Value.\n * @returns Boxed value.\n */\nexport const box = <T>(v: T) => ({ v });\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\nlet error = false;\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn - Function to decorate\n * @returns function decorated with a catchError\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T;\nexport function catchError<T>(fn: Function): (...args: any[]) => T {\n  return function () {\n    if (!error) {\n      try {\n        return fn.apply(void 0, arguments);\n      } catch (e) {\n        error = true;\n        ERROR_HANDLERS.forEach((h) => { h(e); });\n        throw e;\n      }\n    }\n  };\n}\n","/**\n * NOOP function.\n */\nexport const NOOP = () => { /**/ };\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport const NOOP_FALSE = () => false;\n\n/**\n * NOOP_TRUE function always returns `true` value.\n *\n * @returns `true` value.\n */\nexport const NOOP_TRUE = () => true;\n","import { Observable, observable, watch } from \"../core\";\nimport { createOpType, createContainerOp, OpType, ContextOp, Op } from \"./operations\";\nimport { NodeFlags } from \"./node_flags\";\n\n/**\n * Context descriptor.\n */\nexport interface ContextDescriptor<T = any> {\n  /**\n   * Retrieves context value.\n   */\n  get(): T;\n  /**\n   * Creates a context operation.\n   */\n  set(value: T, children: Op): ContextOp<T>;\n}\n\n/**\n * Context state.\n */\nexport interface ContextState<T = any> {\n  /**\n   * Next state.\n   */\n  readonly n: ContextState | null;\n  /**\n   * Descriptor.\n   */\n  readonly d: ContextDescriptor<T>;\n  /**\n   * Context value.\n   */\n  readonly v: Observable<T>;\n}\n\n/**\n * Current context.\n */\nlet n: ContextState | null = null;\n\n/**\n * Used for detecting invalid `ContextDescriptor()` invocations in DEBUG mode.\n */\nlet contextEnabled = false;\n\n/**\n * Enable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function enableContext() {\n  contextEnabled = true;\n}\n\n/**\n * Disable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function disableContext() {\n  contextEnabled = false;\n}\n\n/**\n * Reset current context.\n */\nexport function resetContext() {\n  n = null;\n}\n\n/**\n * pushContext creates a new context state and pushes it to the context stack.\n *\n * @param d Context descriptor.\n * @param v Context value.\n * @returns New {@link ContextState}.\n */\nexport function pushContext<T = any>(d: ContextDescriptor<T>, v: T): ContextState<T> {\n  return n = { n, d, v: observable(v) };\n}\n\n/**\n * getContext retrieves current context.\n *\n * @returns current context.\n */\nexport function getContext(): ContextState | null {\n  return n;\n}\n\n/**\n * setContext assigns current context.\n *\n * Should be executed before going deeper into context node.\n *\n * @param c Current context.\n */\nexport function setContext(c: ContextState | null): ContextState | null {\n  return n = c;\n}\n\n/**\n * contextValue creates a context descriptor.\n *\n * @example\n *\n *     const { set: StoreContext, get: getStore } = contextValue<Store>();\n *     const Component = component((c) => (\n *       () => getStore().value\n *     ));\n *     render(\n *       StoreContext(store,\n *         Component(),\n *       ),\n *       container,\n *     );\n *\n * @returns {@link ContextDescriptor}\n */\nexport function contextValue<T = any>(): ContextDescriptor<T> {\n  let type: OpType;\n  const d = {\n    get: (): T | void => {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!contextEnabled) {\n          throw Error(\"Invalid context invocation\");\n        }\n      }\n\n      let next = n;\n      while (next !== null) {\n        if (next.d === d) {\n          return watch(next.v);\n        }\n        next = next.n;\n      }\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        throw Error(\"Unable to find context value\");\n      }\n    },\n    set: (v: T, c: Op) => createContainerOp(type, v, c),\n  };\n  type = createOpType(NodeFlags.Context, d as ContextDescriptor<T>);\n  return d as ContextDescriptor<T>;\n}\n","/**\n * If you think that some code in this module is weird, you aren't alone :) There are many code fragments in this module\n * that would be considered as a \"bad practice\" by the community, in most cases it is implemented this way because every\n * function in this module is on a hot path. It is better to overoptimize some small module, instead of pushing\n * performance issues into user space.\n */\nimport {\n  UNMOUNT_TOKEN, dirtyCheckWatchList, saveObservableDependencies, assign, enableWatch, disableWatch,\n} from \"../core\";\nimport {\n  doc, objectHasOwnProperty,\n  nodeInsertBefore, nodeRemoveChild, elementSetAttribute, nodeCloneNode, elementRemoveAttribute,\n  elementSetClassName, htmlElementGetStyle, svgElementGetStyle,\n} from \"../dom/shortcuts\";\nimport { SVG_NAMESPACE } from \"../dom/namespaces\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { NodeFlags } from \"./node_flags\";\nimport { AttributeDirective } from \"./attribute_directive\";\nimport { OpNode, DOMElementOp, EventsOp, ContextOp, TrackByKeyOp, ComponentOp, OpArray, Key, Op } from \"./operations\";\nimport { OpState } from \"./state\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, ComponentState } from \"./component\";\nimport { setContext, pushContext, ContextDescriptor, ContextState } from \"./context\";\n\nconst enum MagicValues {\n  /**\n   * One of the children nodes were moved.\n   */\n  MovedChildren = 99999999,\n  /**\n   * New node marker.\n   */\n  NewNodeMark = -1,\n  /**\n   * LIS marker.\n   */\n  LISMark = -2,\n}\n\n/**\n * Simple workaround that efficiently solves a lot of issues with fragments, nested `TrackByKey` ops and holes\n * (`null` ops).\n *\n * Reconciler always goes through the tree from right to left and updates `_nextNode` value when it goes through nodes\n * associated with DOM nodes, so when we need to insert a new DOM node, we can take it from this variable instead of\n * recursively looking for a next DOM node.\n */\nlet _nextNode!: Node | null;\n\n/**\n * _resetState resets global reconciler state.\n */\nexport function _resetState(): void {\n  _nextNode = null;\n}\n\n/**\n * VisitNodesDirective controls the traversal algorithm {@link visitNodes}`.\n */\nexport const enum VisitNodesDirective {\n  /**\n   * Continue traversing the tree.\n   */\n  Continue = 0,\n  /**\n   * Stops immediately.\n   */\n  StopImmediate = 1,\n  /**\n   * Stops traversing through children nodes and continues trversing through adjacent nodes.\n   */\n  Stop = 1 << 1,\n}\n\n/**\n * visitNodes traverses the operation state tree and invokes `visitor` function for each state node.\n *\n * @param opState State node.\n * @param visitor Visitor function.\n * @returns {@link VisitNodesDirective}\n */\nexport function visitNodes(opState: OpState, visitor: (opState: OpState) => VisitNodesDirective): VisitNodesDirective;\nexport function visitNodes(\n  opState: OpState | null,\n  visitor: (opState: OpState) => VisitNodesDirective,\n): VisitNodesDirective {\n  let i = visitor(opState!);\n  if (i !== VisitNodesDirective.Continue) {\n    return (i & VisitNodesDirective.StopImmediate);\n  }\n\n  const { f, c } = opState!;\n  if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n    for (i = 0; i < (c as Array<OpState | null>).length; i++) {\n      if (\n        (opState = (c as Array<OpState | null>)[i]) !== null &&\n        (visitNodes(opState, visitor) & VisitNodesDirective.StopImmediate) !== 0\n      ) {\n        return VisitNodesDirective.StopImmediate;\n      }\n    }\n  } else if (c !== null) {\n    return visitNodes(c as OpState, visitor);\n  }\n  return VisitNodesDirective.Continue;\n}\n\n/**\n * getDOMNode retrieves closest DOM node from the {@link OpState} instance.\n *\n * @typeparam T DOM node type.\n * @param opState State node.\n * @returns DOM node.\n */\nexport function getDOMNode<T extends Node>(opState: OpState): T | null;\nexport function getDOMNode<T extends Node>(opState: OpState | Array<OpState | null> | null): T | null {\n  let i = (opState as OpState).f;\n  let c: OpState | null;\n  if ((i & (NodeFlags.Element | NodeFlags.Text)) === 0) {\n    opState = (opState as OpState).c;\n    if ((i & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (i = 0; i < (opState as Array<OpState | null>).length; i++) {\n        if ((c = (opState as Array<OpState | null>)[i]) !== null) {\n          return getDOMNode(c);\n        }\n      }\n      return null;\n    }\n    return (opState === null) ? null : getDOMNode(opState as OpState);\n  }\n  return (opState as OpState).s as T;\n}\n\nexport function _dirtyCheck(\n  parentElement: Element,\n  opState: OpState,\n  moveNode: boolean,\n): void {\n  const flags = opState.f;\n  const c = opState.c;\n  let state;\n  let i;\n  let r;\n\n  if ((flags & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    state = opState.s as Node;\n    if (moveNode === true) {\n      nodeInsertBefore!.call(parentElement, state, _nextNode);\n    }\n    if (c !== null) {\n      _nextNode = null;\n      _dirtyCheck(state as Element, c as OpState, false);\n    }\n    _nextNode = state;\n  } else if ((flags & NodeFlags.Component) !== 0) {\n    state = opState.s as ComponentState;\n    if (\n      ((flags & NodeFlags.Dirty) !== 0) ||\n      (state.d !== null && dirtyCheckWatchList(state.d) === true)\n    ) {\n      r = opState.o as ComponentOp;\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        enableWatch();\n      }\n      r = state.r!(r.v, r.c);\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        disableWatch();\n      }\n      state.d = saveObservableDependencies();\n      opState.c = _update(\n        parentElement,\n        c as OpState | null,\n        r,\n        moveNode,\n      );\n    } else if (c !== null) {\n      _dirtyCheck(parentElement, c as OpState, moveNode);\n    }\n  } else if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n    i = (c as Array<OpState | null>).length;\n    while (i > 0) {\n      if ((state = (c as Array<OpState | null>)[--i]) !== null) {\n        _dirtyCheck(parentElement, state, moveNode);\n      }\n    }\n  } else if ((flags & NodeFlags.Events) !== 0) {\n    _dirtyCheck(parentElement, c as OpState, moveNode);\n  } else { // ((f & NodeFlags.Context) !== 0)\n    state = setContext(opState.s);\n    _dirtyCheck(parentElement, c as OpState, moveNode);\n    setContext(state);\n  }\n}\n\nfunction _unmountWalk(opState: OpState): void {\n  const flags = opState.f;\n  let children;\n  let i;\n  let v;\n\n  if ((children = opState.c) !== null) {\n    if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (i = 0; i < (children as Array<OpState | null>).length; i++) {\n        if ((v = (children as Array<OpState | null>)[i]) !== null) {\n          _unmountWalk(v);\n        }\n      }\n    } else {\n      _unmountWalk(children as OpState);\n    }\n  }\n\n  if ((flags & NodeFlags.Component) !== 0) {\n    if ((v = (opState.s as ComponentState).u) !== null) {\n      if (typeof v === \"function\") {\n        v(UNMOUNT_TOKEN);\n      } else {\n        for (i = 0; i < v.length; i++) {\n          v[i](UNMOUNT_TOKEN);\n        }\n      }\n    }\n  }\n}\n\nfunction _unmountRemove(parentElement: Element, opState: OpState): void;\nfunction _unmountRemove(\n  parentElement: Element,\n  opState: OpState | Array<OpState | null> | null,\n): void {\n  let i = (opState as OpState).f;\n  let c;\n\n  if ((i & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    nodeRemoveChild!.call(parentElement, (opState as OpState).s as Node);\n  } else {\n    opState = (opState as OpState).c;\n    if ((i & (NodeFlags.TrackByKey | NodeFlags.Fragment)) !== 0) {\n      for (i = 0; i < (opState as Array<OpState | null>).length; ++i) {\n        if ((c = (opState as Array<OpState | null>)[i]) !== null) {\n          _unmountRemove(parentElement, c);\n        }\n      }\n    } else if (opState !== null) {\n      _unmountRemove(parentElement, opState as OpState);\n    }\n  }\n}\n\nexport function _unmount(parentElement: Element, opState: OpState): void {\n  _unmountRemove(parentElement, opState);\n  _unmountWalk(opState);\n}\n\nfunction _mountText(parentElement: Element, o: string | number): OpState {\n  const s = doc.createTextNode(o as string);\n  nodeInsertBefore!.call(parentElement, s, _nextNode);\n  _nextNode = s;\n  return { f: NodeFlags.Text, o, c: null, s };\n}\n\nfunction _createElement(node: Element | undefined, op: DOMElementOp): Element {\n  const { t, v, n } = op;\n  const svg = (t.f & NodeFlags.Svg) !== 0;\n  if (node === void 0) {\n    const tagName = t.d as string;\n    node = svg ?\n      doc.createElementNS(SVG_NAMESPACE, tagName) :\n      doc.createElement(tagName);\n  }\n\n  if (n) {\n    _updateClassName(node, n, svg);\n  }\n\n  if (v !== void 0) {\n    _updateAttrs(node, void 0, v, svg);\n  }\n\n  return node;\n}\n\nfunction _mountObject(\n  parentElement: Element,\n  o: OpNode,\n): OpState {\n  const opType = o.t; // polymorphic callsite\n  const f = opType.f;\n  const opState = { f, o, c: null, s: null } as OpState;\n  let prevState;\n  let value;\n  let node;\n  let i;\n\n  if ((f & NodeFlags.Component) !== 0) {\n    opState.s = prevState = { r: null, d: null, u: null } as ComponentState;\n    // Reusing value variable.\n    prevState.r = value = (opType.d as ComponentDescriptor).c(opState);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      enableWatch();\n    }\n    node = value((o as ComponentOp).v, (o as ComponentOp).c);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      disableWatch();\n    }\n    prevState.d = saveObservableDependencies();\n    opState.c = _mount(parentElement, node);\n  } else {\n    if ((f & NodeFlags.Element) !== 0) {\n      value = opType.d;\n      if ((f & NodeFlags.ElementProto) !== 0) {\n        node = (value as ElementProtoDescriptor).n as Element;\n        if (node === null) {\n          (value as ElementProtoDescriptor).n = node = _createElement(\n            void 0,\n            (value as ElementProtoDescriptor).p,\n          );\n        }\n        node = nodeCloneNode!.call(node, false) as Element;\n      }\n      opState.s = node = _createElement(node, o as DOMElementOp);\n\n      prevState = _nextNode;\n      if ((value = (o as DOMElementOp).c) !== null) {\n        _nextNode = null;\n        opState.c = _mount(node, value);\n      }\n      _nextNode = node;\n      nodeInsertBefore!.call(parentElement, node, prevState);\n    } else if ((f & (NodeFlags.Events | NodeFlags.Context)) !== 0) {\n      if ((f & NodeFlags.Context) !== 0) {\n        opState.s = prevState = ((f & NodeFlags.SetContextState) !== 0) ?\n          setContext((o as ContextOp).v) :\n          pushContext(opType.d as ContextDescriptor, (o as ContextOp).v);\n        opState.c = _mount(parentElement, (o as ContextOp).c);\n        setContext(prevState);\n      } else {\n        opState.c = _mount(parentElement, (o as EventsOp).c);\n      }\n    } else { // ((opFlags & NodeFlags.TrackByKey) !== 0)\n      node = (o as TrackByKeyOp).v;\n      i = node.length;\n      opState.c = value = Array(i);\n      while (i > 0) {\n        value[--i] = _mount(parentElement, node[i].v);\n      }\n    }\n  }\n  return opState;\n}\n\nfunction _mountFragment(parentElement: Element, o: OpArray): OpState {\n  let i = o.length;\n  const c = Array(i);\n  while (i > 0) {\n    c[--i] = _mount(parentElement, o[i]);\n  }\n  return { f: NodeFlags.Fragment, o, c, s: null };\n}\n\nexport function _mount(\n  parentElement: Element,\n  op: Op,\n): OpState | null {\n  return (op !== null) ?\n    (\n      (typeof op === \"object\") ?\n        (\n          (op instanceof Array) ?\n            _mountFragment(parentElement, op) :\n            _mountObject(parentElement, op)\n        ) :\n        _mountText(parentElement, op)\n    ) :\n    null;\n}\n\n/**\n * _update updates a stateNode with a next operation.\n *\n * @param parentElement Parent DOM Element.\n * @param opState Operation state.\n * @param nextOp Next operation.\n * @param moveNode DOM Element should be moved.\n * @returns OpNode state.\n */\nexport function _update(\n  parentElement: Element,\n  opState: OpState | null,\n  nextOp: Op,\n  moveNode: boolean,\n): OpState | null {\n  if (nextOp === null) {\n    if (opState !== null) {\n      _unmount(parentElement, opState);\n    }\n    return null;\n  }\n  if (opState === null) {\n    return _mount(parentElement, nextOp);\n  }\n  const { f, o, s } = opState;\n\n  if ((f & NodeFlags.Text) !== 0) {\n    if (typeof nextOp !== \"object\") {\n      // Reassign to reduce memory consumption even if nextOp is strictly equal to the prev op.\n      opState.o = nextOp;\n      if (o !== nextOp) {\n        (s as Node).nodeValue = nextOp as string;\n      }\n      if (moveNode === true) {\n        nodeInsertBefore!.call(parentElement, s as Node, _nextNode);\n      }\n      _nextNode = s as Node;\n    } else {\n      nodeRemoveChild!.call(parentElement, s as Node);\n      return _mount(parentElement, nextOp);\n    }\n  } else {\n    // Here we don't need to reassign nextOp because op should always be an object, and strict equality will guarantee\n    // that this object is occupying the same memory region.\n    if (o === nextOp) {\n      _dirtyCheck(parentElement, opState, moveNode);\n      return opState;\n    }\n    if (\n      ((f & NodeFlags.Fragment) !== 0 ?\n        !(nextOp instanceof Array) :\n        (\n          nextOp instanceof Array ||\n          (o as OpNode).t !== (nextOp as OpNode).t // polymorphic callsites\n        )\n      )\n    ) {\n      _unmount(parentElement, opState);\n      return _mount(parentElement, nextOp);\n    }\n    opState.o = nextOp;\n    const opStateChildren = opState.c;\n    let prevData1;\n    let nextData1;\n    let prevData2;\n    let nextData2;\n    let nextValue;\n    let i;\n\n    if ((f & NodeFlags.Component) !== 0) {\n      prevData1 = (o as ComponentOp).v;\n      prevData2 = (o as ComponentOp).c;\n      nextData1 = (nextOp as ComponentOp).v;\n      nextData2 = (nextOp as ComponentOp).c;\n      nextValue = (nextOp as ComponentOp).t.d as ComponentDescriptor;\n      // Prioritize checking 2nd property as it is most likely will be used to pass children nodes or custom render\n      // function, so it won't have any complex `areEqual` checking.\n      if (\n        (\n          (prevData2 !== nextData2) &&\n          (nextValue.e2 === void 0 || nextValue.e2(prevData2, nextData2) !== true)\n        ) || (\n          (prevData1 !== nextData1) &&\n          (nextValue.e1 === void 0 || nextValue.e1(prevData1, nextData1) !== true)\n        )\n      ) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== \"production\") {\n          enableWatch();\n        }\n        nextData1 = (s as ComponentState).r!(nextData1, nextData2);\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== \"production\") {\n          disableWatch();\n        }\n        (s as ComponentState).d = saveObservableDependencies();\n\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          nextData1,\n          moveNode,\n        );\n      } else {\n        _dirtyCheck(parentElement, opState, moveNode);\n      }\n    } else {\n      if ((f & NodeFlags.Element) !== 0) {\n        i = (f & NodeFlags.Svg) !== 0;\n\n        if ((o as DOMElementOp).n !== (nextValue = (nextOp as DOMElementOp).n)) {\n          if (nextValue === void 0) {\n            nextValue = \"\";\n          }\n          _updateClassName(s as Element, nextValue, i);\n        }\n\n        if ((o as DOMElementOp).v !== (nextValue = (nextOp as DOMElementOp).v)) {\n          _updateAttrs(s as Element, (o as DOMElementOp).v, nextValue, i);\n        }\n\n        if (moveNode === true) {\n          nodeInsertBefore!.call(parentElement, s as Element, _nextNode);\n        }\n\n        _nextNode = null;\n        opState.c = _update(s as Element, opStateChildren as OpState, (nextOp as DOMElementOp).c, false);\n        _nextNode = s as Node;\n      } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n        if ((f & NodeFlags.Fragment) !== 0) {\n          i = (nextOp as OpArray).length;\n          if (i === 0) {\n            _unmount(parentElement, opState);\n          } else {\n            prevData1 = (opStateChildren as Array<OpState | null>).length;\n            if (i !== prevData1) {\n              opState.c = nextValue = Array(i);\n              while (prevData1 > i) {\n                nextData1 = (opStateChildren as Array<OpState | null>)[--prevData1];\n                if (nextData1 !== null) {\n                  _unmount(parentElement, nextData1);\n                }\n              }\n              while (i > prevData1) {\n                nextValue[--i] = _mount(parentElement, (nextOp as OpArray)[i]);\n              }\n            } else {\n              nextValue = (opStateChildren as Array<OpState | null>);\n            }\n            while (i > 0) {\n              nextValue[--i] = _update(\n                parentElement,\n                (opStateChildren as Array<OpState | null>)[i],\n                (nextOp as OpArray)[i],\n                moveNode,\n              );\n            }\n          }\n        } else {\n          _updateChildrenTrackByKeys(\n            parentElement,\n            opState,\n            (o as TrackByKeyOp).v,\n            (nextOp as TrackByKeyOp).v,\n            moveNode,\n          );\n        }\n      } else if ((f & NodeFlags.Events) !== 0) {\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          (nextOp as EventsOp).c,\n          moveNode,\n        );\n      } else { // if ((flags & NodeFlags.Context) !== 0) {\n        nextData1 = (nextOp as ContextOp).v;\n        if ((f & NodeFlags.SetContextState) !== 0) {\n          opState.s = nextData1;\n        } else {\n          nextValue = (s as ContextState).v;\n          if (nextValue.v !== nextData1) {\n            assign(nextValue, nextData1);\n          }\n        }\n        nextValue = setContext(opState.s);\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          (nextOp as ContextOp).c,\n          moveNode,\n        );\n        setContext(nextValue);\n      }\n    }\n  }\n\n  return opState;\n}\n\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function.\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Common prefix and suffix optimization.\n *\n * This optimization technique is looking for nodes with identical keys by simultaneously iterating through nodes in the\n * old children list `A` and new children list `B` from both sides.\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Skip nodes \"a\" and \"b\" at the start, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * 2. Zero length optimizations.\n *\n * Check if the size of one of the list is equal to zero. When length of the old children list is zero, insert remaining\n * nodes from the new list. When length of the new children list is zero, remove remaining nodes from the old list.\n *\n *  A: -> [a b c g] <-\n *  B: -> [a g] <-\n *\n * Skip nodes \"a\" and \"g\" (prefix and suffix optimization).\n *\n *  A: [b c]\n *  B: []\n *\n * Remove nodes \"b\" and \"c\".\n *\n * 3. Index and unmount removed nodes.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Create array `P` (`sources` variable) with the length of the new children list and fill it with `-1` values\n * (`MagicValue.NewNodeMark` constant). `-1` value indicates that node at this position should be mounted. Later we will\n * assign node positions in the old children list to this array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0, // B[0] == c\n *    b: 1, // B[1] == b\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * Create reverse index `I` that maps keys to node positions in the new children list.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * Assign original positions of the nodes from the old children list to the array `P`.\n *\n * Iterate through nodes in the old children list and get their new positions from the index `I`. Assign old node\n * position to the array `P`. When index `I` doesn't have a key for the old node, it means that it should be unmounted.\n *\n * When we assigning positions to the array `P`, we also store a position of the last seen node in the new children\n * list (`pos` variable), if the last seen position is greater than current position of the node at the new list, then\n * we are switching `moved` flag to `true` (`pos === MagicValue.MovedChildren`).\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is greater than current position of the node at the new list `0`, switch `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index `I`, unmount node `d`.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position `3` for `e` node.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position `4` for 'f' node.\n *\n * 4. Find minimum number of moves when `moved` flag is on and mount new nodes.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 * . 4 *] // . == -1  * == -2\n *\n * When `moved` is on, mark all nodes in the array `P` that belong to the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) and move all nodes that\n * doesn't belong to this subsequence.\n *\n * Iterate over the new children list and the `P` array simultaneously. When value from `P` array is equal to `-1`,\n * mount a new node. When it isn't equal to `-2`, move it.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 * . 4 *] // . == -1  * == -2\n *              ^\n *\n * Node \"e\" has `-2` value in the array `P`, nothing changes.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 * . 4 *] // . == -1  * == -2\n *            ^\n *\n * Node \"f\" has `4` value in the array `P`, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 * . 4 *] // . == -1  * == -2\n *          ^\n *\n * Node \"h\" has `-1` value in the array `P`, mount new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 * . 4 *] // . == -1  * == -2\n *        ^\n *\n * Node \"b\" has `-2` value in the array `P`, nothing changes.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 * . 4 *] // . == -1  * == -2\n *\n * Node \"c\" has `1` value in the array `P`, move it before the next node \"b\".\n *\n * When `moved` flag is off, skip LIS algorithm and mount nodes that have `-1` value in the array `P`.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * NOTE: There are many variations of this algorithm that are used by many UI libraries and many implementations are\n * still using an old optimization technique that were removed several years ago from this implementation. This\n * optimization were used to improve performance of simple moves/swaps. For example:\n *\n *  A: -> [a b c] <-\n *  B: -> [c b a] <-\n *\n * Move \"a\" and \"c\" nodes to the other edge.\n *\n *  A: -> [b] <-\n *  B: -> [b] <-\n *\n * Skip node \"b\".\n *\n * This optimization were removed because it breaks the promise that insert and remove operations shouldn't trigger a\n * move operation. For example:\n *\n *  A: -> [a b]\n *  B:    [c a] <-\n *\n * Move node \"a\" to the end.\n *\n *  A: [b]\n *  B: [c]\n *\n * Remove node \"b\" and insert node \"c\".\n *\n * In this use case, this optimization performs one unnecessary operation. Instead of removing node \"b\" and inserting\n * node \"c\", it also moves node `a`.\n *\n * @param parentElement Parent DOM element.\n * @param opState OpNode state for a TrackByKey operation.\n * @param a Previous operations.\n * @param b Next operations.\n * @param moveNode Children DOM nodes should be moved.\n * @noinline\n * @__NOINLINE__\n */\nfunction _updateChildrenTrackByKeys(\n  parentElement: Element,\n  opState: OpState,\n  a: Key<any, OpNode>[],\n  b: Key<any, OpNode>[],\n  moveNode: boolean,\n): void {\n  let i = b.length;\n  let j: number | undefined = a.length;\n  let result = Array(i);\n\n  if (i === 0) { // New children list is empty.\n    if (j > 0) { // Unmount nodes from the old children list.\n      _unmount(parentElement, opState);\n    }\n  } else if (j === 0) { // Old children list is empty.\n    while (i > 0) { // Mount nodes from the new children list.\n      result[--i] = _mount(parentElement, b[i].v);\n    }\n  } else {\n    let opStateChildren = opState.c as Array<OpState | null>;\n    let aEnd = j - 1; // a.length - 1\n    let bEnd = i - 1; // b.length - 1\n    let start = 0;\n    let node: OpNode | Key<any, OpNode> | OpState | null = b[bEnd];\n\n    // Step 1\n    outer: while (true) {\n      // Update nodes with the same key at the end.\n      while (a[aEnd].k === node.k) {\n        result[bEnd] = _update(parentElement, opStateChildren[aEnd--], node.v, moveNode);\n        if (start > --bEnd || start > aEnd) {\n          break outer;\n        }\n        node = b[bEnd];\n      }\n\n      // Update nodes with the same key at the beginning.\n      while (a[start].k === b[start].k && ++start <= aEnd && start <= bEnd) {\n        // delayed update (all updates should be performed from right-to-left).\n      }\n\n      break;\n    }\n\n    // Step 2\n    if (start > aEnd) {\n      // All nodes from `a` are updated, insert the rest from `b`.\n      while (bEnd >= start) {\n        result[bEnd] = _mount(parentElement, b[bEnd--].v);\n      }\n    } else if (start > bEnd) {\n      // All nodes from `b` are updated, remove the rest from `a`.\n      i = start;\n      do {\n        if ((node = opStateChildren[i++]) !== null) {\n          _unmount(parentElement, node);\n        }\n      } while (i <= aEnd);\n    } else { // Step 3\n      // When `pos === 99999999`, it means that one of the nodes is in the wrong position and we should rearrange nodes\n      // with LIS-based algorithm `markLIS()`.\n      let pos = 0;\n      let bLength = bEnd - start + 1;\n      let sources = new Int32Array(bLength); // Maps positions in the new children list to positions in the old list.\n      let keyIndex = new Map<any, number>(); // Maps keys to their positions in the new children list.\n      for (i = 0; i < bLength; ++i) {\n        j = i + start;\n        // `NewNodeMark` value indicates that node doesn't exist in the old children list.\n        sources[i] = MagicValues.NewNodeMark;\n        keyIndex.set(b[j].k, j);\n      }\n\n      for (i = start; i <= aEnd; ++i) {\n        j = keyIndex.get(a[i].k);\n        node = opStateChildren[i];\n        if (j !== void 0) {\n          pos = (pos < j) ? j : MagicValues.MovedChildren;\n          sources[j - start] = i;\n          result[j] = node;\n        } else if (node !== null) {\n          _unmount(parentElement, node);\n        }\n      }\n\n      // Step 4\n\n      // Mark LIS nodes only when this node weren't moved `moveNode === false` and we've detected that one of the\n      // children nodes were moved `pos === MagicValues.MovedChildren`.\n      if (moveNode === false && pos === MagicValues.MovedChildren) {\n        markLIS(sources);\n      }\n      while (bLength-- > 0) {\n        bEnd = bLength + start;\n        node = b[bEnd].v;\n        j = sources[bLength];\n        result[bEnd] = (j === -1) ?\n          _mount(parentElement, node) :\n          _update(\n            parentElement,\n            result[bEnd],\n            node,\n            moveNode || (pos === MagicValues.MovedChildren && j !== MagicValues.LISMark),\n          );\n      }\n    }\n\n    // Delayed update for nodes from Step 1 (prefix only). Reconciliation algorithm always updates nodes from right to\n    // left.\n    while (start > 0) {\n      result[--start] = _update(parentElement, opStateChildren[start], b[start].v, moveNode);\n    }\n  }\n  opState.c = result;\n}\n\n/**\n * Modified Longest Increased Subsequence algorithm.\n *\n * Mutates input array `a` and replaces all values that are part of LIS with -2 value.\n *\n * Constraints:\n * - Doesn't work with negative numbers. -1 values are ignored.\n * - Input array `a` should contain at least one value that is greater than -1.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @example\n *\n *   const A = Int32Array.from([-1, 0, 2, 1]);\n *   markLIS(A);\n *   // A => [-1, -2, 2, -2]\n *\n * @param a Array of numbers.\n * @noinline\n * @__NOINLINE__\n */\nfunction markLIS(a: Int32Array): void {\n  let length = a.length;\n  let parent = new Int32Array(length);\n  let index = new Int32Array(length);\n  let indexLength = 0;\n  let i = 0;\n  let j: number;\n  let k: number;\n  let lo: number;\n  let hi: number;\n\n  // Skip -1 values at the start of the input array `a`.\n  for (; a[i] === MagicValues.NewNodeMark; ++i) { /**/ }\n\n  index[0] = i++;\n  for (; i < length; ++i) {\n    k = a[i];\n    if (k !== MagicValues.NewNodeMark) { // Ignore -1 values.\n      j = index[indexLength];\n      if (a[j] < k) {\n        parent[i] = j;\n        index[++indexLength] = i;\n      } else {\n        lo = 0;\n        hi = indexLength;\n\n        while (lo < hi) {\n          j = (lo + hi) >> 1;\n          if (a[index[j]] < k) {\n            lo = j + 1;\n          } else {\n            hi = j;\n          }\n        }\n\n        if (k < a[index[lo]]) {\n          if (lo > 0) {\n            parent[i] = index[lo - 1];\n          }\n          index[lo] = i;\n        }\n      }\n    }\n  }\n\n  // Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n  j = index[indexLength];\n  while (indexLength-- >= 0) {\n    a[j] = MagicValues.LISMark;\n    j = parent[j];\n  }\n}\n\n/**\n * Update DOM classname.\n *\n * @param element DOM Element.\n * @param className Class name.\n * @param svg SVG Element.\n */\nfunction _updateClassName(element: Element, className: string, svg: boolean): void {\n  /**\n   * SVGElement.className returns `SVGAnimatedString`.\n   *\n   * #quirks\n   */\n  if (svg === true) {\n    elementSetAttribute!.call(element, \"class\", className);\n  } else {\n    elementSetClassName!.call((element as HTMLElement), className);\n  }\n}\n\n/**\n * Update DOM styles.\n *\n * @param element HTML or SVG Element.\n * @param a Prev styles.\n * @param b Next styles.\n * @param svg SVG element.\n */\nfunction _updateStyle(\n  element: HTMLElement | SVGElement,\n  a: Record<string, string> | undefined,\n  b: Record<string, string> | undefined,\n  svg: boolean,\n): void {\n  const style = svg === true ? svgElementGetStyle!.call(element) : htmlElementGetStyle!.call(element);\n  let key: string;\n  let bValue;\n\n  if (a === void 0) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = b![key];\n      if (bValue !== void 0) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all styles from a\n    for (key in a) {\n      if (a[key] !== void 0) {\n        style.removeProperty(key);\n      }\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      const aValue = a[key];\n      bValue = (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0;\n      if (aValue !== bValue) {\n        if (bValue !== void 0) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        bValue = b[key];\n        ++matchCount;\n        if (bValue !== void 0) {\n          style.setProperty(key, b[key]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attributes.\n *\n * @param element DOM element.\n * @param a Prev DOM attributes.\n * @param b Next DOM attributes.\n * @param svg SVG element.\n */\nfunction _updateAttrs(\n  element: Element,\n  a: Record<string, string | number | AttributeDirective<any> | CSSStyleProps | undefined> | undefined,\n  b: Record<string, string | number | AttributeDirective<any> | CSSStyleProps | undefined> | undefined,\n  svg: boolean,\n): void {\n  let key: string;\n\n  if (a === void 0) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      _updateAttr(element, key, void 0, b![key], svg);\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all attributes from a.\n    for (key in a) {\n      _updateAttr(element, key, a[key], void 0, svg);\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      _updateAttr(\n        element,\n        key,\n        a[key],\n        (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0,\n        svg,\n      );\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        _updateAttr(element, key, void 0, b[key], svg);\n        ++matchCount;\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attribute.\n *\n * @param element DOM Element.\n * @param key Attribute name.\n * @param prev Previous value.\n * @param next Next value.\n * @param svg SVG element.\n */\nfunction _updateAttr(\n  element: Element,\n  key: string,\n  prev: string | number | AttributeDirective<any> | CSSStyleProps | undefined,\n  next: string | number | AttributeDirective<any> | CSSStyleProps | undefined,\n  svg: boolean,\n): void {\n  if (key !== \"style\") {\n    if (typeof next === \"object\") {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof prev !== \"object\" && prev !== void 0) {\n          throw new Error(\n            `Invalid DOM attribute, transitioning from basic values to attribute directives isn't allowed`,\n          );\n        }\n      }\n      (next as AttributeDirective<any>).u!(\n        element,\n        key,\n        prev === void 0 ? void 0 : (prev as AttributeDirective<any>).v,\n        next.v,\n      );\n    } else if (typeof prev === \"object\") {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== \"production\") {\n        if (typeof next !== \"object\" && next !== void 0) {\n          throw new Error(\n            `Invalid DOM attribute, transitioning from attribute directives to basic values isn't allowed`,\n          );\n        }\n      }\n      (prev as AttributeDirective<any>).u!(\n        element,\n        key,\n        (prev as AttributeDirective<any>).v,\n        void 0,\n      );\n    } else if (prev !== next) {\n      if (next === void 0) {\n        elementRemoveAttribute!.call(element, key);\n      } else {\n        elementSetAttribute!.call(element, key, next as string);\n      }\n    }\n  } else if (prev !== next) {\n    _updateStyle(element as HTMLElement, prev as CSSStyleProps, next as CSSStyleProps, svg);\n  }\n}\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n","import { Op } from \"./operations\";\nimport { OpState } from \"./state\";\nimport { _mount, _update, _unmount, _dirtyCheck, _resetState } from \"./reconciler\";\nimport { enableContext, disableContext } from \"./context\";\n\n/**\n * Root.\n */\nexport interface Root {\n  /**\n   * Container element.\n   */\n  container: Element | null;\n  /**\n   * Current state.\n   */\n  state: OpState | null;\n  /**\n   * Next operation.\n   */\n  next: Op | undefined;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Find root node of a container.\n *\n * @param predicate - Find predicate.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport const findRoot = (predicate: (root: Root) => boolean) => ROOTS.find(predicate);\n\n/**\n * Performs a dirty checking.\n */\nexport function dirtyCheck() {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    enableContext();\n  }\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const root = ROOTS[i];\n    const { container, state, next } = root;\n    _resetState();\n    if (next !== void 0) {\n      root.next = void 0;\n      root.state = _update(container!, state, next, false);\n    } else if (state !== null) {\n      _dirtyCheck(container!, state, false);\n    }\n  }\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    disableContext();\n  }\n}\n","import { NOOP, catchError, box, Box, TaskToken, TASK_TOKEN, advanceClock } from \"../core\";\nimport { printWarn } from \"../debug/print\";\nimport { doc } from \"../dom/shortcuts\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { Op } from \"../vdom/operations\";\nimport { Component } from \"../vdom/component\";\nimport { ROOTS, findRoot, dirtyCheck } from \"../vdom/root\";\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  /**\n   * Running inside of a scheduler context.\n   */\n  Running = 1,\n  /**\n   * Scheduler tick is pending for an execution.\n   */\n  TickPending = 1 << 1,\n  /**\n   * Frame update is pending for an execution.\n   */\n  NextFramePending = 1 << 2,\n  /**\n   * Running inside of a frame update context.\n   */\n  UpdatingFrame = 1 << 3,\n  /**\n   * Dirty checking is pending for an execution.\n   */\n  DirtyCheckPending = 1 << 4,\n}\n\nconst enum SchedulerDebugFlags {\n  DirtyCheckingFinished = 1,\n  MutationsFinished = 1 << 1,\n  LayoutFinished = 1 << 2,\n}\n\n/**\n * Task list.\n */\ntype TaskList = Box<Array<(token: TaskToken) => void>>;\n\n/**\n * Execute tasks from the `TaskList`.\n *\n * @param t - Task list\n */\nfunction run(t: TaskList) {\n  while (t.v.length > 0) {\n    const tasks = t.v;\n    t.v = [];\n    for (let i = 0; i < tasks.length; ++i) {\n      tasks[i](TASK_TOKEN);\n    }\n  }\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _debugFlags: SchedulerDebugFlags = 0;\n\nlet _frameStartTime = 0;\nconst _resolvedPromise = Promise.resolve();\nconst _microtasks = box<Array<(token: TaskToken) => void>>([]);\nconst _mutationEffects = box<Array<(token: TaskToken) => void>>([]);\nconst _layoutEffects = box<Array<(token: TaskToken) => void>>([]);\n\n/**\n * withSchedulerTick wraps `inner` function into a scheduler context execution.\n *\n * @typeparam T Arguments.\n * @param inner Inner function.\n * @returns function that will be executed in a scheduler context.\n */\nexport const withSchedulerTick = <T extends any[]>(inner: (...args: T) => void) => (\n  catchError(function () {\n    _flags |= SchedulerFlags.Running;\n    inner.apply(void 0, arguments as unknown as T);\n    run(_microtasks);\n    _flags &= ~(SchedulerFlags.Running | SchedulerFlags.TickPending);\n    advanceClock();\n  })\n) as (...args: T) => void;\n\nconst runMicrotasks = withSchedulerTick(NOOP);\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task Microtask.\n */\nexport function scheduleMicrotask(task: (token: TaskToken) => void): void {\n  _microtasks.v.push(task);\n  if ((_flags & (SchedulerFlags.Running | SchedulerFlags.TickPending)) === 0) {\n    _flags |= SchedulerFlags.TickPending;\n    _resolvedPromise.then(runMicrotasks);\n  }\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport const frameStartTime = () => _frameStartTime;\n\nlet _nextFrame = (time: number | undefined) => {\n  if ((_flags & SchedulerFlags.DirtyCheckPending) !== 0) {\n    dirtyCheck();\n  }\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    _debugFlags |= SchedulerDebugFlags.DirtyCheckingFinished;\n  }\n  run(_mutationEffects);\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    _debugFlags |= SchedulerDebugFlags.MutationsFinished;\n  }\n  run(_layoutEffects);\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    _debugFlags |= SchedulerDebugFlags.LayoutFinished;\n  }\n};\n\n/**\n * addNextFrameMiddleware adds next frame middleware function.\n *\n * @param fn Next frame middleware function.\n */\nexport function addNextFrameMiddleware(\n  fn: (time: number | undefined, next: (time?: number) => void) => void,\n): void {\n  const next = _nextFrame;\n  _nextFrame = (time: number | undefined) => { fn(time, next); };\n}\n\n/**\n * withNextFrame wraps `inner` function into a scheduler frame update context.\n *\n * @param inner Inner function.\n * @returns function that will be executed in a frame update context.\n */\nexport const withNextFrame = (inner: (time?: number) => void) => (\n  withSchedulerTick((time?: number) => {\n    _flags |= SchedulerFlags.UpdatingFrame;\n    inner(time);\n\n    if ((_flags & SchedulerFlags.NextFramePending) !== 0) {\n      if (time !== void 0) {\n        _frameStartTime = time;\n      }\n      _nextFrame(time);\n    }\n    _flags &= ~(\n      SchedulerFlags.UpdatingFrame |\n      SchedulerFlags.NextFramePending |\n      SchedulerFlags.DirtyCheckPending\n    );\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      _debugFlags &= ~(\n        SchedulerDebugFlags.DirtyCheckingFinished |\n        SchedulerDebugFlags.MutationsFinished |\n        SchedulerDebugFlags.LayoutFinished\n      );\n    }\n  })\n);\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = withNextFrame(NOOP);\n\n/**\n * requestNextFrame requests an update for next frame.\n */\nexport function requestNextFrame(): void {\n  if ((_flags & SchedulerFlags.NextFramePending) === 0) {\n    _flags |= SchedulerFlags.NextFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      requestAnimationFrame(_handleNextFrame);\n    }\n  }\n}\n\n/**\n * Adds a write DOM task to the queue.\n *\n * @param fn Write DOM task.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function scheduleMutationEffect(fn: (token: TaskToken) => void): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Mutation effect is scheduled after mutations were finished\");\n      }\n    }\n  }\n  _mutationEffects.v.push(fn);\n  requestNextFrame();\n}\n\n/**\n * debounceMutationEffect creates debounced mutation effect.\n *\n * @typeparam T Effect props type.\n * @param fn Mutation effect.\n * @returns Debounced mutation effect.\n */\nexport function debounceMutationEffect<T>(fn: (value: T) => void): (nextValue: T) => void {\n  let wait = 0;\n  let value: T | undefined;\n  return (nextValue: T) => {\n    value = nextValue;\n    if (wait === 0) {\n      wait = 1;\n      scheduleMutationEffect(() => {\n        fn(value!);\n        wait = 0;\n        value = void 0;\n      });\n    }\n  };\n}\n\n/**\n * Adds a DOM layout task to the queue.\n *\n * @param fn Read DOM task\n */\nexport function scheduleLayoutEffect(fn: (token: TaskToken) => void): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Layout effect is scheduled after layout were finished\");\n      }\n    }\n  }\n  _layoutEffects.v.push(fn);\n  requestNextFrame();\n}\n\n/**\n * Request dirty checking.\n */\nexport function requestDirtyCheck(): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Dirty checking is scheduled after dirty checking were finished\");\n      }\n    }\n  }\n  _flags |= SchedulerFlags.DirtyCheckPending;\n  requestNextFrame();\n}\n\n/**\n * Invalidate component.\n *\n * @param c Component instance.\n */\nexport function invalidate(c: Component): void {\n  c.f |= NodeFlags.Dirty;\n  requestDirtyCheck();\n}\n\n/**\n * Render operation into the container.\n *\n * @param next Operation to render.\n * @param container DOM Node that will contain rendered operation.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function render(next: Op, container: Element): void {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    /**\n     * Rendering into the <body> element is disabled to make it possible to fix iOS quirk with click events.\n     */\n    if (container === doc.body) {\n      throw new Error(\"Rendering into the <body> element aren't allowed\");\n    }\n    if (!doc.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document\");\n    }\n  }\n\n  const root = findRoot((v) => v.container === container);\n  if (root) {\n    root.next = next;\n  } else {\n    ROOTS.push({ container, state: null, next });\n  }\n\n  requestDirtyCheck();\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = (\n  (process.env.IVI_TARGET === \"electron\") ? true :\n  /*#__PURE__*/(() => {\n      let v = false;\n      try {\n        // Test via a getter in the options object to see if the passive property is accessed\n        window.addEventListener(\"_\", null as any, {\n          get passive(): boolean {\n            return v = true;\n          },\n        });\n      } catch (e) {\n        // ignore\n      }\n      return v;\n    })()\n);\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = (\n  (process.env.IVI_TARGET === \"electron\") ||\n  (process.env.IVI_TARGET === \"evergreen\") ||\n  /*#__PURE__*/KeyboardEvent.prototype.hasOwnProperty(\"key\")\n);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = (\n  (process.env.IVI_TARGET === \"electron\") ||\n  (process.env.IVI_TARGET === \"evergreen\") ||\n  /*#__PURE__*/MouseEvent.prototype.hasOwnProperty(\"buttons\")\n);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\n  (\"ontouchstart\" in window)\n);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = (\n  (process.env.IVI_TARGET === \"electron\") ||\n  (\"PointerEvent\" in window)\n);\n\n/* istanbul ignore next */\n/**\n * iOS proprietary GestureEvent.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent}\n */\nexport const IOS_GESTURE_EVENT = (\n  (process.env.IVI_TARGET === \"browser\") &&\n  (\"GestureEvent\" in window)\n);\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = (\n  (process.env.IVI_TARGET === \"electron\") ||\n  (\"InputDeviceCapabilities\" in window)\n);\n","import { PASSIVE_EVENTS } from \"../dom/feature_detection\";\n\n/* istanbul ignore next */\n/**\n * getEventTarget retrieves target element from an event.\n *\n * There are still some differences in modern browsers, so we need to use this function to retrieve event targets.\n *\n * #quirks\n *\n * @param ev Event.\n * @returns Target Element.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n  let target = ev.target || window;\n\n  /**\n   * Some browsers are implementing it according to SVG 1.1 specs:\n   *\n   * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7998724/\n   *\n   * \"If event attributes are assigned to referenced elements, then the actual target for the event will be the\n   * SVGElementInstance object within the 'instance tree' corresponding to the given referenced element.\"\n   *\n   * https://www.w3.org/TR/SVG/struct.html#UseElement\n   *\n   * SVG 2 redefined the use event handling model:\n   *\n   * - Removed the SVGElementInstance and SVGElementInstanceList interfaces, and the corresponding attributes on the\n   *   SVGUseElement interface.\n   * - Changed the ‘use’ element event flow to follow the Shadow DOM spec.\n   *\n   * https://www.w3.org/TR/SVG2/changes.html#structure\n   */\n  if ((target as any).correspondingUseElement !== void 0) {\n    target = (target as any).correspondingUseElement;\n  }\n\n  return target;\n}\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": true } : true;\n\n/* istanbul ignore next */\n/**\n * `{ capture: true, passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_CAPTURE_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"capture\": true, \"passive\": false } : true;\n\n/* istanbul ignore next */\n/**\n * `{ passive: true }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_PASSIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": true } : false;\n\n/* istanbul ignore next */\n/**\n * `{ passive: false }` object that should be used as a 3rd parameter for `addEventListener` method.\n */\nexport const EVENT_ACTIVE_OPTIONS = PASSIVE_EVENTS ? { \"passive\": false } : false;\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { doc } from \"../dom/shortcuts\";\nimport { OpState } from \"../vdom/state\";\nimport { withSchedulerTick } from \"../scheduler\";\nimport { EventHandlerNode, EventHandlerFlags } from \"./event_handler\";\nimport { DispatchTarget, dispatchEvent } from \"./dispatch\";\nimport { EVENT_CAPTURE_ACTIVE_OPTIONS } from \"./utils\";\n\nexport interface NativeEventSource<E extends Event> {\n  next: (event: E) => void;\n}\n\nexport type NativeEventHandler<E extends Event> = (event: E, currentTarget: OpState, src: {}) => number | void;\n\nconst dispatchNativeEvent = (event: Event, currentTarget: DispatchTarget<NativeEventHandler<Event>>, src: {}) => (\n  currentTarget.h.h(event, currentTarget.t, src)\n);\n\n/**\n * Creates a native event source.\n *\n * @typeparam E Native event type.\n * @param flags See {@link NativeEventSourceFlags} for details.\n * @param name Event name\n * @param options Event handler options\n * @returns {@link NativeEventSource} instance\n */\nexport function createNativeEventSource<E extends Event>(\n  name: string,\n  options: { capture?: boolean; passive?: boolean } | boolean = true,\n): NativeEventSource<E> {\n  const source = {\n    next: (event: Event): void => {\n      dispatchEvent(source, event.target as Element, event);\n    },\n  };\n  doc.addEventListener(name, withSchedulerTick((event) => { source.next(event); }), options);\n  return source;\n}\n\nexport function addNativeEventMiddleware<E extends Event>(\n  source: NativeEventSource<E>,\n  fn: (event: E, next: (event: E) => void) => void,\n): void {\n  const next = source.next;\n  source.next = (event: E) => { fn(event, next); };\n}\n\nexport const ABORT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"abort\")\n);\nexport const ACTIVATE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"activate\")\n);\nexport const ARIA_REQUEST_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"ariarequest\")\n);\nexport const BEFORE_ACTIVATE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"beforeactivate\")\n);\nexport const BEFORE_COPY_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforecopy\")\n);\nexport const BEFORE_CUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforecut\")\n);\nexport const BEFORE_DEACTIVATE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"beforedeactivate\")\n);\nexport const BEFORE_PASTE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"beforepaste\")\n);\nexport const BLUR_EVENT = (\n  /*#__PURE__*/createNativeEventSource<FocusEvent>(\"blur\")\n);\nexport const CAN_PLAY_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"canplay\")\n);\nexport const CAN_PLAYTHROUGH_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"canplaythrough\")\n);\nexport const CHANGE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"change\")\n);\nexport const CLICK_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"click\")\n);\nexport const CONTEXT_MENU_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"contextmenu\")\n);\nexport const COPY_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"copy\")\n);\nexport const CUE_CHANGE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"cuechange\")\n);\nexport const CUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"cut\")\n);\nexport const DOUBLE_CLICK_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"dblclick\")\n);\nexport const DEACTIVATE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"deactivate\")\n);\nexport const DRAG_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"drag\")\n);\nexport const DRAG_END_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragend\")\n);\nexport const DRAG_ENTER_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragenter\")\n);\nexport const DRAG_LEAVE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragleave\")\n);\nexport const DRAG_OVER_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragover\")\n);\nexport const DRAG_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"dragstart\")\n);\nexport const DROP_EVENT = (\n  /*#__PURE__*/createNativeEventSource<DragEvent>(\"drop\")\n);\nexport const DURATION_CHANGE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"durationchange\")\n);\nexport const EMPTIED_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"emptied\")\n);\nexport const ENCRYPTED_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MediaEncryptedEvent>(\"encrypted\")\n);\nexport const ENDED_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MediaStreamErrorEvent>(\"ended\")\n);\nexport const ERROR_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ErrorEvent>(\"error\")\n);\nexport const FOCUS_EVENT = (\n  /*#__PURE__*/createNativeEventSource<FocusEvent>(\"focus\")\n);\nexport const GOT_POINTER_CAPTURE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"gotpointercapture\")\n);\nexport const BEFORE_INPUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"beforeinput\")\n);\nexport const INPUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"input\")\n);\nexport const INVALID_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"invalid\")\n);\nexport const KEY_DOWN_EVENT = (\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keydown\")\n);\nexport const KEY_PRESS_EVENT = (\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keypress\")\n);\nexport const KEY_UP_EVENT = (\n  /*#__PURE__*/createNativeEventSource<KeyboardEvent>(\"keyup\")\n);\nexport const LOAD_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"load\")\n);\nexport const LOADED_DATA_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadeddata\")\n);\nexport const LOADED_METADATA_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadedmetadata\")\n);\nexport const LOAD_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"loadstart\")\n);\nexport const LOST_POINTER_CAPTURE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"lostpointercapture\")\n);\nexport const MOUSE_DOWN_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mousedown\")\n);\nexport const MOUSE_OUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseout\")\n);\nexport const MOUSE_OVER_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseover\")\n);\nexport const MOUSE_UP_EVENT = (\n  /*#__PURE__*/createNativeEventSource<MouseEvent>(\"mouseup\")\n);\nexport const PASTE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ClipboardEvent>(\"paste\")\n);\nexport const PAUSE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"pause\")\n);\nexport const PLAY_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"play\")\n);\nexport const PLAYING_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"playing\")\n);\nexport const POINTER_CANCEL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointercancel\")\n);\nexport const POINTER_DOWN_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerdown\")\n);\nexport const POINTER_OUT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerout\")\n);\nexport const POINTER_OVER_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerover\")\n);\nexport const POINTER_UP_EVENT = (\n  /*#__PURE__*/createNativeEventSource<PointerEvent>(\"pointerup\")\n);\nexport const PROGRESS_EVENT = (\n  /*#__PURE__*/createNativeEventSource<ProgressEvent>(\"progress\")\n);\nexport const RATE_CHANGE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"ratechange\")\n);\nexport const RESET_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"reset\")\n);\nexport const SCROLL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"scroll\")\n);\nexport const SEEKED_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"seeked\")\n);\nexport const SEEKING_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"seeking\")\n);\nexport const SELECT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<UIEvent>(\"select\")\n);\nexport const SELECT_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"selectstart\")\n);\nexport const STALLED_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"stalled\")\n);\nexport const SUBMIT_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"submit\")\n);\nexport const SUSPEND_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"suspend\")\n);\nexport const TIME_UPDATE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"timeupdate\")\n);\nexport const TOUCH_CANCEL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchcancel\")\n);\nexport const TOUCH_END_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchend\")\n);\nexport const TOUCH_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchstart\")\n);\nexport const TRANSITION_CANCEL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitioncancel\")\n);\nexport const TRANSITION_END_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionend\")\n);\nexport const TRANSITION_RUN_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionrun\")\n);\nexport const TRANSITION_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TransitionEvent>(\"transitionstart\")\n);\nexport const UNLOAD_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"unload\")\n);\nexport const VOLUME_CHANGE_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"volumechange\")\n);\nexport const WAITING_EVENT = (\n  /*#__PURE__*/createNativeEventSource<Event>(\"waiting\")\n);\nexport const WHEEL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<WheelEvent>(\"wheel\")\n);\n\nexport const ACTIVE_TOUCH_END_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchend\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\nexport const ACTIVE_TOUCH_START_EVENT = (\n  /*#__PURE__*/createNativeEventSource<TouchEvent>(\"touchstart\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\nexport const ACTIVE_WHEEL_EVENT = (\n  /*#__PURE__*/createNativeEventSource<WheelEvent>(\"wheel\", EVENT_CAPTURE_ACTIVE_OPTIONS)\n);\n\n/**\n * Helper function that creates native event handler factories.\n *\n * @param s Native event source.\n * @returns Native event handler factory.\n */\nexport function nativeEventHandlerFactory(s: {}):\n  (h: NativeEventHandler<any>, capture?: boolean) => EventHandlerNode<any> {\n  const bubbleDescriptor = { s, h: dispatchNativeEvent, f: 0 };\n  const captureDescriptor = { s, h: dispatchNativeEvent, f: EventHandlerFlags.Capture };\n  return (h, capture) => ({\n    d: capture === true ? captureDescriptor : bubbleDescriptor,\n    h,\n  });\n}\n\nexport const onAbort: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ABORT_EVENT)\n  );\nexport const onActivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ACTIVATE_EVENT)\n  );\nexport const onAriaRequest: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ARIA_REQUEST_EVENT)\n  );\nexport const onBeforeActivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_ACTIVATE_EVENT)\n  );\nexport const onBeforeCopy: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_COPY_EVENT)\n  );\nexport const onBeforeCut: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_CUT_EVENT)\n  );\nexport const onBeforeDeactivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_DEACTIVATE_EVENT)\n  );\nexport const onBeforePaste: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_PASTE_EVENT)\n  );\nexport const onBlur: <P>(\n  handler: NativeEventHandler<FocusEvent>,\n  capture?: boolean,\n) => EventHandlerNode<FocusEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BLUR_EVENT)\n  );\nexport const onCanPlay: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CAN_PLAY_EVENT)\n  );\nexport const onCanPlaythrough: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CAN_PLAYTHROUGH_EVENT)\n  );\nexport const onChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CHANGE_EVENT)\n  );\nexport const onClick: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CLICK_EVENT)\n  );\nexport const onContextMenu: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CONTEXT_MENU_EVENT)\n  );\nexport const onCopy: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(COPY_EVENT)\n  );\nexport const onCueChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CUE_CHANGE_EVENT)\n  );\nexport const onCut: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(CUT_EVENT)\n  );\nexport const onDoubleClick: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DOUBLE_CLICK_EVENT)\n  );\nexport const onDeactivate: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DEACTIVATE_EVENT)\n  );\nexport const onDrag: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_EVENT)\n  );\nexport const onDragEnd: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_END_EVENT)\n  );\nexport const onDragEnter: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_ENTER_EVENT)\n  );\nexport const onDragLeave: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_LEAVE_EVENT)\n  );\nexport const onDragOver: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_OVER_EVENT)\n  );\nexport const onDragStart: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DRAG_START_EVENT)\n  );\nexport const onDrop: <P>(\n  handler: NativeEventHandler<DragEvent>,\n  capture?: boolean,\n) => EventHandlerNode<DragEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DROP_EVENT)\n  );\nexport const onDurationChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(DURATION_CHANGE_EVENT)\n  );\nexport const onEmptied: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(EMPTIED_EVENT)\n  );\nexport const onEncrypted: <P>(\n  handler: NativeEventHandler<MediaEncryptedEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MediaEncryptedEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ENCRYPTED_EVENT)\n  );\nexport const onEnded: <P>(\n  handler: NativeEventHandler<MediaStreamErrorEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MediaStreamErrorEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ENDED_EVENT)\n  );\nexport const onError: <P>(\n  handler: NativeEventHandler<ErrorEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ErrorEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ERROR_EVENT)\n  );\nexport const onFocus: <P>(\n  handler: NativeEventHandler<FocusEvent>,\n  capture?: boolean,\n) => EventHandlerNode<FocusEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(FOCUS_EVENT)\n  );\nexport const onGotPointerCapture: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(GOT_POINTER_CAPTURE_EVENT)\n  );\nexport const onBeforeInput: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(BEFORE_INPUT_EVENT)\n  );\nexport const onInput: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(INPUT_EVENT)\n  );\nexport const onInvalid: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(INVALID_EVENT)\n  );\nexport const onKeyDown: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(KEY_DOWN_EVENT)\n  );\nexport const onKeyPress: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(KEY_PRESS_EVENT)\n  );\nexport const onKeyUp: <P>(\n  handler: NativeEventHandler<KeyboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<KeyboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(KEY_UP_EVENT)\n  );\nexport const onLoad: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(LOAD_EVENT)\n  );\nexport const onLoadedData: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(LOADED_DATA_EVENT)\n  );\nexport const onLoadedMetadata: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(LOADED_METADATA_EVENT)\n  );\nexport const onLoadStart: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(LOAD_START_EVENT)\n  );\nexport const onLostPointerCapture: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(LOST_POINTER_CAPTURE_EVENT)\n  );\nexport const onMouseDown: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(MOUSE_DOWN_EVENT)\n  );\nexport const onMouseOut: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(MOUSE_OUT_EVENT)\n  );\nexport const onMouseOver: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(MOUSE_OVER_EVENT)\n  );\nexport const onMouseUp: <P>(\n  handler: NativeEventHandler<MouseEvent>,\n  capture?: boolean,\n) => EventHandlerNode<MouseEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(MOUSE_UP_EVENT)\n  );\nexport const onPaste: <P>(\n  handler: NativeEventHandler<ClipboardEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ClipboardEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(PASTE_EVENT)\n  );\nexport const onPause: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(PAUSE_EVENT)\n  );\nexport const onPlay: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(PLAY_EVENT)\n  );\nexport const onPlaying: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(PLAYING_EVENT)\n  );\nexport const onPointerCancel: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(POINTER_CANCEL_EVENT)\n  );\nexport const onPointerDown: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(POINTER_DOWN_EVENT)\n  );\nexport const onPointerOut: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(POINTER_OUT_EVENT)\n  );\nexport const onPointerOver: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(POINTER_OVER_EVENT)\n  );\nexport const onPointerUp: <P>(\n  handler: NativeEventHandler<PointerEvent>,\n  capture?: boolean,\n) => EventHandlerNode<PointerEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(POINTER_UP_EVENT)\n  );\nexport const onProgress: <P>(\n  handler: NativeEventHandler<ProgressEvent>,\n  capture?: boolean,\n) => EventHandlerNode<ProgressEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(PROGRESS_EVENT)\n  );\nexport const onRateChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(RATE_CHANGE_EVENT)\n  );\nexport const onReset: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(RESET_EVENT)\n  );\nexport const onScroll: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SCROLL_EVENT)\n  );\nexport const onSeeked: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SEEKED_EVENT)\n  );\nexport const onSeeking: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SEEKING_EVENT)\n  );\nexport const onSelect: <P>(\n  handler: NativeEventHandler<UIEvent>,\n  capture?: boolean,\n) => EventHandlerNode<UIEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SELECT_EVENT)\n  );\nexport const onSelectStart: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SELECT_START_EVENT)\n  );\nexport const onStalled: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(STALLED_EVENT)\n  );\nexport const onSubmit: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SUBMIT_EVENT)\n  );\nexport const onSuspend: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(SUSPEND_EVENT)\n  );\nexport const onTimeUpdate: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TIME_UPDATE_EVENT)\n  );\nexport const onTouchCancel: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TOUCH_CANCEL_EVENT)\n  );\nexport const onTouchEnd: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TOUCH_END_EVENT)\n  );\nexport const onTouchStart: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TOUCH_START_EVENT)\n  );\nexport const onTransitionCancel: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_CANCEL_EVENT)\n  );\nexport const onTransitionEnd: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_END_EVENT)\n  );\nexport const onTransitionRun: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_RUN_EVENT)\n  );\nexport const onTransitionStart: <P>(\n  handler: NativeEventHandler<TransitionEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TransitionEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(TRANSITION_START_EVENT)\n  );\nexport const onUnload: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(UNLOAD_EVENT)\n  );\nexport const onVolumeChange: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(VOLUME_CHANGE_EVENT)\n  );\nexport const onWaiting: <P>(\n  handler: NativeEventHandler<Event>,\n  capture?: boolean,\n) => EventHandlerNode<Event> = (\n  /*#__PURE__*/nativeEventHandlerFactory(WAITING_EVENT)\n  );\nexport const onWheel: <P>(\n  handler: NativeEventHandler<WheelEvent>,\n  capture?: boolean,\n) => EventHandlerNode<WheelEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(WHEEL_EVENT)\n  );\n\nexport const onActiveTouchEnd: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_TOUCH_END_EVENT)\n  );\nexport const onActiveTouchStart: <P>(\n  handler: NativeEventHandler<TouchEvent>,\n  capture?: boolean,\n) => EventHandlerNode<TouchEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_TOUCH_START_EVENT)\n  );\nexport const onActiveWheel: <P>(\n  handler: NativeEventHandler<WheelEvent>,\n  capture?: boolean,\n) => EventHandlerNode<WheelEvent> = (\n  /*#__PURE__*/nativeEventHandlerFactory(ACTIVE_WHEEL_EVENT)\n  );\n","import { NodeFlags } from \"../vdom/node_flags\";\nimport { OpState } from \"../vdom/state\";\nimport { findRoot } from \"../vdom/root\";\nimport { EventsOp } from \"../vdom/operations\";\nimport { EventHandlerFlags, EventHandler, EventHandlerNode } from \"./event_handler\";\n\nexport const enum DispatchEvent {\n  Propagate = 1\n}\n\n/**\n * DispatchTarget.\n */\nexport interface DispatchTarget<H = any> {\n  /**\n   * Target.\n   */\n  readonly t: any;\n  /**\n   * Matched Event Handlers.\n   */\n  readonly h: EventHandlerNode<H>;\n}\n\n/**\n * collectDispatchTargets traverses the DOM tree from the `target` Element to the root element, then goes down\n * through Virtual DOM tree and collects matching Event Handlers.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching event source.\n * @returns Dispatch targets.\n */\nfunction collectDispatchTargets(target: Element, match: {}): DispatchTarget[] {\n  const targets = [] as DispatchTarget[];\n  const root = findRoot((r) => r.container!.contains(target));\n  if (root) {\n    const container = root.container;\n    if (container !== target) {\n      visitUp(targets, match, target, container!, root.state);\n    }\n  }\n\n  return targets;\n}\n\nfunction visitUp(\n  result: DispatchTarget[],\n  match: {},\n  element: Element,\n  root: Element,\n  stateNode: OpState | null,\n): OpState | null {\n  const parentElement = element.parentNode! as Element;\n  return (parentElement === root || (stateNode = visitUp(result, match, parentElement, root, stateNode)) !== null) ?\n    visitDown(result, match, element, stateNode!) :\n    null;\n}\n\nfunction visitDown(result: DispatchTarget[], match: {}, element: Element, stateNode: OpState | null): OpState | null {\n  if (stateNode !== null) {\n    const { f, c } = stateNode;\n    let r;\n    if ((f & NodeFlags.Element) !== 0) {\n      if (stateNode.s === element) {\n        return stateNode;\n      }\n      if (c !== null) {\n        return visitDown(result, match, element, c as OpState);\n      }\n    } else if ((f & (NodeFlags.Events | NodeFlags.Component | NodeFlags.Context)) !== 0) {\n      if ((r = visitDown(result, match, element, stateNode.c as OpState)) !== null) {\n        if ((f & NodeFlags.Events) !== 0) {\n          collectDispatchTargetsFromEventsOpState(result, stateNode, (stateNode.o as EventsOp).v, match);\n        }\n        return r;\n      }\n    } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (let i = 0; i < (c as OpState[]).length; i++) {\n        if ((r = visitDown(result, match, element, (c as OpState[])[i])) !== null) {\n          return r;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * collectDispatchTargetsFromEventsOpState accumulates matching Event Handlers in `result` array from the `target`\n * operation state.\n *\n * @param result Accumulated Dispatch Targets.\n * @param t Target operation state.\n * @param h Event handler.\n * @param match Matching function.\n */\nfunction collectDispatchTargetsFromEventsOpState(\n  result: DispatchTarget[],\n  t: OpState,\n  h: EventHandler,\n  match: {},\n): void {\n  if (h !== null) {\n    if (h instanceof Array) {\n      let i = h.length;\n      while (--i >= 0) {\n        collectDispatchTargetsFromEventsOpState(result, t, h[i], match);\n      }\n    } else {\n      const source = h.d.s;\n      if (\n        (typeof source === \"function\" && source(match) === true) ||\n        (source === match)\n      ) {\n        result.push({ t, h });\n      }\n    }\n  }\n}\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param src Event source.\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch handler.\n */\nexport function dispatchEvent<E>(\n  src: {},\n  target: Element,\n  event: E,\n): void {\n  const targets = collectDispatchTargets(target, src);\n  let i = targets.length;\n  let currentTarget;\n  let descriptor;\n\n  if (i > 0) {\n    // capture phase\n    while (--i >= 0) {\n      currentTarget = targets[i];\n      descriptor = currentTarget.h.d;\n      if ((descriptor.f & EventHandlerFlags.Capture) !== 0) {\n        if (descriptor.h(event, currentTarget, src) !== DispatchEvent.Propagate) {\n          return;\n        }\n      }\n    }\n\n    // bubble phase\n    while (++i < targets.length) {\n      currentTarget = targets[i];\n      descriptor = currentTarget.h.d;\n      if ((descriptor.f & EventHandlerFlags.Capture) === 0) {\n        if (descriptor.h(event, currentTarget, src) !== DispatchEvent.Propagate) {\n          return;\n        }\n      }\n    }\n  }\n}\n","/**\n * Shortcut for an `undefined` value.\n */\nexport const _ = void 0;\n","import { scheduleLayoutEffect } from \"../scheduler\";\n\n/**\n * Attribute directives are used to extend reconciliation and `renderToString()` algorithms.\n *\n * When DOM element attributes are updated during reconciliation, custom update function `u()` will be invoked with the\n * DOM element, attribute key, previous and next values.\n *\n * When DOM element is rendered to string, custom render to string function `s()` will be invoked with attribute key\n * and its value `v`.\n *\n * @typeparam T Value type.\n */\nexport interface AttributeDirective<T> {\n  /**\n   * Value.\n   */\n  readonly v: T | undefined;\n  /**\n   * Update function.\n   *\n   * @param element Target element.\n   * @param key Attribute key.\n   * @param prev Previous value.\n   * @param next Next value.\n   */\n  u(element: Element, key: string, prev: T | undefined, next: T | undefined): void;\n}\n\n/**\n * PROPERTY function creates an {@link AttributeDirective} that assigns a property to a property name derived from the\n * `key` of the attribute.\n *\n * When rendered to string, it will be ignored.\n *\n * @example\n *\n *   const e = div(\"\", { _customProperty: PROPERTY(\"value\") });\n *\n * @typeparam Property value type.\n * @param v Property value.\n * @returns {@link AttributeDirective}\n */\nexport const PROPERTY = <T>(v: T): AttributeDirective<T> => ({ v, u: updateProperty });\n\n/**\n * Update function for an {@link AttributeDirective} created with a {@link PROPERTY} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateProperty(element: Element, key: string, prev: any, next: any): void {\n  if (prev !== next && next !== void 0) {\n    (element as any)[key] = next!;\n  }\n}\n\n/**\n * UNSAFE_HTML function creates a {@link AttributeDirective} that assigns an `innerHTML` property to an Element.\n *\n * When rendered to string, it will emit its value as inner HTML without any escaping.\n *\n * @example\n *\n *   const e = div(\"\", { unsafeHTML: UNSAFE_HTML(\"<span></span>\") });\n *\n * @param v innerHTML value.\n * @returns {@link AttributeDirective}\n */\nexport const UNSAFE_HTML = (v: string): AttributeDirective<string> => ({ v, u: updateUnsafeHTML });\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link UNSAFE_HTML} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateUnsafeHTML(element: Element, key: string, prev: string | undefined, next: string | undefined) {\n  if (prev !== next) {\n    if (next === void 0) {\n      element.innerHTML = \"\";\n    } else if (prev !== void 0 || next !== \"\") {\n      element.innerHTML = next!;\n    }\n  }\n}\n\n/**\n * EVENT function creates an {@link AttributeDirective} that assigns a native event handler derived from the `key`\n * attribute to an Element.\n *\n * When rendered to string, it will be ignored.\n *\n * @example\n *\n *   const e = div(\"\", { click: EVENT((ev) => { console.log(ev) }); });\n *\n * @param v Event handler.\n * @returns {@link AttributeDirective}\n */\nexport const EVENT = (v: (ev: Event) => void): AttributeDirective<(ev: Event) => void> => ({ v, u: updateEvent });\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link EVENT} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateEvent(\n  element: Element,\n  key: string,\n  prev: ((ev: Event) => void) | undefined,\n  next: ((ev: Event) => void) | undefined,\n) {\n  if (prev !== next) {\n    if (prev !== void 0) {\n      element.removeEventListener(key, prev);\n    }\n    if (next !== void 0) {\n      element.addEventListener(key, next);\n    }\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link AUTOFOCUS} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateAutofocus(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0 && next) {\n    scheduleLayoutEffect(() => { (element as HTMLElement).focus(); });\n  }\n}\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_FALSE: AttributeDirective<boolean> = { v: false, u: updateAutofocus };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_TRUE: AttributeDirective<boolean> = { v: true, u: updateAutofocus };\n\n/**\n * AUTOFOCUS function creates a {@link AttributeDirective} that sets autofocus on an element.\n *\n * When rendered to string, it will emit `autofocus` attribute.\n *\n * @example\n *\n *   const e = input(\"\", { autofocus: AUTOFOCUS(true) });\n *\n * @param v Autofocus state.\n * @returns {@link AttributeDirective}\n */\nexport const AUTOFOCUS = (v: boolean): AttributeDirective<boolean> => (v ? AUTOFOCUS_TRUE : AUTOFOCUS_FALSE);\n","import {\n  HTMLAnchorElementAttrs, HTMLElementAttrs, HTMLAreaElementAttrs, HTMLAudioElementAttrs,\n  HTMLBaseElementAttrs, HTMLBodyElementAttrs, HTMLBRElementAttrs, HTMLButtonElementAttrs,\n  HTMLCanvasElementAttrs, HTMLQuoteElementAttrs, HTMLTableCaptionElementAttrs, HTMLTableColElementAttrs,\n  HTMLModElementAttrs, HTMLDivElementAttrs, HTMLDListElementAttrs, HTMLFieldSetElementAttrs, HTMLFormElementAttrs,\n  HTMLHeadElementAttrs, HTMLHeadingElementAttrs, HTMLHRElementAttrs, HTMLHtmlElementAttrs, HTMLIFrameElementAttrs,\n  HTMLImageElementAttrs, HTMLInputElementAttrs, HTMLLabelElementAttrs, HTMLLegendElementAttrs, HTMLLIElementAttrs,\n  HTMLLinkElementAttrs, HTMLMapElementAttrs, HTMLMenuElementAttrs, HTMLMetaElementAttrs, HTMLMeterElementAttrs,\n  HTMLOListElementAttrs, HTMLOptGroupElementAttrs, HTMLOptionElementAttrs, HTMLParagraphElementAttrs,\n  HTMLPictureElementAttrs, HTMLPreElementAttrs, HTMLProgressElementAttrs, HTMLScriptElementAttrs,\n  HTMLSelectElementAttrs, HTMLSourceElementAttrs, HTMLSpanElementAttrs, HTMLStyleElementAttrs,\n  HTMLTableDataCellElementAttrs, HTMLTableElementAttrs, HTMLTableHeaderCellElementAttrs, HTMLTableRowElementAttrs,\n  HTMLTableSectionElementAttrs, HTMLTemplateElementAttrs, HTMLTextAreaElementAttrs, HTMLTitleElementAttrs,\n  HTMLTrackElementAttrs, HTMLUListElementAttrs, HTMLVideoElementAttrs,\n\n  AttributeDirective, htmlElementFactory,\n} from \"ivi\";\n\n/**\n * {@link AttributeDirective} with `\"\"` value and {@link updateValue} sync function.\n */\nconst VALUE_EMPTY: AttributeDirective<string> = { v: \"\", u: updateValue };\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateChecked} sync function.\n */\nconst CHECKED_FALSE: AttributeDirective<boolean> = { v: false, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateChecked} sync function.\n */\nconst CHECKED_TRUE: AttributeDirective<boolean> = { v: true, u: updateChecked };\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateValue(\n  element: Element,\n  key: string,\n  prev: string | undefined,\n  next: string | undefined,\n) {\n  if (prev === void 0) {\n    if (next !== \"\") {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next!;\n    }\n  } else if (next !== void 0 && ((element as HTMLInputElement | HTMLTextAreaElement).value !== next)) {\n    (element as HTMLInputElement | HTMLTextAreaElement).value = next;\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link CHECKED} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateChecked(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0) {\n    if (next) {\n      (element as HTMLInputElement).checked = next;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement).checked !== next) {\n      (element as HTMLInputElement).checked = next!;\n    }\n  }\n}\n\n/**\n * VALUE function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { value: VALUE(\"value\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const VALUE = (v: string): AttributeDirective<string> => (\n  v === \"\" ? VALUE_EMPTY : { v, u: updateValue }\n);\n\n/**\n * CONTENT function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLTextAreaElement.\n *\n * @example\n *\n *   const e = textarea(\"\", { content: CONTENT(\"content\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const CONTENT = (\n  VALUE\n);\n\n/**\n * CHECKED function creates a {@link AttributeDirective} that assigns a `checked` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { checked: CHECKED(true) });\n *\n * @param v Checked value.\n * @returns {@link AttributeDirective}\n */\nexport const CHECKED = (v: boolean): AttributeDirective<boolean> => (\n  v ? CHECKED_TRUE : CHECKED_FALSE\n);\n\n/* tslint:disable:max-line-length */\n/**\n * Creates OpNode HTML element <a>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <a>\n */\nexport const a = /*#__PURE__*/htmlElementFactory<HTMLAnchorElementAttrs, HTMLAnchorElement>(\"a\");\n\n/**\n * Creates OpNode HTML element <abbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <abbr>\n */\nexport const abbr = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"abbr\");\n\n/**\n * Creates OpNode HTML element <address>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <address>\n */\nexport const address = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"address\");\n\n/**\n * Creates OpNode HTML element <article>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <article>\n */\nexport const article = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"article\");\n\n/**\n * Creates OpNode HTML element <aside>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <aside>\n */\nexport const aside = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"aside\");\n\n/**\n * Creates OpNode HTML element <b>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <b>\n */\nexport const b = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"b\");\n\n/**\n * Creates OpNode HTML element <base>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <base>\n */\nexport const base = /*#__PURE__*/htmlElementFactory<HTMLBaseElementAttrs, HTMLBaseElement>(\"base\");\n\n/**\n * Creates OpNode HTML element <bdo>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <bdo>\n */\nexport const bdo = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"bdo\");\n\n/**\n * Creates OpNode HTML element <blockquote>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <blockquote>\n */\nexport const blockquote = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"blockquote\");\n\n/**\n * Creates OpNode HTML element <body>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <body>\n */\nexport const body = /*#__PURE__*/htmlElementFactory<HTMLBodyElementAttrs, HTMLBodyElement>(\"body\");\n\n/**\n * Creates OpNode HTML element <br>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <br>\n */\nexport const br = /*#__PURE__*/htmlElementFactory<HTMLBRElementAttrs, HTMLBRElement>(\"br\");\n\n/**\n * Creates OpNode HTML element <button>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <button>\n */\nexport const button = /*#__PURE__*/htmlElementFactory<HTMLButtonElementAttrs, HTMLButtonElement>(\"button\");\n\n/**\n * Creates OpNode HTML element <canvas>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <canvas>\n */\nexport const canvas = /*#__PURE__*/htmlElementFactory<HTMLCanvasElementAttrs, HTMLCanvasElement>(\"canvas\");\n\n/**\n * Creates OpNode HTML element <caption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <caption>\n */\nexport const caption = /*#__PURE__*/htmlElementFactory<HTMLTableCaptionElementAttrs, HTMLTableCaptionElement>(\"caption\");\n\n/**\n * Creates OpNode HTML element <cite>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <cite>\n */\nexport const cite = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"cite\");\n\n/**\n * Creates OpNode HTML element <code>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <code>\n */\nexport const code = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"code\");\n\n/**\n * Creates OpNode HTML element <col>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <col>\n */\nexport const col = /*#__PURE__*/htmlElementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"col\");\n\n/**\n * Creates OpNode HTML element <colgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <colgroup>\n */\nexport const colgroup = /*#__PURE__*/htmlElementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"colgroup\");\n\n/**\n * Creates OpNode HTML element <del>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <del>\n */\nexport const del = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"del\");\n\n/**\n * Creates OpNode HTML element <dfn>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dfn>\n */\nexport const dfn = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dfn\");\n\n/**\n * Creates OpNode HTML element <div>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <div>\n */\nexport const div = /*#__PURE__*/htmlElementFactory<HTMLDivElementAttrs, HTMLDivElement>(\"div\");\n\n/**\n * Creates OpNode HTML element <dd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dd>\n */\nexport const dd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dd\");\n\n/**\n * Creates OpNode HTML element <dl>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dl>\n */\nexport const dl = /*#__PURE__*/htmlElementFactory<HTMLDListElementAttrs, HTMLDListElement>(\"dl\");\n\n/**\n * Creates OpNode HTML element <dt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dt>\n */\nexport const dt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dt\");\n\n/**\n * Creates OpNode HTML element <em>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <em>\n */\nexport const em = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"em\");\n\n/**\n * Creates OpNode HTML element <fieldset>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <fieldset>\n */\nexport const fieldset = /*#__PURE__*/htmlElementFactory<HTMLFieldSetElementAttrs, HTMLFieldSetElement>(\"fieldset\");\n\n/**\n * Creates OpNode HTML element <figcaption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figcaption>\n */\nexport const figcaption = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figcaption\");\n\n/**\n * Creates OpNode HTML element <figure>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figure>\n */\nexport const figure = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figure\");\n\n/**\n * Creates OpNode HTML element <footer>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <footer>\n */\nexport const footer = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"footer\");\n\n/**\n * Creates OpNode HTML element <form>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <form>\n */\nexport const form = /*#__PURE__*/htmlElementFactory<HTMLFormElementAttrs, HTMLFormElement>(\"form\");\n\n/**\n * Creates OpNode HTML element <h1>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h1>\n */\nexport const h1 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h1\");\n\n/**\n * Creates OpNode HTML element <h2>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h2>\n */\nexport const h2 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h2\");\n\n/**\n * Creates OpNode HTML element <h3>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h3>\n */\nexport const h3 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h3\");\n\n/**\n * Creates OpNode HTML element <h4>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h4>\n */\nexport const h4 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h4\");\n\n/**\n * Creates OpNode HTML element <h5>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h5>\n */\nexport const h5 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h5\");\n\n/**\n * Creates OpNode HTML element <h6>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h6>\n */\nexport const h6 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h6\");\n\n/**\n * Creates OpNode HTML element <head>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <head>\n */\nexport const head = /*#__PURE__*/htmlElementFactory<HTMLHeadElementAttrs, HTMLHeadElement>(\"head\");\n\n/**\n * Creates OpNode HTML element <header>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <header>\n */\nexport const header = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"header\");\n\n/**\n * Creates OpNode HTML element <hgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hgroup>\n */\nexport const hgroup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"hgroup\");\n\n/**\n * Creates OpNode HTML element <hr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hr>\n */\nexport const hr = /*#__PURE__*/htmlElementFactory<HTMLHRElementAttrs, HTMLHRElement>(\"hr\");\n\n/**\n * Creates OpNode HTML element <html>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <html>\n */\nexport const html = /*#__PURE__*/htmlElementFactory<HTMLHtmlElementAttrs, HTMLHtmlElement>(\"html\");\n\n/**\n * Creates OpNode HTML element <i>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <i>\n */\nexport const i = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"i\");\n\n/**\n * Creates OpNode HTML element <iframe>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <iframe>\n */\nexport const iframe = /*#__PURE__*/htmlElementFactory<HTMLIFrameElementAttrs, HTMLIFrameElement>(\"iframe\");\n\n/**\n * Creates OpNode HTML element <img>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <img>\n */\nexport const img = /*#__PURE__*/htmlElementFactory<HTMLImageElementAttrs, HTMLImageElement>(\"img\");\n\n/**\n * Creates OpNode HTML element <area>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <area>\n */\nexport const area = /*#__PURE__*/htmlElementFactory<HTMLAreaElementAttrs, HTMLAreaElement>(\"area\");\n\n/**\n * Creates OpNode HTML element <map>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <map>\n */\nexport const map = /*#__PURE__*/htmlElementFactory<HTMLMapElementAttrs, HTMLMapElement>(\"map\");\n\n/**\n * Creates OpNode HTML element <ins>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ins>\n */\nexport const ins = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"ins\");\n\n/**\n * Creates OpNode HTML element <kbd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <kbd>\n */\nexport const kbd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"kbd\");\n\n/**\n * Creates OpNode HTML element <label>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <label>\n */\nexport const label = /*#__PURE__*/htmlElementFactory<HTMLLabelElementAttrs, HTMLLabelElement>(\"label\");\n\n/**\n * Creates OpNode HTML element <legend>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <legend>\n */\nexport const legend = /*#__PURE__*/htmlElementFactory<HTMLLegendElementAttrs, HTMLLegendElement>(\"legend\");\n\n/**\n * Creates OpNode HTML element <li>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <li>\n */\nexport const li = /*#__PURE__*/htmlElementFactory<HTMLLIElementAttrs, HTMLLIElement>(\"li\");\n\n/**\n * Creates OpNode HTML element <link>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <link>\n */\nexport const link = /*#__PURE__*/htmlElementFactory<HTMLLinkElementAttrs, HTMLLinkElement>(\"link\");\n\n/**\n * Creates OpNode HTML element <main>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <main>\n */\nexport const main = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"main\");\n\n/**\n * Creates OpNode HTML element <mark>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <mark>\n */\nexport const mark = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"mark\");\n\n/**\n * Creates OpNode HTML element <menu>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <menu>\n */\nexport const menu = /*#__PURE__*/htmlElementFactory<HTMLMenuElementAttrs, HTMLMenuElement>(\"menu\");\n\n/**\n * Creates OpNode HTML element <meta>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meta>\n */\nexport const meta = /*#__PURE__*/htmlElementFactory<HTMLMetaElementAttrs, HTMLMetaElement>(\"meta\");\n\n/**\n * Creates OpNode HTML element <meter>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meter>\n */\nexport const meter = /*#__PURE__*/htmlElementFactory<HTMLMeterElementAttrs, HTMLMeterElement>(\"meter\");\n\n/**\n * Creates OpNode HTML element <nav>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <nav>\n */\nexport const nav = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"nav\");\n\n/**\n * Creates OpNode HTML element <noscript>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <noscript>\n */\nexport const noscript = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"noscript\");\n\n/**\n * Creates OpNode HTML element <ol>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ol>\n */\nexport const ol = /*#__PURE__*/htmlElementFactory<HTMLOListElementAttrs, HTMLOListElement>(\"ol\");\n\n/**\n * Creates OpNode HTML element <optgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <optgroup>\n */\nexport const optgroup = /*#__PURE__*/htmlElementFactory<HTMLOptGroupElementAttrs, HTMLOptGroupElement>(\"optgroup\");\n\n/**\n * Creates OpNode HTML element <option>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <option>\n */\nexport const option = /*#__PURE__*/htmlElementFactory<HTMLOptionElementAttrs, HTMLOptionElement>(\"option\");\n\n/**\n * Creates OpNode HTML element <p>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <p>\n */\nexport const p = /*#__PURE__*/htmlElementFactory<HTMLParagraphElementAttrs, HTMLParagraphElement>(\"p\");\n\n/**\n * Creates OpNode HTML element <picture>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <picture>\n */\nexport const picture = /*#__PURE__*/htmlElementFactory<HTMLPictureElementAttrs, HTMLPictureElement>(\"picture\");\n\n/**\n * Creates OpNode HTML element <pre>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <pre>\n */\nexport const pre = /*#__PURE__*/htmlElementFactory<HTMLPreElementAttrs, HTMLPreElement>(\"pre\");\n\n/**\n * Creates OpNode HTML element <progress>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <progress>\n */\nexport const progress = /*#__PURE__*/htmlElementFactory<HTMLProgressElementAttrs, HTMLProgressElement>(\"progress\");\n\n/**\n * Creates OpNode HTML element <q>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <q>\n */\nexport const q = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"q\");\n\n/**\n * Creates OpNode HTML element <rt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <rt>\n */\nexport const rt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"rt\");\n\n/**\n * Creates OpNode HTML element <ruby>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ruby>\n */\nexport const ruby = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"ruby\");\n\n/**\n * Creates OpNode HTML element <s>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <s>\n */\nexport const s = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"s\");\n\n/**\n * Creates OpNode HTML element <samp>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <samp>\n */\nexport const samp = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"samp\");\n\n/**\n * Creates OpNode HTML element <script>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <script>\n */\nexport const script = /*#__PURE__*/htmlElementFactory<HTMLScriptElementAttrs, HTMLScriptElement>(\"script\");\n\n/**\n * Creates OpNode HTML element <section>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <section>\n */\nexport const section = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"section\");\n\n/**\n * Creates OpNode HTML element <select>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <select>\n */\nexport const select = /*#__PURE__*/htmlElementFactory<HTMLSelectElementAttrs, HTMLSelectElement>(\"select\");\n\n/**\n * Creates OpNode HTML element <source>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <source>\n */\nexport const source = /*#__PURE__*/htmlElementFactory<HTMLSourceElementAttrs, HTMLSourceElement>(\"source\");\n\n/**\n * Creates OpNode HTML element <span>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <span>\n */\nexport const span = /*#__PURE__*/htmlElementFactory<HTMLSpanElementAttrs, HTMLSpanElement>(\"span\");\n\n/**\n * Creates OpNode HTML element <strong>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <strong>\n */\nexport const strong = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"strong\");\n\n/**\n * Creates OpNode HTML element <style>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <style>\n */\nexport const style = /*#__PURE__*/htmlElementFactory<HTMLStyleElementAttrs, HTMLStyleElement>(\"style\");\n\n/**\n * Creates OpNode HTML element <sub>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sub>\n */\nexport const sub = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sub\");\n\n/**\n * Creates OpNode HTML element <sup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sup>\n */\nexport const sup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sup\");\n\n/**\n * Creates OpNode HTML element <table>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <table>\n */\nexport const table = /*#__PURE__*/htmlElementFactory<HTMLTableElementAttrs, HTMLTableElement>(\"table\");\n\n/**\n * Creates OpNode HTML element <tbody>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tbody>\n */\nexport const tbody = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tbody\");\n\n/**\n * Creates OpNode HTML element <td>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <td>\n */\nexport const td = /*#__PURE__*/htmlElementFactory<HTMLTableDataCellElementAttrs, HTMLTableDataCellElement>(\"td\");\n\n/**\n * Creates OpNode HTML element <template>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <template>\n */\nexport const template = /*#__PURE__*/htmlElementFactory<HTMLTemplateElementAttrs, HTMLTemplateElement>(\"template\");\n\n/**\n * Creates OpNode HTML element <tfoot>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tfoot>\n */\nexport const tfoot = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tfoot\");\n\n/**\n * Creates OpNode HTML element <th>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <th>\n */\nexport const th = /*#__PURE__*/htmlElementFactory<HTMLTableHeaderCellElementAttrs, HTMLTableHeaderCellElement>(\"th\");\n\n/**\n * Creates OpNode HTML element <thead>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <thead>\n */\nexport const thead = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"thead\");\n\n/**\n * Creates OpNode HTML element <time>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <time>\n */\nexport const time = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"time\");\n\n/**\n * Creates OpNode HTML element <title>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <title>\n */\nexport const title = /*#__PURE__*/htmlElementFactory<HTMLTitleElementAttrs, HTMLTitleElement>(\"title\");\n\n/**\n * Creates OpNode HTML element <tr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tr>\n */\nexport const tr = /*#__PURE__*/htmlElementFactory<HTMLTableRowElementAttrs, HTMLTableRowElement>(\"tr\");\n\n/**\n * Creates OpNode HTML element <track>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <track>\n */\nexport const track = /*#__PURE__*/htmlElementFactory<HTMLTrackElementAttrs, HTMLTrackElement>(\"track\");\n\n/**\n * Creates OpNode HTML element <u>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <u>\n */\nexport const u = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"u\");\n\n/**\n * Creates OpNode HTML element <ul>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ul>\n */\nexport const ul = /*#__PURE__*/htmlElementFactory<HTMLUListElementAttrs, HTMLUListElement>(\"ul\");\n\n/**\n * Creates OpNode HTML element <wbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <wbr>\n */\nexport const wbr = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"wbr\");\n\n/**\n * Creates OpNode HTML element <textarea>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <textarea>\n */\nexport const textarea = /*#__PURE__*/htmlElementFactory<HTMLTextAreaElementAttrs, HTMLTextAreaElement>(\"textarea\");\n\n/**\n * Creates OpNode HTML element <input>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <input>\n */\nexport const input = /*#__PURE__*/htmlElementFactory<HTMLInputElementAttrs, HTMLInputElement>(\"input\");\n\n/**\n * Creates OpNode HTML element <audio>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <audio>\n */\nexport const audio = /*#__PURE__*/htmlElementFactory<HTMLAudioElementAttrs, HTMLAudioElement>(\"audio\");\n\n/**\n * Creates OpNode HTML element <video>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <video>\n */\nexport const video = /*#__PURE__*/htmlElementFactory<HTMLVideoElementAttrs, HTMLVideoElement>(\"video\");\n","var MonitorMaxSamples = 100;\nvar MonitorSamplesResult = (function () {\n    function MonitorSamplesResult(min, max, mean, last) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.last = last;\n    }\n    return MonitorSamplesResult;\n}());\n/**\n * Profile Samples.\n */\nvar MonitorSamples = (function () {\n    function MonitorSamples(maxSamples) {\n        this.samples = [];\n        this.maxSamples = maxSamples;\n        this._i = -1;\n    }\n    MonitorSamples.prototype.addSample = function (v) {\n        this._i = (this._i + 1) % this.maxSamples;\n        this.samples[this._i] = v;\n    };\n    MonitorSamples.prototype.each = function (fn) {\n        var samples = this.samples;\n        for (var i = 0; i < samples.length; i++) {\n            fn(samples[(this._i + 1 + i) % samples.length], i);\n        }\n    };\n    MonitorSamples.prototype.calc = function () {\n        var samples = this.samples;\n        if (samples.length === 0) {\n            return new MonitorSamplesResult(0, 0, 0, 0);\n        }\n        var min = samples[(this._i + 1) % samples.length];\n        var max = min;\n        var sum = 0;\n        for (var i = 0; i < samples.length; i++) {\n            var k = samples[(this._i + 1 + i) % samples.length];\n            if (k < min) {\n                min = k;\n            }\n            if (k > max) {\n                max = k;\n            }\n            sum += k;\n        }\n        var last = samples[this._i];\n        var mean = sum / samples.length;\n        return new MonitorSamplesResult(min, max, mean, last);\n    };\n    return MonitorSamples;\n}());\n\n/**\n * Basic Counter.\n */\nvar BasicCounter = (function () {\n    function BasicCounter() {\n        this.value = 0;\n        this.onChange = null;\n    }\n    BasicCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return BasicCounter;\n}());\nvar TimestampedValue = (function () {\n    function TimestampedValue(timestamp, value) {\n        this.value = value;\n        this.next = null;\n    }\n    return TimestampedValue;\n}());\n/**\n * Sliding Counter counts how many times `inc` method were called during `interval` period.\n */\nvar SlidingCounter = (function () {\n    function SlidingCounter(interval) {\n        var _this = this;\n        this._dec = function () {\n            var now = performance.now();\n            while (_this._firstTimestamp !== null) {\n                var nextTimestamp = _this._firstTimestamp;\n                if (now >= nextTimestamp.value) {\n                    _this.value -= nextTimestamp.value;\n                    _this._firstTimestamp = _this._firstTimestamp.next;\n                }\n                else {\n                    setTimeout(_this._dec, Math.ceil(nextTimestamp.value - now));\n                    break;\n                }\n            }\n            if (_this._firstTimestamp === null) {\n                _this._lastTimestamp = null;\n            }\n            _this.onChange();\n        };\n        this.interval = interval;\n        this.value = 0;\n        this.onChange = null;\n        this._firstTimestamp = null;\n        this._lastTimestamp = null;\n    }\n    SlidingCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            var timestamp = new TimestampedValue(performance.now() + this.interval, value);\n            if (this._firstTimestamp === null) {\n                this._firstTimestamp = timestamp;\n                setTimeout(this._dec, this.interval);\n            }\n            else {\n                this._lastTimestamp.next = timestamp;\n            }\n            this._lastTimestamp = timestamp;\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return SlidingCounter;\n}());\n\nvar frameTasks = [];\nvar rafId = -1;\n/**\n * Schedule new task that will be executed on the next frame.\n */\nfunction scheduleNextFrameTask(task) {\n    frameTasks.push(task);\n    if (rafId === -1) {\n        requestAnimationFrame(function (t) {\n            rafId = -1;\n            var tasks = frameTasks;\n            frameTasks = [];\n            for (var i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        });\n    }\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MonitorGraphHeight = 30;\nvar MonitorGraphWidth = MonitorMaxSamples;\nvar Widget = (function () {\n    function Widget(name) {\n        var _this = this;\n        this._sync = function () {\n            _this.sync();\n            _this._dirty = false;\n        };\n        this.name = name;\n        this.element = document.createElement(\"div\");\n        this.element.style.cssText = \"padding: 2px;\" +\n            \"background-color: #020;\" +\n            \"font-family: monospace;\" +\n            \"font-size: 12px;\" +\n            \"color: #0f0\";\n        this._dirty = false;\n        this.invalidate();\n    }\n    Widget.prototype.invalidate = function () {\n        if (!this._dirty) {\n            this._dirty = true;\n            scheduleNextFrameTask(this._sync);\n        }\n    };\n    Widget.prototype.sync = function () {\n        throw new Error(\"sync method not implemented\");\n    };\n    return Widget;\n}());\nvar MonitorWidgetFlags;\n(function (MonitorWidgetFlags) {\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMin\"] = 1] = \"HideMin\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMax\"] = 2] = \"HideMax\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMean\"] = 4] = \"HideMean\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideLast\"] = 8] = \"HideLast\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideGraph\"] = 16] = \"HideGraph\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"RoundValues\"] = 32] = \"RoundValues\";\n})(MonitorWidgetFlags || (MonitorWidgetFlags = {}));\nvar MonitorWidget = (function (_super) {\n    __extends(MonitorWidget, _super);\n    function MonitorWidget(name, flags, unitName, samples) {\n        var _this = _super.call(this, name) || this;\n        _this.flags = flags;\n        _this.unitName = unitName;\n        _this.samples = samples;\n        var label = document.createElement(\"div\");\n        label.style.cssText = \"text-align: center\";\n        label.textContent = _this.name;\n        var text = document.createElement(\"div\");\n        if ((flags & MonitorWidgetFlags.HideMin) === 0) {\n            _this.minText = document.createElement(\"div\");\n            text.appendChild(_this.minText);\n        }\n        else {\n            _this.minText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMax) === 0) {\n            _this.maxText = document.createElement(\"div\");\n            text.appendChild(_this.maxText);\n        }\n        else {\n            _this.maxText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMean) === 0) {\n            _this.meanText = document.createElement(\"div\");\n            text.appendChild(_this.meanText);\n        }\n        else {\n            _this.meanText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideLast) === 0) {\n            _this.lastText = document.createElement(\"div\");\n            text.appendChild(_this.lastText);\n        }\n        else {\n            _this.lastText = null;\n        }\n        _this.element.appendChild(label);\n        _this.element.appendChild(text);\n        if ((flags & MonitorWidgetFlags.HideGraph) === 0) {\n            _this.canvas = document.createElement(\"canvas\");\n            _this.canvas.style.cssText = \"display: block; padding: 0; margin: 0\";\n            _this.canvas.width = MonitorGraphWidth;\n            _this.canvas.height = MonitorGraphHeight;\n            _this.ctx = _this.canvas.getContext(\"2d\");\n            _this.element.appendChild(_this.canvas);\n        }\n        else {\n            _this.canvas = null;\n            _this.ctx = null;\n        }\n        return _this;\n    }\n    MonitorWidget.prototype.sync = function () {\n        var _this = this;\n        var result = this.samples.calc();\n        var scale = MonitorGraphHeight / (result.max * 1.2);\n        var min;\n        var max;\n        var mean;\n        var last;\n        if ((this.flags & MonitorWidgetFlags.RoundValues) === 0) {\n            min = result.min.toFixed(2);\n            max = result.max.toFixed(2);\n            mean = result.mean.toFixed(2);\n            last = result.last.toFixed(2);\n        }\n        else {\n            min = Math.round(result.min).toString();\n            max = Math.round(result.max).toString();\n            mean = Math.round(result.mean).toString();\n            last = Math.round(result.last).toString();\n        }\n        if (this.minText !== null) {\n            this.minText.textContent = \"min: \\u00A0\" + min + this.unitName;\n        }\n        if (this.maxText !== null) {\n            this.maxText.textContent = \"max: \\u00A0\" + max + this.unitName;\n        }\n        if (this.meanText !== null) {\n            this.meanText.textContent = \"mean: \" + mean + this.unitName;\n        }\n        if (this.lastText !== null) {\n            this.lastText.textContent = \"last: \" + last + this.unitName;\n        }\n        if (this.ctx !== null) {\n            this.ctx.fillStyle = \"#010\";\n            this.ctx.fillRect(0, 0, MonitorGraphWidth, MonitorGraphHeight);\n            this.ctx.fillStyle = \"#0f0\";\n            this.samples.each(function (v, i) {\n                _this.ctx.fillRect(i, MonitorGraphHeight, 1, -(v * scale));\n            });\n        }\n    };\n    return MonitorWidget;\n}(Widget));\nvar CounterWidget = (function (_super) {\n    __extends(CounterWidget, _super);\n    function CounterWidget(name, counter) {\n        var _this = _super.call(this, name) || this;\n        _this.counter = counter;\n        _this.text = document.createElement(\"div\");\n        _this.element.appendChild(_this.text);\n        return _this;\n    }\n    CounterWidget.prototype.sync = function () {\n        this.text.textContent = this.name + \": \" + this.counter.value;\n    };\n    return CounterWidget;\n}(Widget));\n\nvar container = null;\nvar initialized = false;\n/**\n * Initialize Performance Monitor.\n */\nfunction initPerfMonitor(options) {\n    if (!initialized) {\n        if (options.container) {\n            container = options.container;\n        }\n        initialized = true;\n    }\n}\n/**\n * Check that everything is properly initialized.\n */\nfunction checkInit() {\n    if (!container) {\n        container = document.createElement(\"div\");\n        container.style.cssText = \"position: fixed;\" +\n            \"opacity: 0.9;\" +\n            \"right: 0;\" +\n            \"bottom: 0\";\n        document.body.appendChild(container);\n    }\n    initialized = true;\n}\n/**\n * Start FPS monitor\n */\nfunction startFPSMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMax |\n        MonitorWidgetFlags.HideMean | MonitorWidgetFlags.RoundValues; }\n    checkInit();\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"FPS\", flags, \"\", data);\n    container.appendChild(w.element);\n    var alpha = 2 / 121;\n    var last = 0;\n    var fps = 60;\n    function update(now) {\n        if (last > 0) {\n            fps += alpha * ((1000 / (now - last)) - fps);\n        }\n        last = now;\n        data.addSample(fps);\n        w.invalidate();\n        requestAnimationFrame(update);\n    }\n    requestAnimationFrame(update);\n}\n/**\n * Start Memory Monitor\n */\nfunction startMemMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMean; }\n    checkInit();\n    if (performance.memory === undefined) {\n        return;\n    }\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"Memory\", flags, \"MB\", data);\n    container.appendChild(w.element);\n    function update() {\n        data.addSample(Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)));\n        w.invalidate();\n        setTimeout(update, 30);\n    }\n    update();\n}\nvar ProfilerDetails = (function () {\n    function ProfilerDetails(name, unitName, flags) {\n        this.data = new MonitorSamples(MonitorMaxSamples);\n        this.widget = new MonitorWidget(name, flags, unitName, this.data);\n        this.startTime = -1;\n    }\n    return ProfilerDetails;\n}());\nvar profilerInstances = {};\nvar CounterDetails = (function () {\n    function CounterDetails(name, interval) {\n        var _this = this;\n        this.data = interval === undefined ? new BasicCounter() : new SlidingCounter(interval);\n        this.widget = new CounterWidget(name, this.data);\n        this.data.onChange = function () {\n            _this.widget.invalidate();\n        };\n    }\n    return CounterDetails;\n}());\nvar counterInstances = {};\n/**\n * Initialize profiler and insert into container.\n */\nfunction initProfiler(name, flags) {\n    if (flags === void 0) { flags = 0; }\n    checkInit();\n    var profiler = profilerInstances[name];\n    if (profiler === void 0) {\n        profilerInstances[name] = profiler = new ProfilerDetails(name, \"ms\", flags);\n        container.appendChild(profiler.widget.element);\n    }\n}\n/**\n * Initialize counter and insert into container.\n */\nfunction initCounter(name, interval) {\n    checkInit();\n    var counter = counterInstances[name];\n    if (counter === void 0) {\n        counterInstances[name] = counter = new CounterDetails(name, interval);\n        container.appendChild(counter.widget.element);\n    }\n}\nfunction startProfile(name) {\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0) {\n        profiler.startTime = performance.now();\n    }\n}\nfunction endProfile(name) {\n    var now = performance.now();\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0 && profiler.startTime !== -1) {\n        profiler.data.addSample(now - profiler.startTime);\n        profiler.widget.invalidate();\n    }\n}\nfunction count(name, value) {\n    if (value === void 0) { value = 1; }\n    var counter = counterInstances[name];\n    if (counter !== void 0) {\n        counter.data.inc(value);\n    }\n}\n/**\n * lookup a profile by name\n * @param name the name of the profile to lookup\n */\nfunction getProfile(name) {\n    return profilerInstances[name];\n}\n/**\n * lookup a counter by name\n * @param name the name of the counter to lookup\n */\nfunction getCounter(name) {\n    return counterInstances[name];\n}\n\nexport { initPerfMonitor, startFPSMonitor, startMemMonitor, ProfilerDetails, CounterDetails, initProfiler, initCounter, startProfile, endProfile, count, getProfile, getCounter, MonitorSamplesResult, MonitorMaxSamples, MonitorSamples, BasicCounter, SlidingCounter, Widget, MonitorWidgetFlags, MonitorWidget, CounterWidget };\n","import { _, render, TrackByKey, key, component, observable, watch, withNextFrame, requestDirtyCheck, AUTOFOCUS, invalidate, Events, onClick, onBlur, onInput, } from \"ivi\";\nimport { div, input, VALUE } from \"ivi-html\";\nimport { startProfile, endProfile, startFPSMonitor, startMemMonitor, initProfiler } from \"perf-monitor\";\nconst x = observable(1);\nconst y = observable(1);\nconst Field = component((c) => {\n    let value = \"a\";\n    let editing = false;\n    return () => {\n        watch(x);\n        watch(y);\n        return (Events([\n            onClick(() => {\n                editing = true;\n                invalidate(c);\n            }),\n            onBlur(() => {\n                editing = false;\n                invalidate(c);\n            }),\n            onInput((ev) => {\n                value = ev.target.value;\n                invalidate(c);\n            })\n        ], [\n            editing ? input(_, { value: VALUE(value), autofocus: AUTOFOCUS(true) }) : null,\n            !editing ? div(\"field\", _, value) : null,\n        ]));\n    };\n});\nconst Container = component(() => {\n    return ({ range }, children) => {\n        watch(x);\n        watch(y);\n        const cs = [];\n        for (let i = 0; i < range; i++) {\n            cs.push(children(i));\n        }\n        return div(_, _, TrackByKey(cs));\n    };\n});\nconst Main = component(() => {\n    return () => div(\"main\", _, Container({ range: 10 }, (i) => (key(i, Container({ range: 10 }, (j) => (key(j, Container({ range: 50 }, (k) => (key(k, Field()))))))))));\n});\nstartFPSMonitor();\nstartMemMonitor();\ninitProfiler(\"dirty check\");\nconst container = document.getElementById(\"app\");\nwithNextFrame(() => { render(Main(), container); })();\nfunction tick() {\n    startProfile(\"dirty check\");\n    withNextFrame(requestDirtyCheck)();\n    endProfile(\"dirty check\");\n    requestAnimationFrame(tick);\n}\nrequestAnimationFrame(tick);\n"],"sourceRoot":""}