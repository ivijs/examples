{"version":3,"sources":[" [synthetic:es6/util/inherits] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/symbol] "," [synthetic:util/polyfill] "," [synthetic:es6/array/fill] "," [synthetic:es6/util/makeiterator] "," [synthetic:util/owns] "," [synthetic:es6/weakmap] "," [synthetic:es6/map] ","node_modules/ivi/src/common/feature_detection.ts","node_modules/ivi/src/common/user_agent.ts","node_modules/ivi/src/common/noop.ts","node_modules/ivi/src/common/equality.ts","node_modules/ivi/src/vdom/vnode.ts","node_modules/ivi/src/vdom/vnode_builder.ts","node_modules/ivi/src/vdom/context.ts","node_modules/ivi/src/vdom/sync_dom.ts","node_modules/ivi/src/common/dom.ts","node_modules/ivi/src/events/sync_events.ts","node_modules/ivi/src/events/utils.ts","node_modules/ivi/src/vdom/implementation.ts","node_modules/ivi/src/vdom/component.ts","node_modules/ivi/src/scheduler/scheduler.ts","node_modules/ivi/src/vdom/root.ts","src/benchmarks/dbmon/db.ts","node_modules/perf-monitor/dist/es6/perf-monitor.js","src/benchmarks/dbmon/main.ts"],"names":["$jscomp.defineProperty","$jscomp.global","$jscomp.initSymbol","$jscomp.global.Symbol","$jscomp.Symbol","$jscomp.symbolCounter_","$jscomp.SYMBOL_PREFIX","$jscomp.global.Symbol.iterator","$jscomp.arrayIterator","$jscomp.initSymbolIterator","$jscomp.iteratorPrototype","$jscomp.polyfill","$jscomp.makeIterator","$jscomp.owns","opts","Object","defineProperty","get","window","addEventListener","e","ua","navigator","userAgent","USER_AGENT","test","MSStream","NOOP","isPropsNotIdentical","oldProps","newProps","getDOMInstanceFromVNode","node","_flags","_instance","root","_children","constructor","VNodeBuilder","flags","tag","props","className","children","_tag","_key","_props","_className","_events","_style","_ref","key","style","Array","isArray","i","length","n","result","slice","_normalizeVNodes","$t","value","checked","content","$h","tagName","undefined","$c","c","prototype","render","cloneVNode","newChildren","newNode","nodes","push","Context","data","from","v","keys","l","k","ROOT_CONTEXT","syncClassName","b","setAttribute","syncStyle","a","matchCount","bValue","aValue","hasOwnProperty","setDOMProperty","volume","removeAttribute","charCodeAt","setAttributeNS","XML_NAMESPACE","XLINK_NAMESPACE","syncDOMProps","unregisterEventHandler","handler","dispatcher","unregisterHandler","fn","syncEvents","registerHandler","aHandler","bHandler","events","_updateComponent","component","oldRoot","componentUpdateContext","willUpdate","parentNode","_parentDOMNode","newRoot","componentClassRender","vNodeSyncOrReplace","_context","vNodePropagateNewContext","didUpdate","_updateComponentFunction","parent","context","owner","isPropsChanged","instance","vNodeMount","vnode","didMount","vNodeUnmount","didUnmount","vNodeUnmountAll","vnodes","componentUpdateParentContext","vNodeRemoveChild","removeChild","newParentContext","_parentContext","oldContext","didReceiveNewContext","contextData","updateContext","newContext","vNodeRender","child","document","createTextNode","createElement","type","createElementNS","SVG_NAMESPACE","textContent","childInstance","insertBefore","input","innerHTML","vNodeRenderInto","container","refChild","vNodeCanSync","vNodeSync","nodeValue","bParentFlags","aParentFlags","firstChild","aStart","bStart","aEnd","bEnd","aStartNode","bStartNode","aEndNode","bEndNode","aNode","bNode","nextRef","nextPos","next","aLength","bLength","sources","fill","moved","pos","synced","j","keyIndex","Map","set","p","il","u","didReceiveNewProps","newInstance","replaceChild","clock","microtasks","macrotasks","microtaskNode","macrotaskMessage","Math","random","observe","microtaskObserver","MutationObserver","runMicrotasks","characterData","handleWindowMessage","ev","source","tasks","scheduler.macrotasks","scheduler.clock","scheduler.microtasks.length","scheduler.microtasks","roots","r","newVNode","currentVNode","domNode","invalidated","onclick","last","pop","indexOf","Query","elapsed","query","EMPTY_QUERY","DB","name","id","DB._nextId","queries","update","floor","getTopFiveQueries","qs","sort","DBList","dbs","MonitorSamplesResult","min","max","mean","MonitorSamples","samples","maxSamples","MonitorMaxSamples","_i","addSample","each","calc","sum","frameTasks","rafId","scheduleNextFrameTask","task","requestAnimationFrame","Widget","_sync","this._sync","sync","_dirty","element","cssText","invalidate","Error","MonitorWidgetFlags","MonitorWidget","unitName","label","text","HideMin","minText","appendChild","HideMax","maxText","HideMean","meanText","HideLast","lastText","HideGraph","canvas","width","MonitorGraphWidth","height","MonitorGraphHeight","ctx","getContext","$jscomp.inherits","scale","RoundValues","toFixed","round","toString","fillStyle","fillRect","checkInit","body","startFPSMonitor","now","fps","alpha","w","startMemMonitor","performance","memory","usedJSHeapSize","setTimeout","ProfilerDetails","widget","startTime","profilerInstances","initProfiler","profiler","Popover","target","DatabaseView","db","topFiveQueries","count$$1","q","comps","split","minutes","seconds","ms","Main","rows","mutations","N","location","search","substr","decodeURIComponent","replace","parseInt","parseFloat","sliderContainer","display","slider","marginBottom","marginTop","Number","getElementById"],"mappings":"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","file":"bundle.js","sourceRoot":"../../..","sourcesContent":[null,null,null,null,null,null,null,null,null,null,"/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n *\n * NOTE: Do not implement feature detection for features that aren't used in `ivi` library.\n */\n\n/**\n * Feature Flags.\n */\nexport const enum FeatureFlags {\n    /**\n     * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n     * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n     * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n     *\n     * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n     */\n    PassiveEvents = 1,\n    /**\n     * The `performancemark()` method creates a timestamp in the browser's performance entry buffer with the given\n     * name.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\n     */\n    DevModePerfMarks = 1 << 1,\n}\n\n/**\n * Supported Features, see `FeatureFlags` for details.\n */\nexport let FEATURES: FeatureFlags = 0;\n\nif (__IVI_BROWSER__) {\n    /**\n     * Passive Events:\n     *\n     * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n     */\n    try {\n        // Test via a getter in the options object to see if the passive property is accessed\n        const opts = Object.defineProperty({}, \"passive\", {\n            get: function () {\n                FEATURES |= FeatureFlags.PassiveEvents;\n            },\n        });\n        window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n    } catch (e) {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Check `performance.mark` availability.\n     */\n    if (__IVI_DEV__) {\n        if (performance && performance.mark && performance.measure) {\n            FEATURES |= FeatureFlags.DevModePerfMarks;\n        }\n    }\n}\n","/**\n * User Agent detection is used to fix some quirks like iOS event bubbling, etc.\n *\n * NOTE: Do not implement any browser detection that aren't used in `ivi` library.\n */\n\nconst ua = __IVI_BROWSER__ && navigator ? navigator.userAgent : \"\";\n\n/**\n * User Agent Flags.\n */\nexport const enum UserAgentFlags {\n    /**\n     * iOS browser (iPad, iPhone, iPod).\n     */\n    iOS = 1,\n    /**\n     * Android browser.\n     */\n    Android = 1 << 1,\n};\n\n/**\n * User Agent, see `UserAgentFlags` for details.\n */\nexport let USER_AGENT: UserAgentFlags = 0;\n\nif (__IVI_BROWSER__) {\n    if (/iPad|iPhone|iPod/.test(ua) && !(window as any).MSStream) {\n        USER_AGENT |= UserAgentFlags.iOS;\n    }\n\n    if (/Android/.test(ua)) {\n        USER_AGENT |= UserAgentFlags.Android;\n    }\n}\n","\n/**\n * NOOP function.\n */\nexport function NOOP() {\n    /* tslint:disable:no-empty */\n    /* tslint:enable:no-empty */\n}\n","/**\n * Props checking functions for Component `isPropsChanged` hint method.\n */\n\n/**\n * Check if props are not identical.\n *\n * @param oldProps\n * @param newProps\n * @returns `true` when props are not identical.\n */\nexport function isPropsNotIdentical<P>(oldProps: P, newProps: P): boolean {\n    return oldProps !== newProps;\n}\n\n/**\n * Check if props are not shallow equal.\n *\n * @param oldProps\n * @param newProps\n * @returns `true` when props are not shallow equal.\n */\nexport function isPropsNotShallowEqual<P>(oldProps: P, newProps: P): boolean {\n    if (oldProps === newProps) {\n        return false;\n    }\n\n    const aKeys = Object.keys(oldProps);\n    const bKeys = Object.keys(newProps);\n\n    if (aKeys.length !== bKeys.length) {\n        return true;\n    }\n\n    for (let i = 0; i < aKeys.length; i++) {\n        const key = aKeys[i];\n        const aValue = (oldProps as { [key: string]: any })[key];\n        const bValue = (newProps as { [key: string]: any })[key];\n        if (aValue !== bValue) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","import { EventHandlerList } from \"../events/event_handler\";\nimport { CSSStyleProps } from \"./dom_props\";\nimport { VNodeFlags } from \"./flags\";\nimport { ComponentClass, ComponentFunction, Component } from \"./component\";\nimport { ElementDescriptor } from \"./element_descriptor\";\n\n/**\n * VNode object is the core object in ivi Virtual DOM, it can represent any node type.\n */\nexport interface VNode<P> {\n    /**\n     * Flags, see `VNodeFlags` for details.\n     */\n    _flags: VNodeFlags;\n    /**\n     * Tag name of the element.\n     *\n     * When VNode represents a Component, tag property should contain reference to a `ComponentClass` if it is a\n     * stateful component or `ComponentFunction` for stateless components.\n     */\n    _tag: string | ComponentClass<any> | ComponentFunction<any> | ElementDescriptor<any> | null;\n    /**\n     * Children reconciliation algorithm is using key property to find the same node in the previous children array. Key\n     * should be unique among its siblings.\n     */\n    _key: any;\n    /**\n     * Properties.\n     */\n    _props: P | null;\n    /**\n     * Class name.\n     */\n    _className: string | null;\n    /**\n     * Style.\n     */\n    _style: CSSStyleProps | null;\n    /**\n     * Events.\n     */\n    _events: EventHandlerList | null;\n    /**\n     * Children property can contain flat array of children virtual nodes, or text if it contains a single text node\n     * child.\n     *\n     * When virtual node represents an input field, children property will contain input value.\n     */\n    _children: VNode<any>[] | VNode<any> | string | number | boolean | null | undefined;\n    /**\n     * Reference to HTML node or Component instance. It will be available after virtual node is created or synced. Each\n     * time VNode is synced, reference will be transferred from the old VNode to the new one.\n     */\n    _instance: Node | Component<any> | null;\n    /**\n     * Ref callback.\n     */\n    _ref: ((ref: Node | Component<any> | null) => void) | null;\n    /**\n     * Unique ID thas is available in Dev Mode.\n     */\n    _debugId: number;\n}\n\n/**\n * Check if VNode is representing a Text node.\n *\n * @param node VNode.\n * @returns true when VNode is representing a Text node.\n */\nexport function isTextNode(node: VNode<any>): boolean {\n    return !!(node._flags & VNodeFlags.Text);\n}\n\n/**\n * Check if VNode is representing an Element.\n *\n * @param node VNode.\n * @returns true when VNode is representing an element node.\n */\nexport function isElementNode(node: VNode<any>): boolean {\n    return !!(node._flags & VNodeFlags.Element);\n}\n\n/**\n * Check if VNode is representing an SVG Element.\n *\n * @param node VNode.\n * @returns true when VNode is representing a text node.\n */\nexport function isSVGNode(node: VNode<any>): boolean {\n    return !!(node._flags & VNodeFlags.SvgElement);\n}\n\n/**\n * Check if VNode is representing a Component.\n *\n * @param node VNode.\n * @returns true when VNode is representing a Component.\n */\nexport function isComponentNode(node: VNode<any>): boolean {\n    return !!(node._flags & VNodeFlags.Component);\n}\n\n/**\n * Get reference to a DOM node from a VNode object.\n *\n * @param node VNode which contains reference to a DOM node.\n * @returns null if VNode doesn't have a reference to a DOM node.\n */\nexport function getDOMInstanceFromVNode<T extends Node>(node: VNode<any>): T | null {\n    if (node._flags & VNodeFlags.Component) {\n        if (node._flags & VNodeFlags.ComponentClass) {\n            return getDOMInstanceFromVNode<T>((node._instance as Component<any>).root!);\n        } else {\n            return getDOMInstanceFromVNode<T>(node._children as VNode<any>);\n        }\n    }\n    return node._instance as T;\n}\n\n/**\n * Get reference to a Component instance from a VNode object.\n *\n * @param node VNode which contains reference to a Component instance.\n * @returns null if VNode doesn't have a reference to a Component instance.\n */\nexport function getComponentRef<P>(node: VNode<P>): Component<P> | null {\n    if (__IVI_DEV__) {\n        if (!(node._flags & VNodeFlags.Component)) {\n            throw new Error(\"Failed to get component reference: VNode should represent a Component.\");\n        }\n    }\n    return node._instance as Component<P> | null;\n}\n","import { nextDebugId } from \"../common/dev_mode\";\nimport { InputType } from \"../common/dom\";\nimport { VNode } from \"./vnode\";\nimport { VNodeFlags, ElementDescriptorFlags } from \"./flags\";\nimport { ComponentFunction, ComponentClass, Component } from \"./component\";\nimport { ElementDescriptor } from \"./element_descriptor\";\nimport { EventHandlerList } from \"../events/event_handler\";\nimport {\n    HTMLAnchorElementProps, HTMLElementProps, HTMLAppletElementProps, HTMLAreaElementProps, HTMLAudioElementProps,\n    HTMLBaseElementProps, HTMLBaseFontElementProps, HTMLBodyElementProps, HTMLBRElementProps, HTMLButtonElementProps,\n    HTMLCanvasElementProps, HTMLQuoteElementProps, HTMLTableCaptionElementProps, HTMLTableColElementProps,\n    HTMLDataListElementProps, HTMLModElementProps, HTMLDirectoryElementProps, HTMLDivElementProps,\n    HTMLDListElementProps, HTMLEmbedElementProps, HTMLFieldSetElementProps, HTMLFontElementProps, HTMLFormElementProps,\n    HTMLFrameElementProps, HTMLFrameSetElementProps, HTMLHeadElementProps, HTMLHeadingElementProps, HTMLHRElementProps,\n    HTMLHtmlElementProps, HTMLIFrameElementProps, HTMLImageElementProps, HTMLInputElementProps, HTMLLabelElementProps,\n    HTMLLegendElementProps, HTMLLIElementProps, HTMLLinkElementProps, HTMLMapElementProps, HTMLMarqueeElementProps,\n    HTMLMenuElementProps, HTMLMetaElementProps, HTMLMeterElementProps, HTMLObjectElementProps, HTMLOListElementProps,\n    HTMLOptGroupElementProps, HTMLOptionElementProps, HTMLParagraphElementProps, HTMLParamElementProps,\n    HTMLPictureElementProps, HTMLPreElementProps, HTMLProgressElementProps, HTMLScriptElementProps,\n    HTMLSelectElementProps, HTMLSourceElementProps, HTMLSpanElementProps, HTMLStyleElementProps,\n    HTMLTableDataCellElementProps, HTMLTableElementProps, HTMLTableHeaderCellElementProps, HTMLTableRowElementProps,\n    HTMLTableSectionElementProps, HTMLTemplateElementProps, HTMLTextAreaElementProps, HTMLTitleElementProps,\n    HTMLTrackElementProps, HTMLUListElementProps, HTMLUnknownElementProps, HTMLVideoElementProps, HTMLMediaElementProps,\n    MSHTMLWebViewElementProps,\n\n    SVGCircleElementProps, SVGClipPathElementProps, SVGDefsElementProps, SVGDescElementProps, SVGEllipseElementProps,\n    SVGFEBlendElementProps, SVGFEColorMatrixElementProps, SVGFEComponentTransferElementProps,\n    SVGFECompositeElementProps, SVGFEConvolveMatrixElementProps, SVGFEDiffuseLightingElementProps,\n    SVGFEDisplacementMapElementProps, SVGFEDistantLightElementProps, SVGFEFloodElementProps, SVGFEFuncAElementProps,\n    SVGFEFuncBElementProps, SVGFEFuncGElementProps, SVGFEFuncRElementProps, SVGFEGaussianBlurElementProps,\n    SVGFEImageElementProps, SVGFEMergeElementProps, SVGFEMergeNodeElementProps, SVGFEMorphologyElementProps,\n    SVGFEOffsetElementProps, SVGFEPointLightElementProps, SVGFESpecularLightingElementProps, SVGFESpotLightElementProps,\n    SVGFETileElementProps, SVGFETurbulenceElementProps, SVGFilterElementProps, SVGForeignObjectElementProps,\n    SVGGElementProps, SVGImageElementProps, SVGLinearGradientElementProps, SVGLineElementProps, SVGMarkerElementProps,\n    SVGMaskElementProps, SVGMetadataElementProps, SVGPathElementProps, SVGPatternElementProps, SVGPolygonElementProps,\n    SVGPolylineElementProps, SVGRadialGradientElementProps, SVGRectElementProps, SVGStopElementProps,\n    SVGSVGElementProps, SVGSwitchElementProps, SVGSymbolElementProps, SVGTextElementProps, SVGTextPathElementProps,\n    SVGTSpanElementProps, SVGViewElementProps, SVGUseElementProps, SVGElementProps,\n\n    CSSStyleProps,\n} from \"./dom_props\";\n\n/**\n * VNode Builder provides a chain-method API to build VNodes.\n *\n * VNodeBuilder class has a parametric type `P` to specify `props` type.\n *\n *     const vnode = $h(\"div\", \"div-class-name\")\n *         .props({ id: \"div-id\" })\n *         .events({ click: Events.onClick((e) => console.log(\"click event\", e)) })\n *         .children(\"Hello\");\n *\n * There are several factory functions that create VNode Builder objects:\n *\n *     // Basic HTML Elements\n *     $h(tagName: string, className?: string): VNodeBuilder<HTMLElementProps | null>;\n *\n *     // SVG Elements\n *     $s(tagName: string, className?: string): VNodeBuilder<SVGElementProps | null>;\n *\n *     // Components\n *     $c<P>(component: ComponentClass<P> | ComponentFunction<P>, props: P): VNodeBuilder<P>;\n *\n *     // Input Elements and TextArea (specifying type as \"textarea\" will create HTMLTextAreaElement)\n *     $i(type: string, className?: string): VNodeBuilder<HTMLInputElementProps | HTMLTextAreaElementProps | null>;\n *\n *     // Media Elements (Video and Audio)\n *     $m(tagName: string, className?: string): VNodeBuilder<HTMLMediaElementProps | null>;\n *\n *     // Text Nodes\n *     $t(text: string): VNodeBuilder<null>;\n *\n * @final\n */\nexport class VNodeBuilder<P> implements VNode<P> {\n    _flags: VNodeFlags;\n    _tag: string | ComponentClass<any> | ComponentFunction<any> | ElementDescriptor<any> | null;\n    _key: any;\n    _props: P | null;\n    _className: string | null;\n    _style: CSSStyleProps | null;\n    _events: EventHandlerList | null;\n    _children: VNode<any>[] | VNode<any> | string | number | boolean | null | undefined;\n    _instance: Node | Component<any> | null;\n    _ref: ((ref: Node | Component<any> | null) => void) | null;\n    _debugId: number;\n\n    constructor(\n        flags: number,\n        tag: string | ComponentFunction<P> | ComponentClass<P> | ElementDescriptor<any> | null,\n        props: P | null,\n        className: string | null,\n        children: VNode<any>[] | VNode<any> | string | number | boolean | null | undefined,\n    ) {\n        this._flags = flags;\n        this._tag = tag;\n        this._key = null;\n        this._props = props;\n        this._className = className;\n        this._style = null;\n        this._events = null;\n        this._children = children;\n        this._instance = null;\n        this._ref = null;\n        if (__IVI_DEV__) {\n            this._debugId = nextDebugId();\n        }\n    }\n\n    /**\n     * Set key.\n     *\n     * Children reconciliation algorithm is using key property to find the same node in the previous children array. Key\n     * should be unique among its siblings.\n     *\n     * @param key Any object that should be unique among its siblings.\n     * @returns VNodeBuilder.\n     */\n    key(key: any): VNodeBuilder<P> {\n        this._key = key;\n        return this;\n    }\n\n    /**\n     * Set className.\n     *\n     * @param className.\n     * @returns VNodeBuilder.\n     */\n    className(className: string | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set className, className is available on element nodes only.\");\n            }\n            if (className !== null) {\n                if (this._flags & VNodeFlags.ElementDescriptor) {\n                    const d = this._tag as ElementDescriptor<P>;\n                    if (d._flags & ElementDescriptorFlags.ProtectClassName) {\n                        throw new Error(\"Failed to set className, className is protected by an ElementDescriptor.\");\n                    }\n                }\n            }\n        }\n        this._className = className;\n        return this;\n    }\n\n    /**\n     * Set style.\n     *\n     * @param style.\n     * @returns VNodeBuilder.\n     */\n    style(style: CSSStyleProps | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set style, style is available on element nodes only.\");\n            }\n\n            if (style !== null) {\n                if (this._flags & VNodeFlags.ElementDescriptor) {\n                    const d = this._tag as ElementDescriptor<P>;\n                    if (d._flags & ElementDescriptorFlags.ProtectStyle) {\n                        if (d._protectedStyle) {\n                            const keys = Object.keys(d._protectedStyle);\n                            for (let i = 0; i < keys.length; i++) {\n                                const key = keys[i];\n                                if (style.hasOwnProperty(key)) {\n                                    throw new Error(`Failed to set style, \"${key}\" style is protected by an ` +\n                                        `ElementDescriptor.`);\n                                }\n                            }\n                        } else {\n                            throw new Error(\"Failed to set style, style is protected by an ElementDescriptor.\");\n                        }\n                    }\n                }\n            }\n        }\n        this._style = style;\n        return this;\n    }\n\n    /**\n     * Set events.\n     *\n     * @param events.\n     * @returns VNodeBuilder.\n     */\n    events(events: EventHandlerList | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set events, events are available on element nodes only.\");\n            }\n        }\n        this._events = events;\n        return this;\n    }\n\n    /**\n     * Set props.\n     *\n     * @param props.\n     * @returns VNodeBuilder.\n     */\n    props(props: P): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (props) {\n                if (this._flags & VNodeFlags.ElementDescriptor) {\n                    const d = this._tag as ElementDescriptor<P>;\n                    if (d._flags & ElementDescriptorFlags.ProtectProps) {\n                        if (d._protectedProps) {\n                            const keys = Object.keys(d._protectedProps);\n                            for (let i = 0; i < keys.length; i++) {\n                                const key = keys[i];\n                                if (props.hasOwnProperty(key)) {\n                                    throw new Error(`Failed to set props, \"${key}\" property is protected by an ` +\n                                        `ElementDescriptor.`);\n                                }\n                            }\n                        } else {\n                            throw new Error(\"Failed to set props, props are protected by an ElementDescriptor.\");\n                        }\n                    }\n                }\n            }\n        }\n        this._props = props;\n        return this;\n    }\n\n    /**\n     * Set children.\n     *\n     * @param children Children can be a simple string, single VNode or recursive list of VNodes with strings and null\n     *   values. It will automatically normalize recursive lists by flattening, filtering out null values and replacing\n     *   strings with text nodes.\n     * @returns VNodeBuilder.\n     */\n    children(children: VNodeRecursiveArray | VNode<any> | string | number | boolean | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set children, children are available on element nodes only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set children, input elements can't have children.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children, media elements can't have children.\");\n            }\n        }\n        if (Array.isArray(children)) {\n            this._flags |= VNodeFlags.ChildrenArray;\n            this._children = normalizeVNodes(children);\n        } else {\n            if (typeof children === \"object\") {\n                this._flags |= VNodeFlags.ChildrenVNode;\n            } else {\n                this._flags |= VNodeFlags.ChildrenBasic;\n            }\n            this._children = children;\n        }\n        return this;\n    }\n\n    /**\n     * Set children that will be tracked by `key` property.\n     *\n     * To support use cases with static nodes at the beginning and at the end of the children list, children list may\n     * contain nodes with `null` keys at the beginning of the list and at the end, children with `null` keys shouldn't\n     * move.\n     *\n     * NOTE: If you've found any other use case that can't be easily solved with the current `trackByKeyChildren`\n     * implementation, feel free to submit an issue, but most of the time it is better to help browsers with layout\n     * calculation, and it will be better to wrap nodes that aren't moved into its own container nodes and specify css\n     * containment property. Use cases with \"semantic\" markup probably will be ignored.\n     *\n     * @param children Recursive lists of vnodes that can contain null values. It will automatically normalize recursive\n     *   lists by flattening and filtering out null values.\n     * @returns VNodeBuilder.\n     */\n    trackByKeyChildren(children: VNodeRecursiveArray | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set children, children are available on element nodes only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set children, input elements can't have children.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children, media elements can't have children.\");\n            }\n\n        }\n        this._flags |= VNodeFlags.TrackByKeyChildren | VNodeFlags.ChildrenArray;\n        if (children) {\n            this._children = normalizeVNodes(children);\n        }\n\n        if (__IVI_DEV__) {\n            const childrenArray = this._children as VNode<any>[];\n            let child: VNode<any>;\n            let start = 0;\n            let end = childrenArray.length - 1;\n            while (start <= end) {\n                child = childrenArray[start];\n                if (child._key !== null) {\n                    break;\n                }\n                start++;\n            }\n            while (start <= end) {\n                child = childrenArray[end];\n                if (child._key !== null) {\n                    break;\n                }\n                end--;\n            }\n\n            if (start <= end) {\n                const usedKeys = new Set<any>();\n                while (start <= end) {\n                    child = childrenArray[start];\n                    const key = child._key;\n                    if (key === null) {\n                        throw new Error(`Failed to set children, invalid keyed children list, keyed ` +\n                            `children should have a shape like [non-keyed, keyed, non-keyed].`);\n                    }\n                    if (usedKeys.has(key)) {\n                        throw new Error(`Failed to set children, invalid children list, key: \"${key}\" is ` +\n                            `used multiple times.`);\n                    }\n                    usedKeys.add(key);\n                    start++;\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Set children as an innerHTML string. It is potentially vulnerable to XSS attacks.\n     *\n     * @param html innerHTML in a string format.\n     * @returns VNodeBuilder.\n    */\n    unsafeHTML(html: string): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.Element)) {\n                throw new Error(\"Failed to set unsafeHTML, unsafeHTML is available on element nodes only.\");\n            }\n            if (this._flags & VNodeFlags.InputElement) {\n                throw new Error(\"Failed to set unsafeHTML, input elements can't have innerHTML.\");\n            }\n            if (this._flags & VNodeFlags.MediaElement) {\n                throw new Error(\"Failed to set children, media elements can't have children.\");\n            }\n        }\n        this._flags |= VNodeFlags.UnsafeHTML;\n        this._children = html;\n        return this;\n    }\n\n    /**\n     * Set HTMLInputElement/HTMLTextAreaElement value property.\n     *\n     * @param text Text value.\n     * @returns VNodeBuilder.\n     */\n    value(value: string | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.InputElement)) {\n                throw new Error(\"Failed to set value, value is available on input elements only.\");\n            }\n        }\n        this._children = value;\n        return this;\n    }\n\n    /**\n     * Set HTMLInputElement checked property.\n     *\n     * @param text Text value.\n     * @returns VNodeBuilder.\n     */\n    checked(checked: boolean | null): VNodeBuilder<P> {\n        if (__IVI_DEV__) {\n            if (!(this._flags & VNodeFlags.InputElement)) {\n                throw new Error(\"Failed to set checked, checked is available on input elements only.\");\n            }\n            if (!isInputTypeSupportsCheckedValue(this._tag as InputType)) {\n                throw new Error(`Failed to set checked, input elements with type ${this._tag} doesn't support `\n                    + `checked value.`);\n            }\n        }\n        this._children = checked;\n        return this;\n    }\n\n    /**\n     * Set ref callback.\n     *\n     * When VNode is mounted ref callback will be invoked with a Node value for DOM Elements or Component instance for\n     * components.\n     *\n     * When VNode is unmounted ref callback will be invoked with a `null` value.\n     *\n     * @param ref callback.\n     * @returns VNodeBuilder.\n     */\n    ref(ref: (ref: Node | null) => void): VNodeBuilder<P>;\n    ref(ref: (ref: Component<any> | null) => void): VNodeBuilder<P>;\n    ref(ref: ((ref: Node | null) => void) | ((ref: Component<any> | null) => void)): VNodeBuilder<P> {\n        this._ref = ref;\n        return this;\n    }\n}\n\nexport type VNodeRecursiveListValue = VNodeRecursiveArray | VNode<any> | string | number | boolean | null;\n/**\n * Recursive VNode List.\n */\nexport interface VNodeRecursiveArray extends Array<VNodeRecursiveListValue> { }\n\n/**\n * Create a VNodeBuilder representing a Text node.\n *\n * @param context Text content.\n * @returns VNodeBuilder object.\n */\nexport function $t(content: string | number | boolean | null): VNodeBuilder<null> {\n    return new VNodeBuilder<null>(VNodeFlags.Text, null, null, null, content);\n}\n\n/* tslint:disable:max-line-length */\n/**\n * Create a VNodeBuilder representing an Element node.\n *\n * @param tagName HTML Element tag name.\n * @param props HTML Element props.\n * @returns VNodeBuilder object.\n */\nexport function $h(tagName: \"a\", className?: string): VNodeBuilder<HTMLAnchorElementProps | null>;\nexport function $h(tagName: \"abbr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"acronym\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"address\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"applet\", className?: string): VNodeBuilder<HTMLAppletElementProps | null>;\nexport function $h(tagName: \"area\", className?: string): VNodeBuilder<HTMLAreaElementProps | null>;\nexport function $h(tagName: \"article\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"aside\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"b\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"base\", className?: string): VNodeBuilder<HTMLBaseElementProps | null>;\nexport function $h(tagName: \"basefont\", className?: string): VNodeBuilder<HTMLBaseFontElementProps | null>;\nexport function $h(tagName: \"bdo\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"big\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"blockquote\", className?: string): VNodeBuilder<HTMLQuoteElementProps | null>;\nexport function $h(tagName: \"body\", className?: string): VNodeBuilder<HTMLBodyElementProps | null>;\nexport function $h(tagName: \"br\", className?: string): VNodeBuilder<HTMLBRElementProps | null>;\nexport function $h(tagName: \"button\", className?: string): VNodeBuilder<HTMLButtonElementProps | null>;\nexport function $h(tagName: \"canvas\", className?: string): VNodeBuilder<HTMLCanvasElementProps | null>;\nexport function $h(tagName: \"caption\", className?: string): VNodeBuilder<HTMLTableCaptionElementProps | null>;\nexport function $h(tagName: \"center\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"cite\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"code\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"col\", className?: string): VNodeBuilder<HTMLTableColElementProps | null>;\nexport function $h(tagName: \"colgroup\", className?: string): VNodeBuilder<HTMLTableColElementProps | null>;\nexport function $h(tagName: \"datalist\", className?: string): VNodeBuilder<HTMLDataListElementProps | null>;\nexport function $h(tagName: \"dd\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"del\", className?: string): VNodeBuilder<HTMLModElementProps | null>;\nexport function $h(tagName: \"dfn\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"dir\", className?: string): VNodeBuilder<HTMLDirectoryElementProps | null>;\nexport function $h(tagName: \"div\", className?: string): VNodeBuilder<HTMLDivElementProps | null>;\nexport function $h(tagName: \"dl\", className?: string): VNodeBuilder<HTMLDListElementProps | null>;\nexport function $h(tagName: \"dt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"em\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"embed\", className?: string): VNodeBuilder<HTMLEmbedElementProps | null>;\nexport function $h(tagName: \"fieldset\", className?: string): VNodeBuilder<HTMLFieldSetElementProps | null>;\nexport function $h(tagName: \"figcaption\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"figure\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"font\", className?: string): VNodeBuilder<HTMLFontElementProps | null>;\nexport function $h(tagName: \"footer\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"form\", className?: string): VNodeBuilder<HTMLFormElementProps | null>;\nexport function $h(tagName: \"frame\", className?: string): VNodeBuilder<HTMLFrameElementProps | null>;\nexport function $h(tagName: \"frameset\", className?: string): VNodeBuilder<HTMLFrameSetElementProps | null>;\nexport function $h(tagName: \"h1\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h2\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h3\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h4\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h5\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"h6\", className?: string): VNodeBuilder<HTMLHeadingElementProps | null>;\nexport function $h(tagName: \"head\", className?: string): VNodeBuilder<HTMLHeadElementProps | null>;\nexport function $h(tagName: \"header\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"hgroup\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"hr\", className?: string): VNodeBuilder<HTMLHRElementProps | null>;\nexport function $h(tagName: \"html\", className?: string): VNodeBuilder<HTMLHtmlElementProps | null>;\nexport function $h(tagName: \"i\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"iframe\", className?: string): VNodeBuilder<HTMLIFrameElementProps | null>;\nexport function $h(tagName: \"img\", className?: string): VNodeBuilder<HTMLImageElementProps | null>;\nexport function $h(tagName: \"ins\", className?: string): VNodeBuilder<HTMLModElementProps | null>;\nexport function $h(tagName: \"isindex\", className?: string): VNodeBuilder<HTMLUnknownElementProps | null>;\nexport function $h(tagName: \"kbd\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"keygen\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"label\", className?: string): VNodeBuilder<HTMLLabelElementProps | null>;\nexport function $h(tagName: \"legend\", className?: string): VNodeBuilder<HTMLLegendElementProps | null>;\nexport function $h(tagName: \"li\", className?: string): VNodeBuilder<HTMLLIElementProps | null>;\nexport function $h(tagName: \"link\", className?: string): VNodeBuilder<HTMLLinkElementProps | null>;\nexport function $h(tagName: \"listing\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: \"map\", className?: string): VNodeBuilder<HTMLMapElementProps | null>;\nexport function $h(tagName: \"mark\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"marquee\", className?: string): VNodeBuilder<HTMLMarqueeElementProps | null>;\nexport function $h(tagName: \"menu\", className?: string): VNodeBuilder<HTMLMenuElementProps | null>;\nexport function $h(tagName: \"meta\", className?: string): VNodeBuilder<HTMLMetaElementProps | null>;\nexport function $h(tagName: \"meter\", className?: string): VNodeBuilder<HTMLMeterElementProps | null>;\nexport function $h(tagName: \"nav\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"nextid\", className?: string): VNodeBuilder<HTMLUnknownElementProps | null>;\nexport function $h(tagName: \"nobr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"noframes\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"noscript\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"object\", className?: string): VNodeBuilder<HTMLObjectElementProps | null>;\nexport function $h(tagName: \"ol\", className?: string): VNodeBuilder<HTMLOListElementProps | null>;\nexport function $h(tagName: \"optgroup\", className?: string): VNodeBuilder<HTMLOptGroupElementProps | null>;\nexport function $h(tagName: \"option\", className?: string): VNodeBuilder<HTMLOptionElementProps | null>;\nexport function $h(tagName: \"p\", className?: string): VNodeBuilder<HTMLParagraphElementProps | null>;\nexport function $h(tagName: \"param\", className?: string): VNodeBuilder<HTMLParamElementProps | null>;\nexport function $h(tagName: \"picture\", className?: string): VNodeBuilder<HTMLPictureElementProps | null>;\nexport function $h(tagName: \"plaintext\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"pre\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: \"progress\", className?: string): VNodeBuilder<HTMLProgressElementProps | null>;\nexport function $h(tagName: \"q\", className?: string): VNodeBuilder<HTMLQuoteElementProps | null>;\nexport function $h(tagName: \"rt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"ruby\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"s\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"samp\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"script\", className?: string): VNodeBuilder<HTMLScriptElementProps | null>;\nexport function $h(tagName: \"section\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"select\", className?: string): VNodeBuilder<HTMLSelectElementProps | null>;\nexport function $h(tagName: \"small\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"source\", className?: string): VNodeBuilder<HTMLSourceElementProps | null>;\nexport function $h(tagName: \"span\", className?: string): VNodeBuilder<HTMLSpanElementProps | null>;\nexport function $h(tagName: \"strike\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"strong\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"style\", className?: string): VNodeBuilder<HTMLStyleElementProps | null>;\nexport function $h(tagName: \"sub\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"sup\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"table\", className?: string): VNodeBuilder<HTMLTableElementProps | null>;\nexport function $h(tagName: \"tbody\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"td\", className?: string): VNodeBuilder<HTMLTableDataCellElementProps | null>;\nexport function $h(tagName: \"template\", className?: string): VNodeBuilder<HTMLTemplateElementProps | null>;\nexport function $h(tagName: \"textarea\", className?: string): VNodeBuilder<HTMLTextAreaElementProps | null>;\nexport function $h(tagName: \"tfoot\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"th\", className?: string): VNodeBuilder<HTMLTableHeaderCellElementProps | null>;\nexport function $h(tagName: \"thead\", className?: string): VNodeBuilder<HTMLTableSectionElementProps | null>;\nexport function $h(tagName: \"title\", className?: string): VNodeBuilder<HTMLTitleElementProps | null>;\nexport function $h(tagName: \"tr\", className?: string): VNodeBuilder<HTMLTableRowElementProps | null>;\nexport function $h(tagName: \"track\", className?: string): VNodeBuilder<HTMLTrackElementProps | null>;\nexport function $h(tagName: \"tt\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"u\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"ul\", className?: string): VNodeBuilder<HTMLUListElementProps | null>;\nexport function $h(tagName: \"var\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"wbr\", className?: string): VNodeBuilder<HTMLElementProps | null>;\nexport function $h(tagName: \"x-ms-webview\", className?: string): VNodeBuilder<MSHTMLWebViewElementProps | null>;\nexport function $h(tagName: \"xmp\", className?: string): VNodeBuilder<HTMLPreElementProps | null>;\nexport function $h(tagName: string, className?: string): VNodeBuilder<HTMLElementProps | null> {\n    return new VNodeBuilder<HTMLElementProps | null>(\n        VNodeFlags.Element,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\n/**\n * Create a VNodeBuilder representing a SVGElement node.\n *\n * @param tagName SVG Element tag name.\n * @param className Class name.\n * @returns VNodeBuilder object.\n */\nexport function $s(tagName: \"circle\", className?: string): VNodeBuilder<SVGCircleElementProps | null>;\nexport function $s(tagName: \"clippath\", className?: string): VNodeBuilder<SVGClipPathElementProps | null>;\nexport function $s(tagName: \"defs\", className?: string): VNodeBuilder<SVGDefsElementProps | null>;\nexport function $s(tagName: \"desc\", className?: string): VNodeBuilder<SVGDescElementProps | null>;\nexport function $s(tagName: \"ellipse\", className?: string): VNodeBuilder<SVGEllipseElementProps | null>;\nexport function $s(tagName: \"feblend\", className?: string): VNodeBuilder<SVGFEBlendElementProps | null>;\nexport function $s(tagName: \"fecolormatrix\", className?: string): VNodeBuilder<SVGFEColorMatrixElementProps | null>;\nexport function $s(tagName: \"fecomponenttransfer\", className?: string): VNodeBuilder<SVGFEComponentTransferElementProps | null>;\nexport function $s(tagName: \"fecomposite\", className?: string): VNodeBuilder<SVGFECompositeElementProps | null>;\nexport function $s(tagName: \"feconvolvematrix\", className?: string): VNodeBuilder<SVGFEConvolveMatrixElementProps | null>;\nexport function $s(tagName: \"fediffuselighting\", className?: string): VNodeBuilder<SVGFEDiffuseLightingElementProps | null>;\nexport function $s(tagName: \"fedisplacementmap\", className?: string): VNodeBuilder<SVGFEDisplacementMapElementProps | null>;\nexport function $s(tagName: \"fedistantlight\", className?: string): VNodeBuilder<SVGFEDistantLightElementProps | null>;\nexport function $s(tagName: \"feflood\", className?: string): VNodeBuilder<SVGFEFloodElementProps | null>;\nexport function $s(tagName: \"fefunca\", className?: string): VNodeBuilder<SVGFEFuncAElementProps | null>;\nexport function $s(tagName: \"fefuncb\", className?: string): VNodeBuilder<SVGFEFuncBElementProps | null>;\nexport function $s(tagName: \"fefuncg\", className?: string): VNodeBuilder<SVGFEFuncGElementProps | null>;\nexport function $s(tagName: \"fefuncr\", className?: string): VNodeBuilder<SVGFEFuncRElementProps | null>;\nexport function $s(tagName: \"fegaussianblur\", className?: string): VNodeBuilder<SVGFEGaussianBlurElementProps | null>;\nexport function $s(tagName: \"feimage\", className?: string): VNodeBuilder<SVGFEImageElementProps | null>;\nexport function $s(tagName: \"femerge\", className?: string): VNodeBuilder<SVGFEMergeElementProps | null>;\nexport function $s(tagName: \"femergenode\", className?: string): VNodeBuilder<SVGFEMergeNodeElementProps | null>;\nexport function $s(tagName: \"femorphology\", className?: string): VNodeBuilder<SVGFEMorphologyElementProps | null>;\nexport function $s(tagName: \"feoffset\", className?: string): VNodeBuilder<SVGFEOffsetElementProps | null>;\nexport function $s(tagName: \"fepointlight\", className?: string): VNodeBuilder<SVGFEPointLightElementProps | null>;\nexport function $s(tagName: \"fespecularlighting\", className?: string): VNodeBuilder<SVGFESpecularLightingElementProps | null>;\nexport function $s(tagName: \"fespotlight\", className?: string): VNodeBuilder<SVGFESpotLightElementProps | null>;\nexport function $s(tagName: \"fetile\", className?: string): VNodeBuilder<SVGFETileElementProps | null>;\nexport function $s(tagName: \"feturbulence\", className?: string): VNodeBuilder<SVGFETurbulenceElementProps | null>;\nexport function $s(tagName: \"filter\", className?: string): VNodeBuilder<SVGFilterElementProps | null>;\nexport function $s(tagName: \"foreignobject\", className?: string): VNodeBuilder<SVGForeignObjectElementProps | null>;\nexport function $s(tagName: \"g\", className?: string): VNodeBuilder<SVGGElementProps | null>;\nexport function $s(tagName: \"image\", className?: string): VNodeBuilder<SVGImageElementProps | null>;\nexport function $s(tagName: \"line\", className?: string): VNodeBuilder<SVGLineElementProps | null>;\nexport function $s(tagName: \"lineargradient\", className?: string): VNodeBuilder<SVGLinearGradientElementProps | null>;\nexport function $s(tagName: \"marker\", className?: string): VNodeBuilder<SVGMarkerElementProps | null>;\nexport function $s(tagName: \"mask\", className?: string): VNodeBuilder<SVGMaskElementProps | null>;\nexport function $s(tagName: \"metadata\", className?: string): VNodeBuilder<SVGMetadataElementProps | null>;\nexport function $s(tagName: \"path\", className?: string): VNodeBuilder<SVGPathElementProps | null>;\nexport function $s(tagName: \"pattern\", className?: string): VNodeBuilder<SVGPatternElementProps | null>;\nexport function $s(tagName: \"polygon\", className?: string): VNodeBuilder<SVGPolygonElementProps | null>;\nexport function $s(tagName: \"polyline\", className?: string): VNodeBuilder<SVGPolylineElementProps | null>;\nexport function $s(tagName: \"radialgradient\", className?: string): VNodeBuilder<SVGRadialGradientElementProps | null>;\nexport function $s(tagName: \"rect\", className?: string): VNodeBuilder<SVGRectElementProps | null>;\nexport function $s(tagName: \"stop\", className?: string): VNodeBuilder<SVGStopElementProps | null>;\nexport function $s(tagName: \"svg\", className?: string): VNodeBuilder<SVGSVGElementProps | null>;\nexport function $s(tagName: \"switch\", className?: string): VNodeBuilder<SVGSwitchElementProps | null>;\nexport function $s(tagName: \"symbol\", className?: string): VNodeBuilder<SVGSymbolElementProps | null>;\nexport function $s(tagName: \"text\", className?: string): VNodeBuilder<SVGTextElementProps | null>;\nexport function $s(tagName: \"textpath\", className?: string): VNodeBuilder<SVGTextPathElementProps | null>;\nexport function $s(tagName: \"tspan\", className?: string): VNodeBuilder<SVGTSpanElementProps | null>;\nexport function $s(tagName: \"use\", className?: string): VNodeBuilder<SVGUseElementProps | null>;\nexport function $s(tagName: \"view\", className?: string): VNodeBuilder<SVGViewElementProps | null>;\nexport function $s(tagName: string, className?: string): VNodeBuilder<SVGElementProps | null> {\n    return new VNodeBuilder<SVGElementProps | null>(\n        VNodeFlags.Element | VNodeFlags.SvgElement,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\nfunction isInputTypeSupportsCheckedValue(type: InputType): boolean {\n    if (type === \"checkbox\" || type === \"radio\") {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Create a VNodeBuilder representing an HTMLInputElement node.\n *\n * @param type Input Element type. When type param has value \"textarea\", HTMLTextAreaElement will be created.\n * @param className Class name.\n * @returns VNodeBuilder object.\n */\nexport function $i(type: \"textarea\", className?: string): VNodeBuilder<HTMLTextAreaElementProps | null>;\nexport function $i(type: \"button\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"checkbox\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"color\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"date\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"datetime\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"datetime-local\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"email\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"file\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"hidden\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"image\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"month\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"number\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"password\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"radio\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"range\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"reset\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"search\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"submit\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"tel\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"text\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"time\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"url\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: \"week\", className?: string): VNodeBuilder<HTMLInputElementProps | null>;\nexport function $i(type: InputType, className?: string): VNodeBuilder<HTMLInputElementProps | null> {\n    return new VNodeBuilder<HTMLInputElementProps | null>(\n        type === \"textarea\" ?\n            VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.TextAreaElement :\n            VNodeFlags.Element | VNodeFlags.InputElement,\n        type,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\n/**\n * Create a VNodeBuilder representing an HTMLMediaElement node.\n *\n * @param tagName Media element tag name.\n * @param className Class name.\n * @returns VNodeBuilder object.\n */\nexport function $m(tagName: \"audio\", className?: string): VNodeBuilder<HTMLAudioElementProps | null>;\nexport function $m(tagName: \"video\", className?: string): VNodeBuilder<HTMLVideoElementProps | null>;\nexport function $m(tagName: \"audio\" | \"video\", className?: string): VNodeBuilder<HTMLMediaElementProps | null> {\n    return new VNodeBuilder<HTMLMediaElementProps | null>(\n        VNodeFlags.Element | VNodeFlags.MediaElement,\n        tagName,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n/* tslint:enable:max-line-length */\n\n/**\n * Create a VNodeBuilder representing a Component node.\n *\n * @param c Component factory.\n * @param props Component props.\n * @returns VNodeBuilder object.\n */\nexport function $c(c: ComponentFunction<null> | ComponentClass<null>): VNodeBuilder<null>;\nexport function $c<P>(c: ComponentFunction<P> | ComponentClass<P>, props: P): VNodeBuilder<P>;\nexport function $c<P>(c: ComponentFunction<P> | ComponentClass<P>, props?: P): VNodeBuilder<P> {\n    return new VNodeBuilder<P>(\n        (c.prototype.render) ? VNodeFlags.ComponentClass : VNodeFlags.ComponentFunction,\n        c,\n        props!,\n        null,\n        null);\n}\n\n/**\n * Create a VNodeBuilder representing an ElementDescriptor.\n *\n * @param d Element Descriptor.\n * @param className Class name.\n * @returns VNodeBuilder object.\n */\nexport function $e<P>(d: ElementDescriptor<P>, className?: string): VNodeBuilder<P> {\n    return new VNodeBuilder<P>(\n        d._flags & ElementDescriptorFlags.CopyFlags,\n        d,\n        null,\n        className === undefined ? null : className,\n        null);\n}\n\n/**\n * Perform a deep VNode cloning with DOM and Component reference erasure.\n *\n * @param node VNode to clone.\n * @returns Cloned VNode.\n */\nexport function cloneVNode(node: VNode<any>): VNode<any> {\n    const flags = node._flags;\n    let children = node._children;\n    if (children !== null) {\n        if (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray)) {\n            if (flags & VNodeFlags.ChildrenArray) {\n                children = children as VNode<any>[];\n                const newChildren = new Array<VNode<any>>(children.length);\n                for (let i = 0; i < 0; i++) {\n                    newChildren[i] = cloneVNode(children[i]);\n                }\n                children = newChildren;\n            } else {\n                children = cloneVNode(children as VNode<any>);\n            }\n        }\n    }\n\n    const newNode = new VNodeBuilder(\n        node._flags,\n        node._tag,\n        node._props,\n        node._className,\n        (node._flags & VNodeFlags.Component) ? null : children);\n    newNode._key = node._key;\n    newNode._events = node._events;\n    newNode._style = node._style;\n\n    return newNode;\n}\n\nfunction _normalizeVNodes(nodes: VNodeRecursiveArray, result: VNode<any>[], i: number): void {\n    for (; i < nodes.length; i++) {\n        const n = nodes[i];\n        if (n !== null) {\n            if (Array.isArray(n)) {\n                _normalizeVNodes(n, result, 0);\n            } else {\n                result.push(typeof n === \"object\" ? n as VNode<any> : $t(n));\n            }\n        }\n    }\n}\n\n/**\n * Normalizes recursive VNode lists by flattening all nodes, filtering out `null` children and converting strings to\n * text nodes.\n *\n * @param nodes\n * @returns Normalized VNode array.\n */\nexport function normalizeVNodes(nodes: VNodeRecursiveArray): VNode<any>[] {\n    for (let i = 0; i < nodes.length; i++) {\n        const n = nodes[i];\n\n        if (n === null || Array.isArray(n)) {\n            const result = nodes.slice(0, i) as VNode<any>[];\n            _normalizeVNodes(nodes, result, i);\n            return result;\n        } else if (typeof n !== \"object\") {\n            nodes[i] = $t(n);\n        }\n    }\n\n    return nodes as VNode<any>[];\n}\n","\n/**\n * Context.\n *\n * All Context objects should be immutable.\n *\n * Context objects will be implicitly propagated through virtual dom trees.\n *\n * @final\n */\nexport class Context {\n    /**\n     * Context data.\n     */\n    readonly data: { [key: string]: any };\n    /**\n     * Parent context.\n     *\n     * Contexts are built as a tree of immutable objects.\n     */\n    readonly from?: Context;\n\n    constructor(data: any, from?: Context) {\n        this.data = data;\n        this.from = from;\n    }\n\n    /**\n     * Find a context data.\n     *\n     * Get method supports two ways to retrieve context values:\n     *  - Retrieve value with a simple key.\n     *  - Object with a key => value mapping.\n     *\n     * Retrieving values with a simple key works by iterating through all parent contexts until it finds value,\n     * `undefined` value is returned when nothing is found.\n     *\n     * Retrieving values with key => value mapping works by iterating through all parent contexts and mapping all\n     * keys with values on the first occurence, this process goes on until it finds values for all keys.\n     *\n     * @param key Key may be a simple string, or a { [key: string]: value | undefined } object.\n     * @returns Value for the provided key if it is a simple string, or key object that was used as a key => value\n     *   mapping.\n     */\n    get<V>(key: V): V;\n    get<V>(key: string): V | undefined;\n    get<V>(key: string | V): V | undefined {\n        let n: Context | undefined = this;\n        let v: any;\n\n        if (typeof key !== \"string\") {\n            const keys = Object.keys(key) as (string | null)[];\n            let l = keys.length;\n\n            while (l > 0 && n) {\n                if (n.data) {\n                    for (let i = 0; i < keys.length; i++) {\n                        const k = keys[i];\n                        if (k) {\n                            v = n.data[k];\n                            if (v !== undefined) {\n                                (key as any)[k] = n.data[k];\n                                keys[i] = null;\n                                l--;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                n = n.from;\n            }\n\n            return key;\n        }\n\n        while (n) {\n            if (n.data) {\n                v = n.data[key];\n                if (v !== undefined) {\n                    return v as V;\n                }\n            }\n            n = n.from;\n        }\n\n        return;\n    }\n}\n\n/**\n * Root Context.\n *\n * Default Context that is used to render root nodes.\n */\nexport const ROOT_CONTEXT = new Context(undefined);\n","import { XML_NAMESPACE, XLINK_NAMESPACE } from \"../common/dom\";\nimport { VNodeFlags } from \"./flags\";\nimport { CSSStyleProps } from \"./dom_props\";\n\n/**\n * Sync DOM class names.\n *\n * @param node HTML or SVG Element.\n * @param flags VNode flags.\n * @param a Old className.\n * @param b New className.\n */\nexport function syncClassName(node: Element, flags: VNodeFlags, a: string | null, b: string | null): void {\n    if (!b) {\n        b = \"\";\n    }\n    if (flags & VNodeFlags.SvgElement) {\n        node.setAttribute(\"class\", b);\n    } else {\n        node.className = b;\n    }\n}\n\n/**\n * Sync DOM styles.\n *\n * When styles are synced, and style from the old list is missing in the new one, its value will be reassigned with a\n * `null` value.\n *\n *    a: { backgroundColor: \"#333\", color: \"#fff\" }\n *    b: { backgroundColor: \"#333\" }\n *\n * In this example `color` style will receive a `null` value.\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param a Old styles.\n * @param b New styles.\n */\nexport function syncStyle(\n    node: HTMLElement | SVGStylable,\n    a: CSSStyleProps | null,\n    b: CSSStyleProps | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n    let style: CSSStyleDeclaration;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, insert all styles from b.\n            style = node.style;\n            keys = Object.keys(b);\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                (style as any)[key] = (b as any)[key];\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all styles from a.\n        style = node.style;\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            (style as any)[keys[i]] = null;\n        }\n    } else {\n        style = node.style;\n        let matchCount = 0;\n\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            const bValue = (b as any)[key];\n\n            if (bValue !== undefined) {\n                const aValue = (a as any)[key];\n                if (aValue !== bValue) {\n                    (style as any)[key] = bValue;\n                }\n                matchCount++;\n            } else {\n                (style as any)[key] = null;\n            }\n        }\n\n        keys = Object.keys(b);\n        i = 0;\n        while (matchCount < keys.length && i < keys.length) {\n            key = keys[i++];\n            if (!a.hasOwnProperty(key)) {\n                (style as any)[key] = (b as any)[key];\n                matchCount++;\n            }\n        }\n    }\n}\n\n/**\n * Set DOM property.\n *\n * @param node HTML or SVG Element.\n * @param isSVG node is an SVG Element.\n * @param key Attribute name.\n * @param value Attribute value.\n */\nfunction setDOMProperty(node: Element, flags: VNodeFlags, key: string, value?: any, prevValue?: any): void {\n    if (flags & VNodeFlags.MediaElement) {\n        /**\n         * HTMLMediaElements has an internal state with a `volume` property, so it should be checked before an\n         * assignment to prevent unnecessary events when `volume` value is the same as the `volume` in the internal\n         * state.\n         *\n         * In general we don't want to override behaviour of DOM Elements with an internal state. Assigning props\n         * to such elements should be treated as a one-time assignment, so it works almost like `volume` attribute,\n         * except when a new value is passed down, it can override previous value when it doesn't match the previous\n         * one. There is absolutely no reasons to overcomplicate such behaviour just to make it more beatiful like it\n         * is a declarative assignment and can't be changed, because in real applications, component that controls this\n         * element will always track changes to propagate them into its own state or an external state, and when it\n         * changes it will invalidate its representation, so everything stays in-sync.\n         */\n        if (key === \"volume\") {\n            if ((node as HTMLMediaElement).volume !== value) {\n                (node as HTMLMediaElement).volume = value === undefined ? null : value;\n            }\n            return;\n        }\n    }\n\n    if (value === undefined) {\n        /**\n         * Because there is no generic way to assign a default value for a property when it is removed, it is always\n         * removed with `removeAttribute` method.\n         */\n        node.removeAttribute(key);\n    } else {\n        if (key.length > 5) {\n            if (key.charCodeAt(0) === 120 &&\n                (key.charCodeAt(3) === 58 || key.charCodeAt(5) === 58)) { // 58 === \":\" \"xml:\", \"xlink:\"\n                if (key.charCodeAt(1) === 109 && key.charCodeAt(2) === 108) { // [109, 108] === \"ml\"\n                    /**\n                     * All attributes that starts with an \"xml:\" prefix will be assigned with XML namespace.\n                     */\n                    node.setAttributeNS(XML_NAMESPACE, key, value);\n                    return;\n                } else if (key.charCodeAt(1) === 108 &&\n                    key.charCodeAt(2) === 105 &&\n                    key.charCodeAt(3) === 110 &&\n                    key.charCodeAt(4) === 107) { // [108, 105, 110, 107] === \"link\"\n                    /**\n                     * All attributes that starts with an \"xlink:\" prefix will be assigned with XLINK namespace.\n                     */\n                    node.setAttributeNS(XLINK_NAMESPACE, key, value);\n                    return;\n                }\n            } else if (key.charCodeAt(4) === 45) { // 45 === \"-\" \"data-\", \"aria-\"\n                /**\n                 * Attributes that has \"-\" character at the 4th position will be assigned with a `setAttribute` method.\n                 * It should work with \"data-\" and \"aria-\" attributes. Otherwise just use property assignment instead\n                 * of `setAttribute`.\n                 */\n                node.setAttribute(key, value);\n                return;\n            }\n        }\n\n        (node as any)[key] = value;\n    }\n}\n\n/**\n * Sync DOM properties.\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param flags VNode flags.\n * @param a Old DOM properties.\n * @param b New DOM properties.\n */\nexport function syncDOMProps(\n    node: Element,\n    flags: VNodeFlags,\n    a: { [key: string]: any } | null,\n    b: { [key: string]: any } | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, insert all attributes from b.\n            keys = Object.keys(b);\n            for (i = 0; i < keys.length; i++) {\n                key = keys[i];\n                setDOMProperty(node, flags, key, b[key]);\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all attributes from a.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            setDOMProperty(node, flags, keys[i]);\n        }\n    } else {\n        let matchCount = 0;\n\n        // Remove and update attributes.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            const bValue = b[key];\n            if (bValue === undefined) {\n                setDOMProperty(node, flags, key);\n            } else {\n                const aValue = a[key];\n                if (aValue !== bValue) {\n                    setDOMProperty(node, flags, key, bValue, aValue);\n                }\n                matchCount++;\n            }\n        }\n\n        // Insert new attributes.\n        keys = Object.keys(b);\n        i = 0;\n        while (matchCount < keys.length && i < keys.length) {\n            key = keys[i++];\n            if (!a.hasOwnProperty(key)) {\n                setDOMProperty(node, flags, key, b[key]);\n                matchCount++;\n            }\n        }\n    }\n}\n","/**\n * Miscellaneous DOM related stuff.\n */\n\nexport const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n\n/**\n * Traverses the DOM to the top and calculates DOM Node depth.\n *\n * @param node DOM Node.\n * @returns DOM Node depth.\n */\nexport function nodeDepth(node: Node | null): number {\n    let depth = 0;\n    while (node) {\n        depth++;\n        node = node.parentNode;\n    }\n    return depth;\n}\n\nexport type InputType = \"textarea\" | \"button\" | \"checkbox\" | \"color\" | \"date\" | \"datetime\" | \"datetime-local\" |\n    \"email\" | \"file\" | \"hidden\" | \"image\" | \"month\" | \"number\" | \"password\" | \"radio\" | \"range\" | \"reset\" | \"search\" |\n    \"submit\" | \"tel\" | \"text\" | \"time\" | \"url\" | \"week\";\n","import { EventHandler, EventHandlerList } from \"./event_handler\";\nimport { setEventHandlerListToDOMNode } from \"./utils\";\n\n/**\n * Shortcut for Event Handler registration.\n *\n * @param handler Event Handler.\n */\nfunction registerEventHandler(handler: EventHandler<any>): void {\n    handler.dispatcher.registerHandler(handler.fn);\n}\n\n/**\n * Shortcut for Event Handler unregistration.\n *\n * @param handler Event Handler.\n */\nfunction unregisterEventHandler(handler: EventHandler<any>): void {\n    handler.dispatcher.unregisterHandler(handler.fn);\n}\n\n/**\n * Sync DOM events.\n *\n * Implementation detail: Syncing algorithm has an optimization with an early detection of object shape changes.\n * Objects with static shape will make syncing algorithm slightly faster because it doesn't need to check which\n * properties didn't existed before, so it is possible to just use the static object shapes, and use `undefined` values\n * when you want to remove property and have the same object shape.\n *\n * @param node HTML or SVG Element.\n * @param a Old events.\n * @param b New events.\n */\nexport function syncEvents(\n    node: Element,\n    a: EventHandlerList | null,\n    b: EventHandlerList | null,\n): void {\n    let i: number;\n    let keys: string[];\n    let key: string;\n\n    if (a === null) {\n        if (b !== null) {\n            // a is empty, register all events from b.\n            keys = Object.keys(b);\n            for (i = 0; i < keys.length; i++) {\n                registerEventHandler(b[keys[i]]);\n            }\n        }\n    } else if (b === null) {\n        // b is empty, remove all events from a.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            unregisterEventHandler(a[keys[i]]);\n        }\n    } else {\n        let matchCount = 0;\n\n        // Remove and update events.\n        keys = Object.keys(a);\n        for (i = 0; i < keys.length; i++) {\n            key = keys[i];\n            const aHandler = a[key];\n            const bHandler = b[key];\n            if (bHandler !== undefined) {\n                if (aHandler !== bHandler) {\n                    registerEventHandler(bHandler);\n                    unregisterEventHandler(aHandler);\n                }\n                matchCount++;\n            } else {\n                unregisterEventHandler(aHandler);\n            }\n        }\n\n        // Insert new events.\n        keys = Object.keys(b);\n        i = 0;\n        while (matchCount < keys.length && i < keys.length) {\n            key = keys[i++];\n            if (!a.hasOwnProperty(key)) {\n                registerEventHandler(b[key]);\n                matchCount++;\n            }\n        }\n    }\n\n    setEventHandlerListToDOMNode(node, b === null ? undefined : b);\n}\n\n/**\n * Remove DOM events.\n *\n * @param node HTML or SVG Element.\n * @param a Old events.\n * @param b New events.\n */\nexport function removeEvents(events: EventHandlerList): void {\n    const keys = Object.keys(events);\n    for (let i = 0; i < keys.length; i++) {\n        unregisterEventHandler(events[keys[i]]);\n    }\n}\n","import { FEATURES, FeatureFlags } from \"../common/feature_detection\";\nimport { NativeEventDispatcherFlags } from \"./flags\";\nimport { EventHandlerList } from \"./event_handler\";\n\n/**\n * Gets the target node from a native Event.\n *\n * @param ev Native DOM Event.\n * @returns Target Node.\n */\nexport function getEventTarget(ev: Event): EventTarget {\n    let target = ev.target || window;\n\n    /**\n     * Fix for `SVGUseElement` in old browsers.\n     */\n    if ((target as any).correspondingUseElement) {\n        target = (target as any).correspondingUseElement;\n    }\n\n    /**\n     * Safari fires events on Text Nodes.\n     *\n     * http://www.quirksmode.org/js/events_properties.html\n     */\n    return (target as Node).nodeType === 3 ? (target as Node).parentNode! : target;\n}\n\n/**\n * `{ capture: true, passive: true }` object that should be used as a third parameter in `addEventListener`.\n */\nexport const EVENT_CAPTURE_PASSIVE_OPTIONS =\n    (FEATURES & FeatureFlags.PassiveEvents) ?\n        { \"capture\": true, \"passive\": true } :\n        true;\n\n/**\n * `{ passive: true }` object that should be used as a third parameter in `addEventListener`.\n */\nexport const EVENT_PASSIVE_OPTIONS =\n    (FEATURES & FeatureFlags.PassiveEvents) ?\n        { \"passive\": true } :\n        false;\n\n/**\n * Get Event options that should be used when adding Event Listener.\n *\n * @param flags See `EventDispatcherFlags` for details.\n * @returns Option object that can be used as a 3rd parameter in `addEventListener` call.\n */\nexport function getEventOptions(flags: NativeEventDispatcherFlags): boolean | { capture?: boolean, passive?: boolean } {\n    if (flags & NativeEventDispatcherFlags.Passive) {\n        if (flags & NativeEventDispatcherFlags.Capture) {\n            return EVENT_CAPTURE_PASSIVE_OPTIONS;\n        }\n        return EVENT_PASSIVE_OPTIONS;\n    }\n    if (flags & NativeEventDispatcherFlags.Capture) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Property that is used on DOM Nodes to store EventProps object.\n */\nexport const DOM_NODE_EVENTS_PROPERTY = \"_ev\";\n\n/**\n * Set Event Handler list to DOM Node.\n *\n * @param node DOM Node.\n * @param events Event Handler List.\n */\nexport function setEventHandlerListToDOMNode(node: Node, events: EventHandlerList | undefined): void {\n    (node as any)[DOM_NODE_EVENTS_PROPERTY] = events;\n}\n\n/**\n * Get Event Handler list from DOM Node.\n *\n * @param node DOM Node.\n * @returns EventHandlerList or undefined if DOM Node doesn't listen for any events.\n */\nexport function getEventHandlerListFromDOMNode(node: Node): EventHandlerList | undefined {\n    return (node as any)[DOM_NODE_EVENTS_PROPERTY];\n}\n","/**\n * DO NOT MOVE THIS FUNCTIONS TO SEPARATE MODULES!\n *\n * There are so many circular dependencies between functions in this module, so just leave it all here instead of\n * creating many circular dependencies between JS modules.\n *\n * Code in this module is working only in browser environments.\n *\n * Tags:\n *\n * #entry - Entry point, function that will be invoked just once when the reconciliation process is started with a root\n *   render, or when scheduler updates invalidated components. Entry point is a good place to inject tryCatch statements\n *   to improve stack trace messages etc.\n * #augment - Function that is used only for augmenting.\n * #component - Component related functions.\n */\n\nimport { DevModeFlags, DEV_MODE, perfMarkBegin, perfMarkEnd, getFunctionName } from \"../common/dev_mode\";\nimport { devModeOnError, devModeOnComponentCreated, devModeOnComponentDisposed } from \"../common/dev_hooks\";\nimport { injectScreenOfDeath } from \"../common/screen_of_death\";\nimport { SVG_NAMESPACE } from \"../common/dom\";\nimport {\n    setInitialNestingState, pushNestingState, restoreNestingState, checkNestingViolation, nestingStateAncestorFlags,\n    nestingStateParentTagName, AncestorFlags, AncestorFlagsByTagName,\n} from \"../common/html_nesting_rules\";\nimport { VNodeFlags, ComponentFlags } from \"./flags\";\nimport { VNode, getDOMInstanceFromVNode } from \"./vnode\";\nimport { ElementDescriptor } from \"./element_descriptor\";\nimport { cloneVNode, $t } from \"./vnode_builder\";\nimport {\n    ComponentClass, ComponentFunction, Component, registerComponent, unregisterComponent, getDOMInstanceFromComponent,\n} from \"./component\";\nimport {\n    stackTracePushComponent, stackTracePopComponent, stackTraceReset, stackTraceAugment,\n    getFunctionalComponentStackTrace,\n} from \"./stack_trace\";\nimport { Context } from \"./context\";\nimport { syncDOMProps, syncClassName, syncStyle } from \"./sync_dom\";\nimport { syncEvents, removeEvents } from \"../events/sync_events\";\n\n/**\n * Begin component perf mark.\n *\n * @param debugId\n * @param method\n */\nfunction componentPerfMarkBegin(debugId: number, method: string): void {\n    if (__IVI_DEV__) {\n        if (DEV_MODE & DevModeFlags.EnableComponentPerformanceProfiling) {\n            perfMarkBegin(`${debugId}::${method}`);\n        }\n    }\n}\n\n/**\n * End component perf mark.\n *\n * @param debugId\n * @param method\n * @param component\n */\nfunction componentPerfMarkEnd(\n    debugId: number,\n    method: string,\n    instance: false,\n    component: ComponentFunction<any>,\n): void;\nfunction componentPerfMarkEnd(\n    debugId: number,\n    method: string,\n    instance: true,\n    component: Component<any>,\n): void;\nfunction componentPerfMarkEnd(\n    debugId: number,\n    method: string,\n    instance: boolean,\n    component: Component<any> | ComponentFunction<any>,\n): void {\n    if (__IVI_DEV__) {\n        if (DEV_MODE & DevModeFlags.EnableComponentPerformanceProfiling) {\n            perfMarkEnd(\n                `${instance ? \"[C]\" : \"[F]\"}${getFunctionName(\n                    (instance ? component.constructor : component) as Function\n                )}::${method}`,\n                `${debugId}::${method}`,\n            );\n        }\n    }\n}\n\n/**\n * Traverses tree to the body and calculates `AncestorFlags`.\n *\n * @param element\n * @returns Ancestor Flags.\n */\nfunction ancestorFlags(element: Element): AncestorFlags {\n    if (__IVI_DEV__) {\n        let result = 0;\n        while (element && (element !== document.body)) {\n            result |= AncestorFlagsByTagName[element.tagName.toLowerCase()];\n            element = element.parentElement;\n        }\n        return result;\n    }\n\n    return 0;\n}\n\n/**\n * Render VNode entry point tryCatch wrapper.\n *\n * #entry\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered instance.\n */\nexport function renderVNode(\n    parent: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    if (__IVI_DEV__) {\n        if ((parent as Element).tagName) {\n            setInitialNestingState((parent as Element).tagName.toLowerCase(), ancestorFlags(parent as Element));\n        } else {\n            setInitialNestingState(\"\", 0);\n        }\n\n        try {\n            return _renderVNode(parent, refChild, vnode, context, owner);\n        } catch (e) {\n            stackTraceAugment(e);\n            devModeOnError(e);\n            injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n            stackTraceReset();\n            throw e;\n        }\n    }\n    return _renderVNode(parent, refChild, vnode, context, owner);\n}\n\n/**\n * Render VNode entry point. Renders VNode into container and invokes `didMount` lifecycle methods after VNode is\n * inserted into container.\n *\n * #entry\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction _renderVNode(\n    container: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    return vNodeRenderInto(container, refChild, vnode, context, owner);\n}\n\n/**\n * Sync VNode entry point tryCatch wrapper.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nexport function syncVNode(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    if (__IVI_DEV__) {\n        if ((parent as Element).tagName) {\n            setInitialNestingState((parent as Element).tagName.toLowerCase(), ancestorFlags(parent as Element));\n        } else {\n            setInitialNestingState(\"\", 0);\n        }\n\n        try {\n            return _syncVNode(parent, a, b, context, owner);\n        } catch (e) {\n            stackTraceAugment(e);\n            devModeOnError(e);\n            injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n            stackTraceReset();\n            throw e;\n        }\n    }\n    return _syncVNode(parent, a, b, context, owner);\n}\n\n/**\n * Sync VNode entry point. Sync VNode with a new one or replace when they aren't compatible.\n *\n * #entry\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction _syncVNode(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    return vNodeSyncOrReplace(parent, a, b, context, owner);\n}\n\n/**\n * Remove VNode entry point tryCatch wrapper.\n *\n * #entry\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nexport function removeVNode(parent: Node, node: VNode<any>): void {\n    if (__IVI_DEV__) {\n        try {\n            _removeVNode(parent, node);\n            return;\n        } catch (e) {\n            stackTraceAugment(e);\n            devModeOnError(e);\n            injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n            stackTraceReset();\n            throw e;\n        }\n    }\n    _removeVNode(parent, node);\n}\n\n/**\n * Remove VNode entry point.\n *\n * #entry\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nfunction _removeVNode(parent: Node, node: VNode<any>): void {\n    parent.removeChild(getDOMInstanceFromVNode(node) !);\n    vNodeUnmount(node);\n}\n\n/**\n * Augment entry point tryCatch wrapper.\n *\n * #entry\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nexport function augmentVNode(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): void {\n    if (__IVI_DEV__) {\n        if ((parent as Element).tagName) {\n            setInitialNestingState((parent as Element).tagName.toLowerCase(), ancestorFlags(parent as Element));\n        } else {\n            setInitialNestingState(\"\", 0);\n        }\n\n        try {\n            _augmentVNode(parent, node, vnode, context, owner);\n            return;\n        } catch (e) {\n            stackTraceAugment(e);\n            devModeOnError(e);\n            injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n            stackTraceReset();\n            throw e;\n        }\n    }\n    _augmentVNode(parent, node, vnode, context, owner);\n}\n\n/**\n * Augment entry point. Augments DOM tree with a Virtual DOM tree and performs mounting.\n *\n * #entry\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nfunction _augmentVNode(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): void {\n    vNodeAugment(parent, node, vnode, context, owner);\n}\n\n/**\n * Update Component entry point tryCatch wrapper.\n *\n * #entry\n * #component\n *\n * @param component Component to update.\n * @returns DOM Node.\n */\nexport function updateComponent<P>(component: Component<P>): void {\n    if (__IVI_DEV__) {\n        try {\n            stackTracePushComponent((component as Object).constructor as ComponentClass<any>, component);\n            _updateComponent(component);\n            stackTracePopComponent();\n            return;\n        } catch (e) {\n            stackTraceAugment(e);\n            devModeOnError(e);\n            injectScreenOfDeath(`ivi Error: ${e.message}`, e.stack);\n            stackTraceReset();\n            throw e;\n        }\n    }\n    _updateComponent(component);\n}\n\n/**\n * Update Component.\n *\n * #entry\n *\n * @param component Component to update.\n * @returns DOM Node.\n */\nfunction _updateComponent<P>(component: Component<P>): void {\n    const flags = component.flags;\n\n    if ((flags & ComponentFlags.Mounted) && (flags & ComponentFlags.Dirty)) {\n        componentPerfMarkBegin(component._debugId, \"update\");\n\n        const oldRoot = component.root!;\n        if (flags & ComponentFlags.DirtyContext) {\n            componentUpdateContext(component);\n        }\n\n        componentWillUpdate(component);\n\n        if (flags & (ComponentFlags.DirtyProps | ComponentFlags.DirtyState | ComponentFlags.UsingContext)) {\n            if (__IVI_DEV__) {\n                if ((component._parentDOMNode as Element).tagName) {\n                    setInitialNestingState((component._parentDOMNode as Element).tagName.toLowerCase(),\n                        component._ancestorFlags);\n                } else {\n                    setInitialNestingState(\"\", component._ancestorFlags);\n                }\n            }\n            const parentNode = component._parentDOMNode;\n            const newRoot = componentClassRender(component);\n            vNodeSyncOrReplace(parentNode!, oldRoot, newRoot, component._context);\n            component.flags &= ~(ComponentFlags.Dirty | ComponentFlags.InUpdateQueue);\n        } else if (oldRoot) {\n            vNodePropagateNewContext(component._parentDOMNode!, oldRoot, component._context, component);\n        }\n\n        componentDidUpdate(component);\n        componentPerfMarkEnd(component._debugId, \"update\", true, component);\n    }\n}\n\n/**\n * Update a component function.\n *\n * #component\n *\n * @param parent Parent DOM Node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current Context.\n * @param owner Owner.\n * @returns DOM Node.\n */\nfunction _updateComponentFunction(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    let instance: Node | Component<any>;\n    const fn = b._tag as ComponentFunction<any>;\n\n    componentPerfMarkBegin(b._debugId, \"update\");\n\n    if (a === b || !fn.isPropsChanged || fn.isPropsChanged(a._props, b._props)) {\n        const oldRoot = a._children as VNode<any>;\n        const newRoot = b._children = componentFunctionRender(fn, b._props, context);\n        instance = vNodeSyncOrReplace(parent, oldRoot, newRoot, context, owner);\n    } else {\n        b._children = a._children;\n        instance = a._instance!;\n    }\n\n    componentPerfMarkEnd(b._debugId, \"update\", false, fn);\n\n    b._instance = instance;\n    return instance;\n}\n\n/**\n * Recursively mount all nodes.\n *\n * @param vnode VNode.\n */\nfunction vNodeMount(vnode: VNode<any>): void {\n    const flags = vnode._flags;\n\n    if (flags & VNodeFlags.Component) {\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._instance as Component<any>;\n            stackTracePushComponent(vnode._tag as ComponentClass<any>, component);\n            componentPerfMarkBegin(component._debugId, \"mount\");\n\n            if (__IVI_DEV__) {\n                if (component.flags & ComponentFlags.Mounted) {\n                    throw new Error(\"Failed to mount Component: component is already mounted.\");\n                }\n            }\n\n            component.flags |= ComponentFlags.Mounted;\n            componentDidMount(component);\n            vNodeMount(component.root!);\n            componentPerfMarkEnd(component._debugId, \"mount\", true, component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            stackTracePushComponent(vnode._tag as ComponentFunction<any>);\n            componentPerfMarkBegin(vnode._debugId, \"mount\");\n            vNodeMount(vnode._children as VNode<any>);\n            componentPerfMarkEnd(vnode._debugId, \"mount\", false, vnode._tag as ComponentFunction<any>);\n        }\n        stackTracePopComponent();\n    } else if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n        let children = vnode._children;\n        if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n            if (flags & VNodeFlags.ChildrenArray) {\n                children = children as VNode<any>[];\n                for (let i = 0; i < children.length; i++) {\n                    vNodeMount(children[i]);\n                }\n            } else {\n                vNodeMount(children as VNode<any>);\n            }\n        }\n    }\n}\n\n/**\n * Recursively unmount all nodes.\n *\n * @param vnode VNode.\n */\nfunction vNodeUnmount(vnode: VNode<any>): void {\n    const flags = vnode._flags;\n    if (flags & VNodeFlags.Component) {\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._instance as Component<any>;\n            stackTracePushComponent(vnode._tag as ComponentClass<any>, component);\n            componentPerfMarkBegin(component._debugId, \"unmount\");\n\n            if (__IVI_DEV__) {\n                if (!(component.flags & ComponentFlags.Mounted)) {\n                    throw new Error(\"Failed to unmount Component: component is already unmounted.\");\n                }\n            }\n            vNodeUnmount(component.root!);\n            component.flags &= ~(ComponentFlags.Mounted | ComponentFlags.UpdateEachFrame);\n            componentDidUnmount(component);\n            componentPerfMarkEnd(component._debugId, \"unmount\", true, component);\n            unregisterComponent(component);\n            devModeOnComponentDisposed(component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            stackTracePushComponent(vnode._tag as ComponentFunction<any>);\n            componentPerfMarkBegin(vnode._debugId, \"unmount\");\n            vNodeUnmount(vnode._children as VNode<any>);\n            componentPerfMarkEnd(vnode._debugId, \"unmount\", false, vnode._tag as ComponentFunction<any>);\n        }\n        stackTracePopComponent();\n    } else if (flags & VNodeFlags.Element) {\n        if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n            let children = vnode._children;\n            if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n                if (flags & VNodeFlags.ChildrenArray) {\n                    children = children as VNode<any>[];\n                    for (let i = 0; i < children.length; i++) {\n                        vNodeUnmount(children[i]);\n                    }\n                } else {\n                    vNodeUnmount(children as VNode<any>);\n                }\n            }\n        }\n        if (vnode._events) {\n            removeEvents(vnode._events);\n        }\n    }\n\n    if (vnode._ref) {\n        vnode._ref(null);\n    }\n}\n\n/**\n * Unmount all nodes and its subtrees.\n *\n * @param vnodes Array of VNodes.\n */\nfunction vNodeUnmountAll(vnodes: VNode<any>[]): void {\n    for (let i = 0; i < vnodes.length; i++) {\n        vNodeUnmount(vnodes[i]);\n    }\n}\n\n/**\n * Recursively propagate new context.\n *\n * @param vnode VNode.\n * @param context New context.\n */\nfunction vNodePropagateNewContext(parent: Node, vnode: VNode<any>, context: Context, owner?: Component<any>): void {\n    const flags = vnode._flags;\n    if (flags & VNodeFlags.Component) {\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = vnode._instance as Component<any>;\n            stackTracePushComponent(vnode._tag as ComponentClass<any>, component);\n            componentPerfMarkBegin(component._debugId, \"propagateContext\");\n            componentUpdateParentContext(component, context);\n            _updateComponent(component);\n            componentPerfMarkEnd(component._debugId, \"propagateContext\", true, component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            const fn = vnode._tag as ComponentFunction<any>;\n            stackTracePushComponent(vnode._tag as ComponentFunction<any>);\n            componentPerfMarkBegin(vnode._debugId, \"propagateContext\");\n            // Optimization that checks if function is using context parameter. When function doesn't use context, it\n            // means that we can ignore re-renders when context is changed, and just propagate a new context through\n            // existing subtree.\n            if (fn.length < 2) {\n                if (vnode._children) {\n                    vNodePropagateNewContext(parent, vnode._children as VNode<any>, context, owner);\n                }\n            } else {\n                _updateComponentFunction(parent, vnode._children as VNode<any>, vnode._children as VNode<any>, context,\n                    owner);\n            }\n            componentPerfMarkEnd(vnode._debugId, \"propagateContext\", false, fn);\n        }\n        stackTracePopComponent();\n    } else if (!(flags & (VNodeFlags.InputElement | VNodeFlags.MediaElement))) {\n        let children = vnode._children;\n        if (children !== null && (flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ChildrenArray))) {\n            if (flags & VNodeFlags.ChildrenArray) {\n                children = children as VNode<any>[];\n                for (let i = 0; i < children.length; i++) {\n                    vNodePropagateNewContext(parent, children[i], context, owner);\n                }\n            } else {\n                vNodePropagateNewContext(parent, children as VNode<any>, context, owner);\n            }\n        }\n    }\n}\n\n/**\n * Move node.\n *\n * @param parent Parent DOM node.\n * @param node VNode element to move.\n * @param nextRef Reference to the next node, if it is null, node will be moved to the end.\n */\nfunction vNodeMoveChild(parent: Node, node: VNode<any>, nextRef: Node | null): void {\n    parent.insertBefore(getDOMInstanceFromVNode(node) !, nextRef!);\n}\n\n/**\n * Remove all children.\n *\n * `didUnmount` lifecycle methods will be invoked in all children and their subtrees.\n *\n * @param parent Parent DOM node.\n * @param nodes Arrays of VNodes to remove.\n */\nfunction vNodeRemoveAllChildren(parent: Node, nodes: VNode<any>[]): void {\n    parent.textContent = \"\";\n    vNodeUnmountAll(nodes);\n}\n\n/**\n * Remove child.\n *\n * `didUnmount` lifecycle methods will be invoked in removed node and its subtree.\n *\n * @param parent Parent DOM node.\n * @param node VNode element to remove.\n */\nfunction vNodeRemoveChild(parent: Node, node: VNode<any>): void {\n    parent.removeChild(getDOMInstanceFromVNode(node) !);\n    vNodeUnmount(node);\n}\n\n/**\n * Assign a new parent context to a component.\n *\n * Reference equality is used to check if context is changed, all context objects should be immutable.\n *\n * #component\n *\n * @param component Component.\n * @param newContext New Context to assign.\n */\nfunction componentUpdateParentContext<P>(component: Component<P>, newParentContext: Context): void {\n    if (component._parentContext !== newParentContext) {\n        component.flags |= ComponentFlags.DirtyContext;\n        const oldContext = component._parentContext;\n        component._parentContext = newParentContext;\n        component.didReceiveNewContext(oldContext, newParentContext);\n    }\n}\n\n/**\n * Update current context of a component.\n *\n * #component\n *\n * @param component Component.\n */\nfunction componentUpdateContext<P>(component: Component<P>): void {\n    component.flags &= ~(ComponentFlags.CheckUsingProps | ComponentFlags.ContextUsingProps);\n    const contextData = component.updateContext();\n    component.flags |= (component.flags & ComponentFlags.CheckUsingProps) << 1;\n    const newContext = contextData ? new Context(contextData, component._parentContext) : component._parentContext;\n    component._context = newContext;\n}\n\n/**\n * Assign a new props to a component.\n *\n * #component\n *\n * @param component Component.\n * @param newProps New props to assign.\n */\nfunction componentUpdateProps<P>(component: Component<P>, newProps: P): void {\n    const oldProps = component._props;\n    if (component.isPropsChanged(oldProps, newProps)) {\n        component.flags |= ComponentFlags.DirtyProps;\n\n        component._props = newProps;\n\n        // There is no reason to call `didReceiveNewProps` when props aren't changed, even when they are reassigned\n        // later to reduce memory usage.\n        component.didReceiveNewProps(oldProps, newProps);\n        if (component.flags & ComponentFlags.ContextUsingProps) {\n            component.flags |= ComponentFlags.DirtyContext;\n        }\n    } else {\n        // Reassign props even when they aren't changed to reduce overall memory usage.\n        //\n        // New value always stays alive because it is referenced from virtual dom tree, so instead of keeping in memory\n        // two values even when they are the same, we just always reassign it to the new value.\n        component._props = newProps;\n    }\n}\n\n/**\n * Invoke `component.willUpdate` method.\n *\n * #component\n *\n * @param component\n */\nfunction componentWillUpdate<P>(component: Component<P>): void {\n    component.willUpdate();\n}\n\n/**\n * Invoke `component.didUpdate` method.\n *\n * #component\n *\n * @param component\n */\nfunction componentDidUpdate<P>(component: Component<P>): void {\n    component.didUpdate();\n}\n\n/**\n * Invoke `component.didMount` method.\n *\n * #component\n *\n * @param component\n */\nfunction componentDidMount<P>(component: Component<P>): void {\n    component.didMount();\n}\n\n/**\n * Invoke `component.didMount` method.\n *\n * #component\n *\n * @param component\n */\nfunction componentDidUnmount<P>(component: Component<P>): void {\n    component.didUnmount();\n}\n\n/**\n * Render a component class instance and return root VNode.\n *\n * #component\n *\n * @param component Component.\n * @returns Root VNode.\n */\nfunction componentClassRender<P>(component: Component<P>): VNode<any> {\n    component.flags &= ~(ComponentFlags.CheckUsingContext | ComponentFlags.UsingContext);\n    const root = component.root = component.render() || $t(\"\");\n    component.flags |= (component.flags & ComponentFlags.CheckUsingContext) << 1;\n    return root;\n}\n\n/**\n * Render a component function instance and return root VNode.\n *\n * #component\n *\n * @param component Component function.\n * @param props Props.\n * @param context Context.\n * @returns Root VNode.\n */\nfunction componentFunctionRender<P>(component: ComponentFunction<P>, props: P, context?: Context): VNode<any> {\n    return component(props, context) || $t(\"\");\n}\n\n/**\n * Set value for HTMLInputElement.\n *\n * When value has a string type it is assigned to `value` property, otherwise it is assigned to `checked` property.\n *\n * @param input HTMLInputElement.\n * @param value Value.\n */\nfunction setHTMLInputValue(input: HTMLInputElement, value: string | boolean | null): void {\n    if (typeof value === \"string\") {\n        input.value = value;\n    } else {\n        input.checked = value as boolean;\n    }\n}\n\n/**\n * Render VNode.\n *\n * @param parent Parent DOM Node.\n * @param vnode VNode to render.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction vNodeRender(parent: Node, vnode: VNode<any>, context: Context, owner?: Component<any>): Node | Component<any> {\n    // if VNode already has an instance, perform a deep clone\n    if (vnode._instance) {\n        vnode = cloneVNode(vnode);\n    }\n\n    const flags = vnode._flags;\n    let instance: Node | Component<any>;\n    let childInstance: Node | Component<any>;\n    let i: number;\n    let child: VNode<any>;\n\n    if (flags & (VNodeFlags.Text | VNodeFlags.Element)) {\n        // Push nesting state and check for nesting violation.\n        const _prevNestingStateParentTagName = nestingStateParentTagName();\n        const _prevNestingStateAncestorFlags = nestingStateAncestorFlags();\n\n        if (flags & VNodeFlags.Text) {\n            pushNestingState(\"$t\");\n            checkNestingViolation();\n            instance = document.createTextNode(vnode._children as string);\n        } else { // (flags & VNodeFlags.Element)\n            pushNestingState((flags & VNodeFlags.ElementDescriptor) ?\n                (vnode._tag as ElementDescriptor<any>)._tagName :\n                vnode._tag as string);\n            checkNestingViolation();\n            if (flags & VNodeFlags.ElementDescriptor) {\n                instance = (vnode._tag as ElementDescriptor<any>).createElement();\n            } else if (flags & VNodeFlags.InputElement) {\n                if (flags & VNodeFlags.TextAreaElement) {\n                    instance = document.createElement(\"textarea\");\n                } else {\n                    instance = document.createElement(\"input\");\n                    (instance as HTMLInputElement).type = vnode._tag as string;\n                }\n            } else if (flags & VNodeFlags.SvgElement) {\n                instance = document.createElementNS(SVG_NAMESPACE, vnode._tag as string);\n            } else {\n                instance = document.createElement(vnode._tag as string);\n            }\n\n            if (vnode._props) {\n                syncDOMProps(instance as Element, flags, null, vnode._props);\n            }\n            if (vnode._className !== null) {\n                syncClassName(instance as Element, flags, null, vnode._className);\n            }\n            if (vnode._style !== null) {\n                syncStyle(instance as HTMLElement, null, vnode._style);\n            }\n            if (vnode._events) {\n                syncEvents(instance as Element, null, vnode._events);\n            }\n\n            let children = vnode._children;\n            if (children !== null) {\n                if (flags & (VNodeFlags.ChildrenBasic | VNodeFlags.ChildrenArray)) {\n                    if (flags & VNodeFlags.ChildrenBasic) {\n                        instance.textContent = children as string;\n                    } else {\n                        children = children as VNode<any>[];\n                        for (i = 0; i < children.length; i++) {\n                            child = children[i];\n                            childInstance = vNodeRender(instance, child, context, owner);\n\n                            instance.insertBefore(\n                                (child._flags & VNodeFlags.ComponentClass) ?\n                                    getDOMInstanceFromComponent(childInstance as Component<any>) :\n                                    childInstance as Node,\n                                null);\n                        }\n                    }\n                } else if (flags & VNodeFlags.ChildrenVNode) {\n                    child = children as VNode<any>;\n                    childInstance = vNodeRender(instance, child, context, owner);\n                    instance.insertBefore(\n                        (child._flags & VNodeFlags.ComponentClass) ?\n                            getDOMInstanceFromComponent(childInstance as Component<any>) :\n                            childInstance as Node,\n                        null);\n                } else if (flags & VNodeFlags.InputElement) {\n                    setHTMLInputValue(instance as HTMLInputElement, children as string | boolean);\n                } else { // (flags & VNodeFlags.UnsafeHTML)\n                    (instance as Element).innerHTML = children as string;\n                }\n            }\n        }\n\n        restoreNestingState(_prevNestingStateParentTagName, _prevNestingStateAncestorFlags);\n    } else { // (flags & VNodeFlags.Component)\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = instance = new (vnode._tag as ComponentClass<any>)(vnode._props, context, owner);\n            registerComponent(component);\n            devModeOnComponentCreated(component);\n            stackTracePushComponent(vnode._tag as ComponentClass<any>, component);\n            componentPerfMarkBegin(component._debugId, \"create\");\n            if (__IVI_DEV__) {\n                component._ancestorFlags = nestingStateAncestorFlags();\n                component._stackTrace = getFunctionalComponentStackTrace();\n            }\n            component._parentDOMNode = parent;\n            componentUpdateContext(component);\n            const root = componentClassRender(component);\n            vNodeRender(parent, root, component._context, component);\n            componentPerfMarkEnd(component._debugId, \"create\", true, component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            stackTracePushComponent(vnode._tag as ComponentFunction<any>);\n            componentPerfMarkBegin(vnode._debugId, \"create\");\n            const root = vnode._children =\n                componentFunctionRender(vnode._tag as ComponentFunction<any>, vnode._props, context);\n            instance = vNodeRender(parent, root, context, owner);\n            componentPerfMarkEnd(vnode._debugId, \"create\", false, vnode._tag as ComponentFunction<any>);\n        }\n        stackTracePopComponent();\n    }\n\n    vnode._instance = instance;\n    if (vnode._ref) {\n        vnode._ref(instance);\n    }\n\n    return instance;\n}\n\n/**\n * Render VNode into container and invoke `didMount` lifecycle methods after VNode is inserted into container.\n *\n * It is important that `didMount` methods are invoked only after DOM Nodes have been inserted into container, so it\n * goes twice through the entire vnode tree, first time when everything is rendered and the second time when `didMount`\n * methods are invoked.\n *\n * @param container Container Node.\n * @param refChild Reference to the next Node, when it is `null` child will be inserted at the end.\n * @param vnode VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Rendered DOM Node.\n */\nfunction vNodeRenderInto(\n    container: Node,\n    refChild: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    const instance = vNodeRender(container, vnode, context, owner);\n    container.insertBefore(getDOMInstanceFromVNode(vnode) !, refChild);\n    vNodeMount(vnode);\n    return instance;\n}\n\n/**\n * Get non-comment DOM Node. This function removes all comment DOM Nodes when searching for non-comment nodes.\n *\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @returns Non-comment DOM Node.\n */\nfunction getNonCommentNode(parent: Node, node: Node | null): Node | null {\n    while (node && node.nodeType === 8) {\n        const next = node.nextSibling;\n        parent.removeChild(node);\n        node = next;\n    }\n    return node;\n}\n\n/**\n * Augment DOM Node with a Virtual DOM Node.\n *\n * #augment\n *\n * @param parent Parent DOM Node.\n * @param node DOM Node.\n * @param vnode Virtual DOM Node.\n * @param context Context.\n * @param owner Owner.\n */\nfunction vNodeAugment(\n    parent: Node,\n    node: Node | null,\n    vnode: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    // if VNode already has a reference to a DOM Node, perform a deep clone of vnodes\n    if (vnode._instance) {\n        vnode = cloneVNode(vnode);\n    }\n\n    let instance: Node | Component<any>;\n\n    if (node) {\n        const flags = vnode._flags;\n\n        if (flags & (VNodeFlags.Element | VNodeFlags.Text)) {\n            // Push nesting state and check for nesting violation.\n            const _prevNestingStateParentTagName = nestingStateParentTagName();\n            const _prevNestingStateAncestorFlags = nestingStateAncestorFlags();\n\n            instance = node;\n\n            if (flags & VNodeFlags.Element) {\n                if (__IVI_DEV__) {\n                    pushNestingState((flags & VNodeFlags.ElementDescriptor) ?\n                        (vnode._tag as ElementDescriptor<any>)._tagName :\n                        vnode._tag as string);\n                    checkNestingViolation();\n                    if (node.nodeType !== 1) {\n                        throw new Error(`Invalid node type: expected \"1\", actual \"${node.nodeType}\".`);\n                    }\n                    if (vnode._className) {\n                        const className = (node as Element).getAttribute(\"class\");\n                        if (className !== vnode._className) {\n                            throw new Error(`Invalid class name: expected \"${vnode._className}\", ` +\n                                `actual \"${className}\".`);\n                        }\n                    }\n                    // We can't check any style properties, because browsers ignore style names they don't understand,\n                    // like style names with browser specific prefixes.\n                    if (vnode._children === null) {\n                        if (node.hasChildNodes()) {\n                            throw new Error(`Invalid children: expected \"0\" children, ` +\n                                `actual \"${node.childNodes.length}\".`);\n                        }\n                    }\n                }\n\n                if (vnode._events) {\n                    syncEvents(node as Element, null, vnode._events);\n                }\n\n                if (vnode._children !== null) {\n                    if (flags & (VNodeFlags.ChildrenArray | VNodeFlags.ChildrenVNode)) {\n                        let domChild = getNonCommentNode(node, node.firstChild);\n                        if (flags & VNodeFlags.ChildrenArray) {\n                            const children = vnode._children as VNode<any>[];\n                            for (let i = 0; i < children.length; i++) {\n                                if (__IVI_DEV__) {\n                                    if (domChild === null) {\n                                        throw new Error(`Invalid children: expected to find ${children.length} ` +\n                                            `children nodes.`);\n                                    }\n                                }\n                                vNodeAugment(node, domChild, children[i], context, owner);\n                                domChild = getNonCommentNode(node, domChild!.nextSibling);\n                            }\n                            if (__IVI_DEV__) {\n                                if (getNonCommentNode(node, domChild) !== null) {\n                                    throw new Error(`Invalid children: document contains more children nodes than ` +\n                                        `expected.`);\n                                }\n                            }\n                        } else {\n                            if (__IVI_DEV__) {\n                                if (domChild === null) {\n                                    throw new Error(`Invalid children: expected to find 1 child node.`);\n                                }\n                                if (getNonCommentNode(node, domChild.nextSibling) !== null) {\n                                    throw new Error(`Invalid children: document contains more children nodes than ` +\n                                        `expected.`);\n                                }\n                            }\n                            vNodeAugment(node, domChild, vnode._children as VNode<any>, context, owner);\n                        }\n\n                    } else if (flags & VNodeFlags.InputElement) {\n                        // Do not override input value when augmenting.\n                        //\n                        // TODO: What should be the default behavior when input element is changed before scripts\n                        // are loaded. Maybe we should fire onInput event, is synthetic event enough, or it should be\n                        // a native event?\n                        //\n                        // setHTMLInputValue(node as HTMLInputElement, vnode._children as string | boolean);\n                    }\n                }\n            } else if (__IVI_DEV__) { // (flags & VNodeFlags.Text)\n                pushNestingState(\"$t\");\n                checkNestingViolation();\n\n                if (node.nodeType !== 3) {\n                    throw new Error(`Invalid node type: expected \"3\", actual \"${node.nodeType}\".`);\n                }\n                if (node.nodeValue !== (vnode._children as number | boolean | string).toString()) {\n                    throw new Error(`Invalid text content: expected \"${vnode._children}\", actual \"${node.nodeValue}\".`);\n                }\n            }\n\n            restoreNestingState(_prevNestingStateParentTagName, _prevNestingStateAncestorFlags);\n        } else { // (flags & VNodeFlags.Component)\n            if (flags & VNodeFlags.ComponentClass) {\n                const component = instance = new (vnode._tag as ComponentClass<any>)(vnode._props, context, owner);\n                registerComponent(component);\n                devModeOnComponentCreated(component);\n                stackTracePushComponent(vnode._tag as ComponentClass<any>, component);\n\n                if (__IVI_DEV__) {\n                    component._ancestorFlags = nestingStateAncestorFlags();\n                    component._stackTrace = getFunctionalComponentStackTrace();\n                }\n\n                component._parentDOMNode = parent;\n                componentUpdateContext(component);\n                const root = componentClassRender(component);\n                vNodeAugment(parent, node, root, component._context, component);\n            } else {\n                stackTracePushComponent(vnode._tag as ComponentFunction<any>);\n                const root = vnode._children =\n                    componentFunctionRender(vnode._tag as ComponentFunction<any>, vnode._props, context);\n                instance = vNodeAugment(parent, node, root, context, owner);\n            }\n\n            stackTracePopComponent();\n        }\n    } else {\n        instance = vNodeRenderInto(parent, null, vnode, context, owner);\n    }\n\n    vnode._instance = instance;\n    if (vnode._ref) {\n        vnode._ref(instance);\n    }\n\n    return instance;\n}\n\n/**\n * Check if two nodes can be synced.\n *\n * Two nodes can be synced when their flags and tags are identical.\n *\n * @param a Old VNode.\n * @param b New VNode.\n * @return true if nodes can be synced.\n */\nfunction vNodeCanSync(a: VNode<any>, b: VNode<any>): boolean {\n    return ((a._flags & VNodeFlags.Syncable) === (b._flags & VNodeFlags.Syncable) &&\n        a._tag === b._tag &&\n        a._key === b._key);\n}\n\n/**\n * Sync two VNodes.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction vNodeSync(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    if (a === b) {\n        return b._instance!;\n    }\n\n    if (b._instance) {\n        b = cloneVNode(b);\n    }\n\n    const flags = a._flags;\n    let instance: Node | Component<any> | undefined;\n\n    if (flags & (VNodeFlags.Text | VNodeFlags.Element)) {\n        instance = b._instance = a._instance!;\n\n        if (flags & VNodeFlags.Text) {\n            if (a._children !== b._children) {\n                (instance as Text).nodeValue = b._children as string;\n            }\n        } else { // (flags & VNodeFlags.Element)\n            if (a._props !== b._props) {\n                syncDOMProps(instance as Element, flags, a._props, b._props);\n            }\n            if (a._className !== b._className) {\n                syncClassName(instance as Element, flags, a._className, b._className);\n            }\n            if (a._style !== b._style) {\n                syncStyle(instance as HTMLElement, a._style, b._style);\n            }\n            if (a._events !== b._events) {\n                syncEvents(instance as HTMLElement, a._events, b._events);\n            }\n\n            if (a._children !== b._children) {\n                syncChildren(\n                    instance as Element,\n                    a._flags,\n                    b._flags,\n                    a._children as VNode<any>[] | VNode<any> | string | number | boolean,\n                    b._children as VNode<any>[] | VNode<any> | string | number | boolean,\n                    context,\n                    owner);\n            }\n        }\n    } else { // (flags & VNodeFlags.Component)\n        if (flags & VNodeFlags.ComponentClass) {\n            const component = instance = b._instance = a._instance as Component<any>;\n            stackTracePushComponent(b._tag as ComponentClass<any>, component);\n            componentUpdateProps(component, b._props);\n            componentUpdateParentContext(component, context);\n            _updateComponent(component);\n        } else { // (flags & VNodeFlags.ComponentFunction)\n            stackTracePushComponent(b._tag as ComponentFunction<any>);\n            instance = b._instance = _updateComponentFunction(parent, a, b, context, owner);\n        }\n        stackTracePopComponent();\n    }\n\n    return instance;\n}\n\n/**\n * Sync VNode with a new one or replace when they aren't compatible.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent Parent node.\n * @param a Old VNode.\n * @param b New VNode.\n * @param context Current context.\n * @param owner Owning component.\n * @returns Synced DOM Node. When VNodes are synced and they aren't compatible, old DOM Node will be replaced with a new\n * DOM Node.\n */\nfunction vNodeSyncOrReplace(\n    parent: Node,\n    a: VNode<any>,\n    b: VNode<any>,\n    context: Context,\n    owner?: Component<any>,\n): Node | Component<any> {\n    if (vNodeCanSync(a, b)) {\n        return vNodeSync(parent, a, b, context, owner);\n    }\n    const newInstance = vNodeRender(parent, b, context, owner);\n    parent.replaceChild(\n        (b._flags & VNodeFlags.ComponentClass) ?\n            getDOMInstanceFromComponent(newInstance as Component<any>) :\n            newInstance as Element, getDOMInstanceFromVNode(a) !);\n    vNodeUnmount(a);\n    vNodeMount(b);\n    return newInstance;\n}\n\n/**\n * Sync old children list with the new one.\n *\n * @param parent Parent node.\n * @param aParentFlags Old parent VNode flags.\n * @param bParentFlags New parent VNode flags.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildren(\n    parent: Node,\n    aParentFlags: VNodeFlags,\n    bParentFlags: VNodeFlags,\n    a: VNode<any>[] | VNode<any> | string | number | boolean,\n    b: VNode<any>[] | VNode<any> | string | number | boolean,\n    context: Context,\n    owner: Component<any> | undefined,\n): void {\n    let i = 0;\n\n    if (a === null) {\n        if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.ChildrenArray)) {\n            if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                parent.textContent = b as string;\n            } else {\n                b = b as VNode<any>[];\n                for (i = 0; i < b.length; i++) {\n                    vNodeRenderInto(parent, null, b[i], context, owner);\n                }\n            }\n        } else if (bParentFlags & VNodeFlags.ChildrenVNode) {\n            vNodeRenderInto(parent, null, b as VNode<any>, context, owner);\n        } else if (bParentFlags & VNodeFlags.InputElement) {\n            setHTMLInputValue(parent as HTMLInputElement, b as string | boolean);\n        } else { // (bParentFlags & VNodeFlags.UnsafeHTML)\n            (parent as Element).innerHTML = b as string;\n        }\n    } else if (b === null) {\n        if (aParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n            parent.textContent = \"\";\n        } else if (aParentFlags & VNodeFlags.ChildrenArray) {\n            vNodeRemoveAllChildren(parent, a as VNode<any>[]);\n        } else if (aParentFlags & VNodeFlags.ChildrenVNode) {\n            vNodeRemoveChild(parent, a as VNode<any>);\n        } else { // (bParentFlags & VNodeFlags.InputElement)\n            if (typeof a === \"string\") {\n                (parent as HTMLInputElement).value = \"\";\n            } else {\n                (parent as HTMLInputElement).checked = false;\n            }\n        }\n    } else {\n        if (aParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    const c = parent.firstChild;\n                    if (c) {\n                        c.nodeValue = b as string;\n                    } else {\n                        parent.textContent = b as string;\n                    }\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n            } else {\n                parent.textContent = \"\";\n                if (bParentFlags & VNodeFlags.ChildrenArray) {\n                    b = b as VNode<any>[];\n                    for (i = 0; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    vNodeRenderInto(parent, null, b as VNode<any>, context, owner);\n                }\n            }\n        } else if (aParentFlags & VNodeFlags.ChildrenArray) {\n            a = a as VNode<any>[];\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    parent.textContent = b as string;\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n                vNodeUnmountAll(a);\n            } else if (bParentFlags & VNodeFlags.ChildrenArray) {\n                b = b as VNode<any>[];\n                if (a.length === 0) {\n                    for (i = 0; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    if (b.length === 0) {\n                        vNodeRemoveAllChildren(parent, a);\n                    } else if (a.length === 1 && b.length === 1) {\n                        vNodeSyncOrReplace(parent, a[0], b[0], context, owner);\n                    } else {\n                        if (aParentFlags & bParentFlags & VNodeFlags.TrackByKeyChildren) {\n                            syncChildrenTrackByKeys(parent, a, b, context, owner);\n                        } else {\n                            syncChildrenNaive(parent, a, b, context, owner);\n                        }\n                    }\n                }\n            } else {\n                b = b as VNode<any>;\n                if (a.length > 0) {\n                    vNodeSyncOrReplace(parent, a[0], b, context, owner);\n                    for (i = 1; i < a.length; i++) {\n                        vNodeRemoveChild(parent, a[i]);\n                    }\n                } else {\n                    vNodeRenderInto(parent, null, b, context, owner);\n                }\n            }\n        } else if (aParentFlags & VNodeFlags.ChildrenVNode) {\n            a = a as VNode<any>;\n            if (bParentFlags & (VNodeFlags.ChildrenBasic | VNodeFlags.UnsafeHTML)) {\n                if (bParentFlags & VNodeFlags.ChildrenBasic) {\n                    parent.textContent = b as string;\n                } else {\n                    (parent as Element).innerHTML = b as string;\n                }\n                vNodeUnmount(a);\n            } else if (bParentFlags & VNodeFlags.ChildrenArray) {\n                b = b as VNode<any>[];\n                if (b.length > 0) {\n                    vNodeSyncOrReplace(parent, a, b[0], context, owner);\n                    for (i = 1; i < b.length; i++) {\n                        vNodeRenderInto(parent, null, b[i], context, owner);\n                    }\n                } else {\n                    vNodeRemoveChild(parent, a);\n                }\n            } else {\n                vNodeSyncOrReplace(parent, a, b as VNode<any>, context, owner);\n            }\n        } else { // (aParentFlags & VNodeFlags.InputElement)\n            if (typeof b === \"string\") {\n                if ((parent as HTMLInputElement).value !== b) {\n                    (parent as HTMLInputElement).value = b;\n                }\n            } else {\n                (parent as HTMLInputElement).checked = b as boolean;\n            }\n        }\n    }\n}\n\n/**\n * Sync children naive way.\n *\n * Any heuristics that is used in this algorithm is an undefined behaviour, and external dependencies should not rely on\n * any knowledge about this algorithm, because it can be changed in any time.\n *\n * This naive algorithm is quite simple:\n *\n *  A: -> [a a c d e g g] <-\n *  B: -> [a a f d c g] <-\n *\n * It starts by iterating over old children list `A` and new children list `B` from both ends.\n *\n *  A: -> [a b c d e g g] <-\n *  B: -> [a b f d c g] <-\n *\n * When it find nodes that have the same key, tag and flags, it will sync them. Node \"a\" and \"b\" on the right side, and\n * node \"g\" on the right side will be synced.\n *\n *  A: -> [c d e g]\n *  B: -> [f d c]\n *\n * Then it start iterating over old and new children lists from the left side and check if nodes can be synced. Nodes\n * \"c\" and \"f\" can't be synced, remove node \"c\" and insert new node \"f\".\n *\n *  A: -> [d e g]\n *  B: -> [d c]\n *\n * Node \"d\" is synced.\n *\n *  A: -> [e g]\n *  B: -> [c]\n *\n * Node \"e\" removed, node \"c\" inserted.\n *\n *  A: -> [g]\n *  B:    []\n *\n * Length of the old list is larger than length of the new list, remove remaining nodes from the old list.\n *\n * @param parent Parent node.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildrenNaive(\n    parent: Node,\n    a: VNode<any>[],\n    b: VNode<any>[],\n    context: Context,\n    owner?: Component<any>,\n): void {\n    let aStart = 0;\n    let bStart = 0;\n    let aEnd = a.length - 1;\n    let bEnd = b.length - 1;\n    let aNode: VNode<any>;\n    let bNode: VNode<any>;\n    let nextPos: number;\n    let next: Node | null;\n\n    // Sync similar nodes at the beginning.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aStart];\n        bNode = b[bStart];\n\n        if (!vNodeCanSync(aNode, bNode)) {\n            break;\n        }\n\n        aStart++;\n        bStart++;\n\n        vNodeSync(parent, aNode, bNode, context, owner);\n    }\n\n    // Sync similar nodes at the end.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n\n        if (!vNodeCanSync(aNode, bNode)) {\n            break;\n        }\n\n        aEnd--;\n        bEnd--;\n\n        vNodeSync(parent, aNode, bNode, context, owner);\n    }\n\n    // Iterate over the remaining nodes and if they have the same type, then sync, otherwise just\n    // remove the old node and insert the new one.\n    while (aStart <= aEnd && bStart <= bEnd) {\n        aNode = a[aStart++];\n        bNode = b[bStart++];\n        vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n    }\n\n    if (aStart <= aEnd) {\n        // All nodes from a are synced, remove the rest.\n        do {\n            vNodeRemoveChild(parent, a[aStart++]);\n        } while (aStart <= aEnd);\n    } else if (bStart <= bEnd) {\n        // All nodes from b are synced, insert the rest.\n        nextPos = bEnd + 1;\n        next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n        do {\n            vNodeRenderInto(parent, next, b[bStart++], context, owner);\n        } while (bStart <= bEnd);\n    }\n}\n\n/**\n * Sync children with track by keys algorithm.\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix, and perform simple moves on the edges.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a b f d c g] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"g\" at the end.\n *\n *  A: -> [c d e f] <-\n *  B: -> [f d c] <-\n *\n * At this position it will try to look at the opposite edge, and if there is a node with the same key at the opposite\n * edge, it will perform simple move operation. Node \"c\" is moved to the right edge, and node \"f\" is moved to the left\n * edge.\n *\n *  A: -> [d e] <-\n *  B: -> [d] <-\n *\n * Now it will try again to find common prefix and suffix, node \"d\" is the same, so we can skip it.\n *\n *  A: [e]\n *  B: []\n *\n * Here it will check if the size of one of the list is equal to zero, and if length of the old children list is zero,\n * it will insert all remaining nodes from the new list, or if length of the new children list is zero, it will remove\n * all remaining nodes from the old list.\n *\n * This simple optimization technique will cover most of the real world use cases, even reversing the children list,\n * except for sorting.\n *\n * When algorithm couldn't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * That is how children reconciliation algorithm is working in one of the fastest virtual dom libraries :)\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here. Naive algo\n * and simple 1/N, N/1 cases are using replace op.\n *\n * @param parent Parent node.\n * @param a Old VNode list.\n * @param b New VNode list.\n * @param context Current context.\n * @param owner Owning component.\n */\nfunction syncChildrenTrackByKeys(\n    parent: Node,\n    a: VNode<any>[],\n    b: VNode<any>[],\n    context: Context,\n    owner?: Component<any>,\n): void {\n    let aStart = 0;\n    let bStart = 0;\n    let aEnd = a.length - 1;\n    let bEnd = b.length - 1;\n    let aStartNode = a[aStart];\n    let bStartNode = b[bStart];\n    let aEndNode = a[aEnd];\n    let bEndNode = b[bEnd];\n    let i: number;\n    let j: number | undefined;\n    let nextPos: number;\n    let next: Node | null;\n    let aNode: VNode<any> | null;\n    let bNode: VNode<any>;\n    let node: VNode<any>;\n\n    // Check that items without keys at the beginning and at the end doesn't change their shape.\n    if (__IVI_DEV__) {\n        outer: while (true) {\n            while (aStartNode._key === null) {\n                if (bStartNode._key !== null) {\n                    throw new Error(\"Invalid children list, when trackByKey is enabled, nodes without keys shouldn't \" +\n                        \"change their shape.\");\n                }\n                aStart++;\n                bStart++;\n                if (aStart > aEnd || bStart > bEnd) {\n                    break outer;\n                }\n                aStartNode = a[aStart];\n                bStartNode = b[bStart];\n            }\n\n            if (bStartNode._key === null) {\n                throw new Error(\"Invalid children list, when trackByKey is enabled, nodes without keys shouldn't \" +\n                    \"change their shape.\");\n            }\n\n            while (aEndNode._key === null) {\n                if (bEndNode._key !== null) {\n                    throw new Error(\"Invalid children list, when trackByKey is enabled, nodes without keys shouldn't \" +\n                        \"change their shape.\");\n                }\n                aEnd--;\n                bEnd--;\n                if (aStart > aEnd || bStart > bEnd) {\n                    break outer;\n                }\n                aEndNode = a[aEnd];\n                bEndNode = b[bEnd];\n            }\n\n            if (bEndNode._key === null) {\n                throw new Error(\"Invalid children list, when trackByKey is enabled, nodes without keys shouldn't \" +\n                    \"change their shape.\");\n            }\n\n            break;\n        }\n\n        // restore variables after checking.\n        aStart = 0;\n        bStart = 0;\n        aEnd = a.length - 1;\n        bEnd = b.length - 1;\n        aStartNode = a[aStart];\n        bStartNode = b[bStart];\n        aEndNode = a[aEnd];\n        bEndNode = b[bEnd];\n    }\n\n    // Step 1\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode._key === bStartNode._key) {\n            vNodeSyncOrReplace(parent, aStartNode, bStartNode, context, owner);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n        }\n\n        // Sync nodes with the same key at the end.\n        while (aEndNode._key === bEndNode._key) {\n            vNodeSyncOrReplace(parent, aEndNode, bEndNode, context, owner);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n        }\n\n        // Move and sync nodes from right to left.\n        if (aEndNode._key === bStartNode._key) {\n            vNodeSyncOrReplace(parent, aEndNode, bStartNode, context, owner);\n            vNodeMoveChild(parent, bStartNode, getDOMInstanceFromVNode(aStartNode));\n            aEnd--;\n            bStart++;\n            // There is no need to check when we out of bounds, because the only way we can get here is when there are\n            // more nodes in the lists.\n            //\n            // Impossible transformations:\n            //   [a] => [a b] (common prefix)\n            //   [b a] => [a] (common suffix)\n            //\n            // Possible transformations:\n            //   [b a] => [a b]\n            //   [b a] => [a c]\n\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            // In a real-world scenarios there is a higher chance that next node after the move will be the same, so we\n            // immediately jump to the start of this prefix/suffix algo.\n            continue;\n        }\n\n        // Move and sync nodes from left to right.\n        if (aStartNode._key === bEndNode._key) {\n            vNodeSyncOrReplace(parent, aStartNode, bEndNode, context, owner);\n            nextPos = bEnd + 1;\n            next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n            vNodeMoveChild(parent, bEndNode, next);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            continue;\n        }\n\n        break;\n    }\n\n    if (aStart > aEnd) {\n        // All nodes from a are synced, insert the rest from b.\n        nextPos = bEnd + 1;\n        next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n        while (bStart <= bEnd) {\n            vNodeRenderInto(parent, next, b[bStart++], context, owner);\n        }\n    } else if (bStart > bEnd) {\n        // All nodes from b are synced, remove the rest from a.\n        while (aStart <= aEnd) {\n            vNodeRemoveChild(parent, a[aStart++]);\n        }\n        // Step 2\n    } else {\n        let aLength = aEnd - aStart + 1;\n        let bLength = bEnd - bStart + 1;\n        const aNullable = a as Array<VNode<any> | null>; // will be removed by js optimizing compilers.\n        // Mark all nodes as inserted.\n        const sources = new Array<number>(bLength).fill(-1);\n\n        let moved = false;\n        let pos = 0;\n        let synced = 0;\n\n        // When children lists are small, we are using naive O(N) algorithm to find if child is removed.\n        if ((bLength <= 4) || ((aLength * bLength) <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (synced < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode._key === bNode._key) {\n                            sources[j - bStart] = i;\n\n                            if (pos > j) {\n                                moved = true;\n                            } else {\n                                pos = j;\n                            }\n                            vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n                            synced++;\n                            aNullable[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            const keyIndex = new Map<any, number>();\n\n            for (i = bStart; i <= bEnd; i++) {\n                node = b[i];\n                keyIndex.set(node._key, i);\n            }\n\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n\n                if (synced < bLength) {\n                    j = keyIndex.get(aNode._key);\n\n                    if (j !== undefined) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        } else {\n                            pos = j;\n                        }\n                        vNodeSyncOrReplace(parent, aNode, bNode, context, owner);\n                        synced++;\n                        aNullable[i] = null;\n                    }\n                }\n            }\n        }\n\n        if (aLength === a.length && synced === 0) {\n            // Noone is synced, remove all children with one dom op.\n            vNodeRemoveAllChildren(parent, a);\n            while (bStart < bLength) {\n                vNodeRenderInto(parent, null, b[bStart++], context, owner);\n            }\n        } else {\n            i = aLength - synced;\n            while (i > 0) {\n                aNode = aNullable[aStart++];\n                if (aNode !== null) {\n                    vNodeRemoveChild(parent, aNode);\n                    i--;\n                }\n            }\n\n            // Step 3\n            if (moved) {\n                const seq = lis(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n                        vNodeRenderInto(parent, next, node, context, owner);\n                    } else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n                            vNodeMoveChild(parent, node, next);\n                        } else {\n                            j--;\n                        }\n                    }\n                }\n            } else if (synced !== bLength) {\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        nextPos = pos + 1;\n                        next = nextPos < b.length ? getDOMInstanceFromVNode(b[nextPos]) : null;\n                        vNodeRenderInto(parent, next, node, context, owner);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n *\n * @param a Array of numbers.\n * @returns Longest increasing subsequence.\n */\nfunction lis(a: number[]): number[] {\n    const p = a.slice(0);\n    const result: number[] = [];\n    result.push(0);\n    let u: number;\n    let v: number;\n\n    for (let i = 0, il = a.length; i < il; i++) {\n        if (a[i] === -1) {\n            continue;\n        }\n\n        let j = result[result.length - 1];\n        if (a[j] < a[i]) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n\n        u = 0;\n        v = result.length - 1;\n\n        while (u < v) {\n            let c = ((u + v) / 2) | 0;\n            if (a[result[c]] < a[i]) {\n                u = c + 1;\n            } else {\n                v = c;\n            }\n        }\n\n        if (a[i] < a[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n\n    u = result.length;\n    v = result[u - 1];\n\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n\n    return result;\n}\n","import { getFunctionName, nextDebugId } from \"../common/dev_mode\";\nimport { isPropsNotIdentical, isPropsNotShallowEqual } from \"../common/equality\";\nimport { AncestorFlags } from \"../common/html_nesting_rules\";\nimport { ComponentFlags } from \"./flags\";\nimport { Context } from \"./context\";\nimport { VNode, getDOMInstanceFromVNode } from \"./vnode\";\nimport { currentFrame } from \"../scheduler/scheduler\";\n\n/**\n * Component function constructor.\n */\nexport interface ComponentFunction<P> {\n    (props: P, context?: Context): VNode<any> | undefined;\n    isPropsChanged?: (oldProps: P, newProps: P) => boolean;\n}\n\n/**\n * Component class constructor.\n */\nexport interface ComponentClass<P> {\n    new (props: P, context: Context, owner: Component<any> | undefined): Component<P>;\n}\n\n/**\n * Component is the main building block that is used to build UI applications.\n *\n * Component class has a parametric type `P` to specify `props` type.\n *\n * Example:\n *\n *     class Hello extends Component<string> {\n *       render() {\n *         return $t(`Hello ${this.props}`);\n *       }\n *     }\n *\n *     render($c(Hello, \"world\"), document.getElementById(\"App\")!);\n */\nexport abstract class Component<P> {\n    /**\n     * Flags, see `ComponentFlags` for details.\n     *\n     * Lowest 16 bits are reserved for ivi flags, other bits can be used for user flags.\n     */\n    flags: ComponentFlags;\n    /**\n     * Depth in the components tree.\n     *\n     * Depth property is used by scheduler to determine component priority when updating components.\n     */\n    readonly depth: number;\n    /**\n     * Component properties.\n     */\n    _props: P;\n    /**\n     * Parent context.\n     *\n     * Context that was used to create this component.\n     */\n    _parentContext: Context;\n    /**\n     * Current context.\n     */\n    _context: Context;\n    /**\n     * Owner component.\n     *\n     * Parent component. When owner is an undefined, it means that this component is a root component.\n     */\n    readonly owner: Component<any> | undefined;\n    /**\n     * Virtual DOM root node.\n     */\n    root: VNode<any> | null;\n    /**\n     * Parent DOM node.\n     *\n     * It is used because when root node is changed we will need to replace old DOM node with a new one, and right now\n     * browsers doesn't provide a nice API that doesn't require to know parent nodes.\n     */\n    _parentDOMNode: Node | null;\n    /**\n     * Ancestor Flags are used to check child nesting violations.\n     *\n     * Dev Mode.\n     */\n    _ancestorFlags: AncestorFlags;\n    /**\n     * Component function stack trace.\n     *\n     * Component functions doesn't have any instances, so we need to store them separately.\n     *\n     * Dev Mode.\n     */\n    _stackTrace: ComponentFunction<any>[] | null;\n    /**\n     * Unique ID.\n     *\n     * ID generator is using `dev_mode.uniqueId()` function, so it will be unique across all Dev Mode ids.\n     *\n     * Dev Mode.\n     */\n    _debugId: number;\n\n    constructor(props: P, context: Context, owner: Component<any> | undefined) {\n        this.flags = 0;\n        this.depth = owner ? owner.depth + 1 : 0;\n        this._props = props;\n        this._parentContext = context;\n        this._context = context;\n        this.owner = owner;\n        this.root = null;\n        if (__IVI_BROWSER__) {\n            this._parentDOMNode = null;\n        }\n        if (__IVI_DEV__) {\n            this._ancestorFlags = 0;\n            this._stackTrace = null;\n            this._debugId = nextDebugId();\n        }\n    }\n\n    /**\n     * Get current context.\n     *\n     * @returns Current context.\n     */\n    get context(): Context {\n        this.flags |= ComponentFlags.CheckUsingContext;\n        return this._context;\n    }\n\n    /**\n     * Get props.\n     *\n     * @returns Current props.\n     */\n    get props(): P {\n        this.flags |= ComponentFlags.CheckUsingProps;\n        return this._props;\n    }\n\n    /**\n     * Is Component mounted.\n     *\n     * `isMounted` should be used only in one case, to prevent unnecessary work in asynchronous tasks.\n     *\n     * @returns `true` when Component is mounted.\n     */\n    get isMounted(): boolean {\n        return !!(this.flags & ComponentFlags.Mounted);\n    }\n\n    /**\n     * Lifecycle method `isPropsChanged` is used as a hint that can reduce unnecessary updates.\n     *\n     * By default all props changes returns `true`.\n     *\n     * @param oldProps Old props.\n     * @param newProps New props.\n     * @returns `true` when props should be updated.\n     */\n    isPropsChanged(oldProps: P, newProps: P): boolean {\n        return true;\n    }\n\n    /**\n     * Lifecycle method `didReceiveNewProps` is invoked after new props are assigned.\n     *\n     * @param oldProps Old props.\n     * @param newProps New props.\n     */\n    didReceiveNewProps(oldProps: P, newProps: P): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didReceiveNewContext` is invoked after new context is assigned.\n     *\n     * @param oldContext Old context.\n     * @param newContext New Context.\n     */\n    didReceiveNewContext(oldContext: Context, newContext: Context): void {\n        // TODO: this lifecycle method might be slightly confusing because it actually works with parent contexts.\n        // Maybe rename it to something more appropriate?\n        //\n        // NOTE: `willReceiveNewContext` will be even more confusing because components provide an API to get current\n        // context with `this.context`. `willReceiveNewProps` were changed to `didReceiveNewProps` to make it look like\n        // this lifecycle method.\n\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `updateContext` is used to modify current context.\n     *\n     * It will be invoked when component is created, each time when parent context is changed, each time when props are\n     * changed, and when component is updated with invalidated context.\n     *\n     * @returns Context data.\n     */\n    updateContext<C>(): C | undefined {\n        return;\n    }\n\n    /**\n     * Lifecycle method `didMount` is invoked when component is mounted to the document.\n     */\n    didMount(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didUnmount` is invoked when component is unmounted from the document.\n     */\n    didUnmount(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `willUpdate` is invoked before update.\n     */\n    willUpdate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `updated` is invoked after update.\n     */\n    didUpdate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * Lifecycle method `didInvalidate` is invoked after `invalidate` method is invoked.\n     */\n    didInvalidate(): void {\n        /* tslint:disable:no-empty */\n        /* tslint:enable:no-empty */\n    }\n\n    /**\n     * When render method returns `undefined` value, it will create an empty text node.\n     */\n    render(): VNode<any> | undefined {\n        return;\n    }\n\n    /**\n     * Invalidate view.\n     */\n    invalidate(): void {\n        if (__IVI_BROWSER__) {\n            invalidateComponent(this, ComponentFlags.DirtyState);\n        }\n    }\n\n    /**\n     * Invalidate context.\n     */\n    invalidateContext(): void {\n        if (__IVI_BROWSER__) {\n            invalidateComponent(this, ComponentFlags.DirtyContext);\n        }\n    }\n}\n\n/**\n * Invalidate Component.\n *\n * @param component\n * @param dirtyFlags\n */\nexport function invalidateComponent<P>(component: Component<P>, dirtyFlags: number): void {\n    if (__IVI_BROWSER__) {\n        if (component.flags & ComponentFlags.Mounted) {\n            component.flags |= dirtyFlags;\n            component.didInvalidate();\n            if (!(component.flags & ComponentFlags.InUpdateQueue)) {\n                currentFrame().updateComponent(component);\n            }\n        }\n    }\n}\n\n/**\n * Global Component registry available in Dev Mode. It is used to find components by their `debugId`.\n */\nlet COMPONENT_REGISTRY: Map<number, Component<any>>;\nif (__IVI_DEV__) {\n    COMPONENT_REGISTRY = new Map<number, Component<any>>();\n}\n\n/**\n * Register a Component in Component Registry by its `debugId`.\n *\n * @param component Component instance.\n */\nexport function registerComponent(component: Component<any>): void {\n    if (__IVI_DEV__) {\n        COMPONENT_REGISTRY.set(component._debugId, component);\n    }\n}\n\n/**\n * Unregister a Component from Component Registry by its `debugId`.\n *\n * @param component Component instance.\n */\nexport function unregisterComponent(component: Component<any>): void {\n    if (__IVI_DEV__) {\n        COMPONENT_REGISTRY.delete(component._debugId);\n    }\n}\n\n/**\n * Find Component instance by `debugId` in Component Registry.\n *\n * @param debugId Debug ID.\n * @returns Component associtated with `debugId` or an `undefined` if component is missing.\n */\nexport function findComponentByDebugId(debugId: number): Component<any> | undefined {\n    if (__IVI_DEV__) {\n        return COMPONENT_REGISTRY.get(debugId);\n    }\n    return;\n}\n\n/**\n * Checks props for identity.\n *\n * This function can be used as a wrapper for function expression, or as a class decorator.\n *\n *     const MyComponent = checkPropsIdentity(function(text: string) {\n *         return $h(\"div\").children(text);\n *     });\n *\n *     @checkPropsIdentity\n *     class MyClassComponent extends Component<string> {\n *         render() {\n *             return $h(\"div\").children(this.props);\n *         }\n *     }\n *\n * @param target Component constructor.\n * @returns Component constructor with identity check.\n */\nexport function checkPropsIdentity<P extends ComponentClass<any> | ComponentFunction<any>>(target: P): P {\n    if (target.prototype.render) {\n        target.prototype.isPropsChanged = isPropsNotIdentical;\n    } else {\n        (target as ComponentFunction<any>).isPropsChanged = isPropsNotIdentical;\n    }\n    return target;\n}\n\n/**\n * Checks props for shallow equality.\n *\n * This function can be used as a wrapper for function expression, or as a class decorator.\n *\n *     const MyComponent = checkPropsShallowEquality(function(props: { text: string }) {\n *         return $h(\"div\").children(props.text);\n *     });\n *\n *     @checkPropsShallowEquality\n *     class MyClassComponent extends Component<{ text: string }> {\n *         render() {\n *             return $h(\"div\").children(this.props.text);\n *         }\n *     }\n *\n * @param target Component constructor.\n * @returns Component constructor with identity check.\n */\nexport function checkPropsShallowEquality<P extends ComponentClass<any> | ComponentFunction<any>>(target: P): P {\n    if (target.prototype.render) {\n        target.prototype.isPropsChanged = isPropsNotShallowEqual;\n    } else {\n        (target as ComponentFunction<any>).isPropsChanged = isPropsNotShallowEqual;\n    }\n    return target;\n}\n\n/**\n * Get reference to a DOM node from a Component instance.\n *\n * @param component Component instance.\n * @returns DOM node.\n */\nexport function getDOMInstanceFromComponent<T extends Node>(component: Component<any>): T {\n    if (__IVI_DEV__) {\n        if (!component.root) {\n            throw new Error(\"Failed to get DOM instance from component, component is not initialized.\");\n        }\n    }\n    return getDOMInstanceFromVNode<T>(component.root!) !;\n}\n\n/**\n * Get component name from component instance or component function.\n *\n * @param component Component.\n * @return Component name.\n */\nexport function getComponentName(component: Component<any> | ComponentFunction<any>): string {\n    return getFunctionName(\n        (component as Function).prototype.render ?\n            (component as Object).constructor :\n            component as ComponentFunction<any>,\n    );\n}\n","/**\n * Universal Scheduler.\n *\n * When scheduler is running on server, all frame tasks will be executed inside a macrotask registered with a\n * `setImmediate` call.\n */\n\nimport { Component } from \"../vdom/component\";\nimport { updateComponent } from \"../vdom/implementation\";\nimport { ComponentFlags } from \"../vdom/flags\";\n\n/**\n * Scheduler Task.\n */\nexport type SchedulerTask = () => void;\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n    /**\n     * Microtasks are pending for execution in microtasks queue.\n     */\n    MicrotaskPending = 1,\n    /**\n     * Macrotasks are pending for execution in macrotasks queue.\n     */\n    MacrotaskPending = 1 << 1,\n    /**\n     * Frametasks are pending for execution in frametasks queue.\n     */\n    FrametaskPending = 1 << 2,\n    /**\n     * Current frame ready.\n     */\n    CurrentFrameReady = 1 << 3,\n}\n\n/**\n * Frame Tasks Group flags.\n */\nconst enum FrameTasksGroupFlags {\n    /**\n     * Group contains component update tasks.\n     */\n    Component = 1,\n    /**\n     * Group contains \"write\" tasks.\n     */\n    Write = 1 << 1,\n    /**\n     * Group contains \"read\" tasks\".\n     */\n    Read = 1 << 2,\n    /**\n     * Group contains \"after\" tasks.\n     */\n    After = 1 << 3,\n    /**\n     * Group is locked from reading and writing.\n     */\n    RWLock = 1 << 4,\n}\n\n/**\n * Frame tasks group contains tasks for updating components, read dom and write dom tasks, and tasks that should be\n * executed after all other tasks are finished.\n *\n * To get access to the frame tasks group, use: `currentFrame()` and `nextFrame()` scheduler methods.\n *\n *     scheduler.currentFrame().read(() => {\n *       console.log(element.clientWidth);\n *     });\n *\n * @final\n */\nexport class FrameTasksGroup {\n    /**\n     * See `FrameTasksGroupFlags` for details.\n     */\n    _flags: number;\n    /**\n     * Array of component arrays indexed by their depth.\n     */\n    _componentTasks: Array<Component<any>[] | null>;\n    /**\n     * Write DOM task queue.\n     */\n    _writeTasks: SchedulerTask[] | null;\n    /**\n     * Read DOM task queue.\n     */\n    _readTasks: SchedulerTask[] | null;\n    /**\n     * Tasks that should be executed when all other tasks are finished.\n     */\n    _afterTasks: SchedulerTask[] | null;\n\n    constructor() {\n        this._flags = 0;\n        this._componentTasks = [];\n        this._writeTasks = null;\n        this._readTasks = null;\n        this._afterTasks = null;\n    }\n\n    /**\n     * Add Component to the components queue.\n     *\n     * @param component\n     */\n    updateComponent(component: Component<any>): void {\n        if (__IVI_BROWSER__) {\n            if (__IVI_DEV__) {\n                if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                    throw new Error(\"Failed to add update component task to the current frame, current frame is \" +\n                        \"locked for read and write tasks.\");\n                }\n            }\n\n            if ((component.flags & ComponentFlags.InUpdateQueue) === 0) {\n                component.flags |= ComponentFlags.InUpdateQueue;\n                const priority = component.depth;\n\n                this._flags |= FrameTasksGroupFlags.Component;\n                while (priority >= this._componentTasks.length) {\n                    this._componentTasks.push(null);\n                }\n\n                const group = this._componentTasks[priority];\n                if (group === null) {\n                    this._componentTasks[priority] = [component];\n                } else {\n                    group.push(component);\n                }\n            }\n        }\n    }\n\n    /**\n     * Add new task to the write DOM task queue.\n     *\n     * @param callback\n     */\n    write(callback: SchedulerTask): void {\n        if (__IVI_DEV__) {\n            if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                throw new Error(\"Failed to add update component task to the current frame, current frame is locked \" +\n                    \"for read and write tasks.\");\n            }\n        }\n\n        this._flags |= FrameTasksGroupFlags.Write;\n        if (this._writeTasks === null) {\n            this._writeTasks = [];\n        }\n        this._writeTasks.push(callback);\n    }\n\n    /**\n     * Add new task to the read DOM task queue.\n     *\n     * @param callback\n     */\n    read(callback: SchedulerTask): void {\n        if (__IVI_DEV__) {\n            if ((this._flags & FrameTasksGroupFlags.RWLock) !== 0) {\n                throw new Error(\"Failed to add update component task to the current frame, current frame is locked \" +\n                    \"for read and write tasks.\");\n            }\n        }\n\n        this._flags |= FrameTasksGroupFlags.Read;\n        if (this._readTasks === null) {\n            this._readTasks = [];\n        }\n        this._readTasks.push(callback);\n    }\n\n    /**\n     * Add new task to the task queue that will execute tasks when all DOM tasks are finished.\n     *\n     * @param callback\n     */\n    after(callback: SchedulerTask): void {\n        this._flags |= FrameTasksGroupFlags.After;\n        if (this._afterTasks === null) {\n            this._afterTasks = [];\n        }\n        this._afterTasks.push(callback);\n    }\n\n    /**\n     * Lock read and write task queues.\n     *\n     * Works in DEBUG mode only.\n     */\n    _rwLock(): void {\n        if (__IVI_DEV__) {\n            this._flags |= FrameTasksGroupFlags.RWLock;\n        }\n    }\n\n    /**\n     * Unlock read and write task queue.\n     *\n     * Works in DEBUG mode only.\n     */\n    _rwUnlock(): void {\n        if (__IVI_DEV__) {\n            this._flags &= ~FrameTasksGroupFlags.RWLock;\n        }\n    }\n}\n\n/**\n * Scheduler.\n */\nconst scheduler = {\n    /**\n     * See `SchedulerFlags` for details.\n     */\n    flags: 0,\n    clock: 0,\n    time: 0,\n    microtasks: [] as SchedulerTask[],\n    macrotasks: [] as SchedulerTask[],\n    currentFrame: new FrameTasksGroup(),\n    nextFrame: new FrameTasksGroup(),\n    updateComponents: [] as Component<any>[],\n};\n\nconst microtaskNode = __IVI_BROWSER__ ? document.createTextNode(\"\") : undefined;\nlet microtaskToggle = 0;\nconst macrotaskMessage = __IVI_BROWSER__ ? \"__ivi\" + Math.random() : undefined;\n\nif (__IVI_BROWSER__) {\n    // Microtask scheduler based on mutation observer\n    const microtaskObserver = new MutationObserver(runMicrotasks);\n    microtaskObserver.observe(microtaskNode!, { characterData: true });\n\n    // Macrotask scheduler based on postMessage\n    window.addEventListener(\"message\", handleWindowMessage);\n}\nscheduler.currentFrame._rwLock();\n\n/**\n * Monotonically increasing clock.\n *\n * @returns current clock value.\n */\nexport function clock(): number {\n    return scheduler.clock;\n}\n\n/**\n * Trigger microtasks execution.\n */\nfunction requestMicrotaskExecution(): void {\n    if ((scheduler.flags & SchedulerFlags.MicrotaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.MicrotaskPending;\n        if (__IVI_BROWSER__) {\n            microtaskToggle ^= 1;\n            microtaskNode!.nodeValue = microtaskToggle ? \"1\" : \"0\";\n        } else {\n            process.nextTick(runMicrotasks);\n        }\n    }\n}\n\n/**\n * Trigger macrotasks execution.\n */\nfunction requestMacrotaskExecution(): void {\n    if ((scheduler.flags & SchedulerFlags.MacrotaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.MacrotaskPending;\n        if (__IVI_BROWSER__) {\n            window.postMessage(macrotaskMessage, \"*\");\n        } else {\n            setImmediate(runMacrotasks);\n        }\n    }\n}\n\n/**\n * Trigger next frame tasks execution.\n */\nfunction requestNextFrame(): void {\n    if ((scheduler.flags & SchedulerFlags.FrametaskPending) === 0) {\n        scheduler.flags |= SchedulerFlags.FrametaskPending;\n        if (__IVI_BROWSER__) {\n            requestAnimationFrame(handleNextFrame);\n        } else {\n            setImmediate(handleNextFrame);\n        }\n    }\n}\n\n/**\n * Macrotask scheduler event handler.\n *\n * @param ev Message event.\n */\nfunction handleWindowMessage(ev: MessageEvent): void {\n    if (ev.source === window && ev.data === macrotaskMessage) {\n        runMacrotasks();\n    }\n}\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nfunction handleNextFrame(): void {\n    const updateComponents = scheduler.updateComponents;\n    let tasks: SchedulerTask[];\n    let i: number;\n    let j: number;\n\n    scheduler.flags &= ~SchedulerFlags.FrametaskPending;\n    scheduler.flags |= SchedulerFlags.CurrentFrameReady;\n\n    scheduler.time = Date.now();\n\n    const frame = scheduler.nextFrame;\n    scheduler.nextFrame = scheduler.currentFrame;\n    scheduler.currentFrame = frame;\n\n    scheduler.currentFrame._rwUnlock();\n    scheduler.nextFrame._rwUnlock();\n\n    if (__IVI_BROWSER__) {\n        // Mark all update components as dirty. But don't update until all write tasks are finished. It is possible that\n        // we won't need to update component if it is removed.\n        for (i = 0; i < updateComponents.length; i++) {\n            updateComponents[i].flags |= ComponentFlags.DirtyState;\n        }\n    }\n\n    // Perform read/write batching. Start with executing read DOM tasks, then update components, execute write DOM tasks\n    // and repeat until all read and write tasks are executed.\n    do {\n        while ((frame._flags & FrameTasksGroupFlags.Read) !== 0) {\n            frame._flags &= ~FrameTasksGroupFlags.Read;\n            tasks = frame._readTasks!;\n            frame._readTasks = null;\n\n            for (i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        }\n\n        while ((frame._flags & (FrameTasksGroupFlags.Component | FrameTasksGroupFlags.Write)) !== 0) {\n            if ((frame._flags & FrameTasksGroupFlags.Write) !== 0) {\n                frame._flags &= ~FrameTasksGroupFlags.Write;\n                tasks = frame._writeTasks!;\n                frame._writeTasks = null;\n                for (i = 0; i < tasks.length; i++) {\n                    tasks[i]();\n                }\n            }\n\n            if (__IVI_BROWSER__) {\n                if ((frame._flags & FrameTasksGroupFlags.Component) !== 0) {\n                    frame._flags &= ~FrameTasksGroupFlags.Component;\n                    const componentGroups = frame._componentTasks;\n\n                    for (i = 0; i < componentGroups.length; i++) {\n                        const componentGroup = componentGroups[i];\n                        if (componentGroup !== null) {\n                            componentGroups[i] = null;\n                            for (j = 0; j < componentGroup.length; j++) {\n                                updateComponent(componentGroup[j]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (__IVI_BROWSER__) {\n            // Update components registered for updating on each frame.\n            // Remove components that doesn't have UPDATE_EACH_FRAME flag.\n            i = 0;\n            j = updateComponents.length;\n\n            while (i < j) {\n                const component = updateComponents[i++];\n                if ((component.flags & ComponentFlags.UpdateEachFrame) === 0) {\n                    component.flags &= ~ComponentFlags.InUpdateEachFrameQueue;\n                    if (i === j) {\n                        updateComponents.pop();\n                    } else {\n                        updateComponents[--i] = updateComponents.pop() !;\n                    }\n                } else {\n                    updateComponent(component);\n                }\n            }\n        }\n    } while ((frame._flags & (FrameTasksGroupFlags.Component |\n        FrameTasksGroupFlags.Write |\n        FrameTasksGroupFlags.Read)) !== 0);\n\n    scheduler.flags &= ~SchedulerFlags.CurrentFrameReady;\n\n    // Lock current from adding read and write tasks in debug mode.\n    scheduler.currentFrame._rwLock();\n\n    // Perform tasks that should be executed when all DOM ops are finished.\n    while ((frame._flags & FrameTasksGroupFlags.After) !== 0) {\n        frame._flags &= ~FrameTasksGroupFlags.After;\n\n        tasks = frame._afterTasks!;\n        frame._afterTasks = null;\n        for (i = 0; i < tasks.length; i++) {\n            tasks[i]();\n        }\n    }\n\n    if (__IVI_BROWSER__) {\n        if (updateComponents.length > 0) {\n            requestNextFrame();\n        }\n    }\n\n    scheduler.clock++;\n}\n\nfunction runMicrotasks(): void {\n    scheduler.time = Date.now();\n\n    while (scheduler.microtasks.length > 0) {\n        const tasks = scheduler.microtasks;\n        scheduler.microtasks = [];\n        for (let i = 0; i < tasks.length; i++) {\n            tasks[i]();\n        }\n        scheduler.clock++;\n    }\n\n    scheduler.flags &= ~SchedulerFlags.MicrotaskPending;\n}\n\nfunction runMacrotasks(): void {\n    scheduler.flags &= ~SchedulerFlags.MacrotaskPending;\n    scheduler.time = Date.now();\n\n    let tasks = scheduler.macrotasks;\n    scheduler.macrotasks = [];\n    for (let i = 0; i < tasks.length; i++) {\n        tasks[i]();\n    }\n\n    scheduler.clock++;\n}\n\n/**\n * Add task to the microtask queue.\n *\n * @param task\n */\nexport function scheduleMicrotask(task: () => void): void {\n    requestMicrotaskExecution();\n    scheduler.microtasks.push(task);\n}\n\n/**\n * Add task to the macrotask queue.\n *\n * @param task\n */\nexport function scheduleMacrotask(task: () => void): void {\n    requestMacrotaskExecution();\n    scheduler.macrotasks.push(task);\n}\n\n/**\n * Get task list for the next frame.\n *\n * @returns Frame tasks group.\n */\nexport function nextFrame(): FrameTasksGroup {\n    requestNextFrame();\n    return scheduler.nextFrame;\n}\n\n/**\n * Get task list for the current frame.\n *\n * @returns Frame tasks group.\n */\nexport function currentFrame(): FrameTasksGroup {\n    if (scheduler.flags & SchedulerFlags.CurrentFrameReady) {\n        return scheduler.currentFrame;\n    }\n    return nextFrame();\n}\n\n/**\n * Add component to the list of components that will be updated each frame.\n *\n * @param component\n */\nexport function startUpdateComponentEachFrame(component: Component<any>): void {\n    if (__IVI_BROWSER__) {\n        requestNextFrame();\n        scheduler.updateComponents.push(component);\n    }\n}\n","import { USER_AGENT, UserAgentFlags } from \"../common/user_agent\";\nimport { NOOP } from \"../common/noop\";\nimport { nextFrame } from \"../scheduler/scheduler\";\nimport { Context, ROOT_CONTEXT } from \"./context\";\nimport { VNodeFlags } from \"./flags\";\nimport { VNode } from \"./vnode\";\nimport { Component, getDOMInstanceFromComponent } from \"./component\";\nimport { renderVNode, syncVNode, removeVNode, augmentVNode } from \"./implementation\";\n\n/**\n * Root.\n */\nexport interface Root {\n    container: Element;\n    currentVNode: VNode<any> | null;\n    newVNode: VNode<any> | null;\n    newContext: Context | null;\n    domNode: Node | null;\n    invalidated: boolean;\n}\n\nconst roots = [] as Root[];\n\n/**\n * Find Root node in container.\n *\n * @param container DOM Node that contains root node.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport function findRoot(container: Element): Root | undefined {\n    for (let i = 0; i < roots.length; i++) {\n        const r = roots[i];\n        if (r.container === container) {\n            return r;\n        }\n    }\n\n    return;\n}\n\n/**\n * Render VNode into container.\n *\n * @param root Root data.\n * @returns rendered Node.\n */\nfunction _render<T>(root: Root): T | undefined {\n    let result: Node | Component<any> | undefined;\n    const currentVNode = root.currentVNode;\n    const newVNode = root.newVNode;\n\n    if (newVNode) {\n        if (currentVNode) {\n            result = syncVNode(root.container, currentVNode, newVNode, root.newContext!);\n        } else {\n            result = renderVNode(root.container, null, newVNode!, root.newContext!);\n            /**\n             * Fix for the Mouse Event bubbling on iOS devices.\n             *\n             * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n             */\n            if (USER_AGENT & UserAgentFlags.iOS) {\n                (root.container as HTMLElement).onclick = NOOP;\n            }\n        }\n        root.currentVNode = newVNode;\n        root.domNode = (newVNode._flags & VNodeFlags.ComponentClass) ?\n            getDOMInstanceFromComponent(result as Component<any>) :\n            result as Node;\n    } else if (currentVNode) {\n        removeVNode(root.container, currentVNode);\n        const last = roots.pop();\n        if (last !== root && roots.length) {\n            roots[roots.indexOf(root)] = last!;\n        }\n    }\n\n    root.newVNode = null;\n    root.newContext = null;\n    root.invalidated = false;\n\n    return result as T | undefined;\n}\n\n/**\n * Render VNode into container.\n *\n * @param node VNode to render.\n * @param container DOM Node that will contain rendered node.\n * @param context root context, all root contexts should be created from the `ROOT_CONTEXT` instance.\n * @returns rendered Node.\n */\nexport function render<T extends Node>(\n    node: VNode<any> | null,\n    container: Element,\n    context: Context = ROOT_CONTEXT,\n): T | undefined {\n    if (__IVI_DEV__) {\n        if (container === document.body) {\n            throw new Error(\"Rendering in the <body> aren't allowed, create an element inside body that will contain \" +\n                \"your application.\");\n        }\n    }\n\n    let root = findRoot(container);\n    if (root) {\n        root.newVNode = node;\n        root.newContext = context;\n    } else {\n        root = {\n            container: container,\n            currentVNode: null,\n            newVNode: node,\n            newContext: context,\n            domNode: null,\n            invalidated: false,\n        } as Root;\n        roots.push(root);\n    }\n\n    return _render<T>(root);\n}\n\n/**\n * Render VNode into container on the next frame.\n *\n * @param node VNode to render.\n * @param container DOM Node that will contain rendered node.\n * @param context root context, all root contexts should be created from the `ROOT_CONTEXT` instance.\n * @returns rendered Node.\n */\nexport function renderNextFrame(\n    node: VNode<any> | null,\n    container: Element,\n    context: Context = ROOT_CONTEXT,\n): void {\n    if (__IVI_DEV__) {\n        if (container === document.body) {\n            throw new Error(\"Rendering in the <body> aren't allowed, create an element inside body that will contain \" +\n                \"your application.\");\n        }\n    }\n\n    let root = findRoot(container);\n    if (root) {\n        root.newVNode = node;\n        root.newContext = context;\n    } else {\n        root = {\n            container: container,\n            currentVNode: null,\n            newVNode: node,\n            newContext: context,\n            domNode: null,\n            invalidated: false,\n        } as Root;\n        roots.push(root);\n    }\n    if (!root.invalidated) {\n        nextFrame().write(function () {\n            if (root!.invalidated) {\n                _render(root!);\n            }\n        });\n    }\n}\n\n/**\n * Augment existing DOM tree with a Virtual DOM tree.\n *\n * Augmentation is separated from `render` function to reduce code size when web application doesn't use augmentation.\n * Optimizing javascript compiler should remove all code associated with augmentation when it isn't used.\n *\n * @param node Root VNode.\n * @param container Container DOM Node.\n * @param context root context, all root contexts should be created from the `ROOT_CONTEXT` instance.\n */\nexport function augment(node: VNode<any> | null, container: Element, context: Context = ROOT_CONTEXT): void {\n    if (__IVI_DEV__) {\n        if (container === document.body) {\n            throw new Error(\"Rendering in the <body> aren't allowed, create an element inside body that will contain \" +\n                \"your application.\");\n        }\n\n        if (findRoot(container)) {\n            throw new Error(\"Failed to augment, container is associated with a Virtual DOM.\");\n        }\n    }\n\n    if (node) {\n        augmentVNode(container, container.firstChild!, node, context);\n        roots.push({\n            container: container,\n            currentVNode: node,\n            newVNode: null,\n            newContext: null,\n            domNode: container.firstChild!,\n            invalidated: false,\n        });\n        /**\n         * Fix for the Mouse Event bubbling on iOS devices.\n         *\n         * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n         */\n        if (USER_AGENT & UserAgentFlags.iOS) {\n            (container as HTMLElement).onclick = NOOP;\n        }\n    }\n}\n","/**\n * @final\n */\nexport class Query {\n    elapsed: number;\n    query: string;\n\n    constructor(elapsed: number, query: string) {\n        this.elapsed = elapsed;\n        this.query = query;\n    }\n\n    static rand(): Query {\n        const elapsed = Math.random() * 15;\n        let query: string;\n\n        if (Math.random() < 0.1) {\n            query = \"vacuum\";\n        } else if (Math.random() < 0.2) {\n            query = \"<IDLE> in transaction\";\n        } else {\n            query = \"SELECT blah FROM something\";\n        }\n\n        return new Query(elapsed, query);\n    }\n};\n\nexport const EMPTY_QUERY = new Query(0.0, \"***\");\n\n/**\n * @final\n */\nexport class DB {\n    id: number;\n    name: string;\n    queries: Query[] | null;\n\n    constructor(name: string) {\n        this.id = DB._nextId++;\n        this.name = name;\n        this.queries = null;\n\n        this.update();\n    }\n\n    static _nextId = 0;\n\n    update(): void {\n        const queries = [] as Query[];\n\n        const r = Math.floor((Math.random() * 10) + 1);\n        for (let j = 0; j < r; j++) {\n            queries.push(Query.rand());\n        }\n\n        this.queries = queries;\n    }\n\n    getTopFiveQueries(): Query[] {\n        let qs = this.queries!.slice(0, 5);\n        qs.sort(function (a, b) {\n            return a.elapsed - b.elapsed;\n        });\n        while (qs.length < 5) {\n            qs.push(EMPTY_QUERY);\n        }\n        return qs;\n    }\n}\n\n/**\n * @final\n */\nexport class DBList {\n    dbs: DB[];\n\n    constructor(n: number) {\n        this.dbs = [];\n\n        for (let i = 0; i < n; i++) {\n            this.dbs.push(new DB(\"cluster\" + (i + 1)));\n            this.dbs.push(new DB(\"cluster\" + (i + 1) + \" slave\"));\n        }\n    }\n\n    update(): void {\n        const dbs = this.dbs;\n        for (let i = 0; i < dbs.length; i++) {\n            dbs[i] = new DB(dbs[i].name);\n        }\n    }\n\n    randomUpdate(r: number): void {\n        const dbs = this.dbs;\n        for (let i = 0; i < dbs.length; i++) {\n            if (Math.random() < r) {\n                dbs[i] = new DB(dbs[i].name);\n            }\n        }\n    }\n}\n","const MonitorMaxSamples = 100;\nclass MonitorSamplesResult {\n    constructor(min, max, mean, last) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.last = last;\n    }\n}\n/**\n * Profile Samples.\n */\nclass MonitorSamples {\n    constructor(maxSamples) {\n        this.samples = [];\n        this.maxSamples = maxSamples;\n        this._i = -1;\n    }\n    addSample(v) {\n        this._i = (this._i + 1) % this.maxSamples;\n        this.samples[this._i] = v;\n    }\n    each(fn) {\n        const samples = this.samples;\n        for (let i = 0; i < samples.length; i++) {\n            fn(samples[(this._i + 1 + i) % samples.length], i);\n        }\n    }\n    calc() {\n        const samples = this.samples;\n        if (samples.length === 0) {\n            return new MonitorSamplesResult(0, 0, 0, 0);\n        }\n        let min = samples[(this._i + 1) % samples.length];\n        let max = min;\n        let sum = 0;\n        for (let i = 0; i < samples.length; i++) {\n            const k = samples[(this._i + 1 + i) % samples.length];\n            if (k < min) {\n                min = k;\n            }\n            if (k > max) {\n                max = k;\n            }\n            sum += k;\n        }\n        const last = samples[this._i];\n        const mean = sum / samples.length;\n        return new MonitorSamplesResult(min, max, mean, last);\n    }\n}\n\n/**\n * Basic Counter.\n */\nclass BasicCounter {\n    constructor() {\n        this.value = 0;\n        this.onChange = null;\n    }\n    inc(value) {\n        if (value > 0) {\n            this.value += value;\n            this.onChange();\n        }\n    }\n}\nclass TimestampedValue {\n    constructor(timestamp, value) {\n        this.value = value;\n        this.next = null;\n    }\n}\n/**\n * Sliding Counter counts how many times `inc` method were called during `interval` period.\n */\nclass SlidingCounter {\n    constructor(interval) {\n        this._dec = () => {\n            const now = performance.now();\n            while (this._firstTimestamp !== null) {\n                const nextTimestamp = this._firstTimestamp;\n                if (now >= nextTimestamp.value) {\n                    this.value -= nextTimestamp.value;\n                    this._firstTimestamp = this._firstTimestamp.next;\n                }\n                else {\n                    setTimeout(this._dec, Math.ceil(nextTimestamp.value - now));\n                    break;\n                }\n            }\n            if (this._firstTimestamp === null) {\n                this._lastTimestamp = null;\n            }\n            this.onChange();\n        };\n        this.interval = interval;\n        this.value = 0;\n        this.onChange = null;\n        this._firstTimestamp = null;\n        this._lastTimestamp = null;\n    }\n    inc(value) {\n        if (value > 0) {\n            const timestamp = new TimestampedValue(performance.now() + this.interval, value);\n            if (this._firstTimestamp === null) {\n                this._firstTimestamp = timestamp;\n                setTimeout(this._dec, this.interval);\n            }\n            else {\n                this._lastTimestamp.next = timestamp;\n            }\n            this._lastTimestamp = timestamp;\n            this.value += value;\n            this.onChange();\n        }\n    }\n}\n\nlet frameTasks = [];\nlet rafId = -1;\n/**\n * Schedule new task that will be executed on the next frame.\n */\nfunction scheduleNextFrameTask(task) {\n    frameTasks.push(task);\n    if (rafId === -1) {\n        requestAnimationFrame(function (t) {\n            rafId = -1;\n            const tasks = frameTasks;\n            frameTasks = [];\n            for (let i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        });\n    }\n}\n\nconst MonitorGraphHeight = 30;\nconst MonitorGraphWidth = MonitorMaxSamples;\nclass Widget {\n    constructor(name) {\n        this._sync = () => {\n            this.sync();\n            this._dirty = false;\n        };\n        this.name = name;\n        this.element = document.createElement(\"div\");\n        this.element.style.cssText = \"padding: 2px;\" +\n            \"background-color: #020;\" +\n            \"font-family: monospace;\" +\n            \"font-size: 12px;\" +\n            \"color: #0f0\";\n        this._dirty = false;\n        this.invalidate();\n    }\n    invalidate() {\n        if (!this._dirty) {\n            this._dirty = true;\n            scheduleNextFrameTask(this._sync);\n        }\n    }\n    sync() {\n        throw new Error(\"sync method not implemented\");\n    }\n}\nvar MonitorWidgetFlags;\n(function (MonitorWidgetFlags) {\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMin\"] = 1] = \"HideMin\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMax\"] = 2] = \"HideMax\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMean\"] = 4] = \"HideMean\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideLast\"] = 8] = \"HideLast\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideGraph\"] = 16] = \"HideGraph\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"RoundValues\"] = 32] = \"RoundValues\";\n})(MonitorWidgetFlags || (MonitorWidgetFlags = {}));\nclass MonitorWidget extends Widget {\n    constructor(name, flags, unitName, samples) {\n        super(name);\n        this.flags = flags;\n        this.unitName = unitName;\n        this.samples = samples;\n        const label = document.createElement(\"div\");\n        label.style.cssText = \"text-align: center\";\n        label.textContent = this.name;\n        const text = document.createElement(\"div\");\n        if ((flags & MonitorWidgetFlags.HideMin) === 0) {\n            this.minText = document.createElement(\"div\");\n            text.appendChild(this.minText);\n        }\n        else {\n            this.minText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMax) === 0) {\n            this.maxText = document.createElement(\"div\");\n            text.appendChild(this.maxText);\n        }\n        else {\n            this.maxText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMean) === 0) {\n            this.meanText = document.createElement(\"div\");\n            text.appendChild(this.meanText);\n        }\n        else {\n            this.meanText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideLast) === 0) {\n            this.lastText = document.createElement(\"div\");\n            text.appendChild(this.lastText);\n        }\n        else {\n            this.lastText = null;\n        }\n        this.element.appendChild(label);\n        this.element.appendChild(text);\n        if ((flags & MonitorWidgetFlags.HideGraph) === 0) {\n            this.canvas = document.createElement(\"canvas\");\n            this.canvas.style.cssText = \"display: block; padding: 0; margin: 0\";\n            this.canvas.width = MonitorGraphWidth;\n            this.canvas.height = MonitorGraphHeight;\n            this.ctx = this.canvas.getContext(\"2d\");\n            this.element.appendChild(this.canvas);\n        }\n        else {\n            this.canvas = null;\n            this.ctx = null;\n        }\n    }\n    sync() {\n        const result = this.samples.calc();\n        const scale = MonitorGraphHeight / (result.max * 1.2);\n        let min;\n        let max;\n        let mean;\n        let last;\n        if ((this.flags & MonitorWidgetFlags.RoundValues) === 0) {\n            min = result.min.toFixed(2);\n            max = result.max.toFixed(2);\n            mean = result.mean.toFixed(2);\n            last = result.last.toFixed(2);\n        }\n        else {\n            min = Math.round(result.min).toString();\n            max = Math.round(result.max).toString();\n            mean = Math.round(result.mean).toString();\n            last = Math.round(result.last).toString();\n        }\n        if (this.minText !== null) {\n            this.minText.textContent = `min: \\u00A0${min}${this.unitName}`;\n        }\n        if (this.maxText !== null) {\n            this.maxText.textContent = `max: \\u00A0${max}${this.unitName}`;\n        }\n        if (this.meanText !== null) {\n            this.meanText.textContent = `mean: ${mean}${this.unitName}`;\n        }\n        if (this.lastText !== null) {\n            this.lastText.textContent = `last: ${last}${this.unitName}`;\n        }\n        if (this.ctx !== null) {\n            this.ctx.fillStyle = \"#010\";\n            this.ctx.fillRect(0, 0, MonitorGraphWidth, MonitorGraphHeight);\n            this.ctx.fillStyle = \"#0f0\";\n            this.samples.each((v, i) => {\n                this.ctx.fillRect(i, MonitorGraphHeight, 1, -(v * scale));\n            });\n        }\n    }\n}\nclass CounterWidget extends Widget {\n    constructor(name, counter) {\n        super(name);\n        this.counter = counter;\n        this.text = document.createElement(\"div\");\n        this.element.appendChild(this.text);\n    }\n    sync() {\n        this.text.textContent = `${this.name}: ${this.counter.value}`;\n    }\n}\n\nlet container = null;\nlet initialized = false;\n/**\n * Initialize Performance Monitor.\n */\nfunction initPerfMonitor(options) {\n    if (!initialized) {\n        if (options.container) {\n            container = options.container;\n        }\n        initialized = true;\n    }\n}\n/**\n * Check that everything is properly initialized.\n */\nfunction checkInit() {\n    if (!container) {\n        container = document.createElement(\"div\");\n        container.style.cssText = \"position: fixed;\" +\n            \"opacity: 0.9;\" +\n            \"right: 0;\" +\n            \"bottom: 0\";\n        document.body.appendChild(container);\n    }\n    initialized = true;\n}\n/**\n * Start FPS monitor\n */\nfunction startFPSMonitor(flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMax |\n        MonitorWidgetFlags.HideMean | MonitorWidgetFlags.RoundValues) {\n    checkInit();\n    const data = new MonitorSamples(MonitorMaxSamples);\n    const w = new MonitorWidget(\"FPS\", flags, \"\", data);\n    container.appendChild(w.element);\n    const alpha = 2 / 121;\n    let last = 0;\n    let fps = 60;\n    function update(now) {\n        if (last > 0) {\n            fps += alpha * ((1000 / (now - last)) - fps);\n        }\n        last = now;\n        data.addSample(fps);\n        w.invalidate();\n        requestAnimationFrame(update);\n    }\n    requestAnimationFrame(update);\n}\n/**\n * Start Memory Monitor\n */\nfunction startMemMonitor(flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMean) {\n    checkInit();\n    if (performance.memory === undefined) {\n        return;\n    }\n    const data = new MonitorSamples(MonitorMaxSamples);\n    const w = new MonitorWidget(\"Memory\", flags, \"MB\", data);\n    container.appendChild(w.element);\n    function update() {\n        data.addSample(Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)));\n        w.invalidate();\n        setTimeout(update, 30);\n    }\n    update();\n}\nclass ProfilerDetails {\n    constructor(name, unitName, flags) {\n        this.data = new MonitorSamples(MonitorMaxSamples);\n        this.widget = new MonitorWidget(name, flags, unitName, this.data);\n        this.startTime = -1;\n    }\n}\nconst profilerInstances = {};\nclass CounterDetails {\n    constructor(name, interval) {\n        this.data = interval === undefined ? new BasicCounter() : new SlidingCounter(interval);\n        this.widget = new CounterWidget(name, this.data);\n        this.data.onChange = () => {\n            this.widget.invalidate();\n        };\n    }\n}\nconst counterInstances = {};\n/**\n * Initialize profiler and insert into container.\n */\nfunction initProfiler(name, flags = 0) {\n    checkInit();\n    let profiler = profilerInstances[name];\n    if (profiler === void 0) {\n        profilerInstances[name] = profiler = new ProfilerDetails(name, \"ms\", flags);\n        container.appendChild(profiler.widget.element);\n    }\n}\n/**\n * Initialize counter and insert into container.\n */\nfunction initCounter(name, interval) {\n    checkInit();\n    let counter = counterInstances[name];\n    if (counter === void 0) {\n        counterInstances[name] = counter = new CounterDetails(name, interval);\n        container.appendChild(counter.widget.element);\n    }\n}\nfunction startProfile(name) {\n    const profiler = profilerInstances[name];\n    if (profiler !== void 0) {\n        profiler.startTime = performance.now();\n    }\n}\nfunction endProfile(name) {\n    const now = performance.now();\n    const profiler = profilerInstances[name];\n    if (profiler !== void 0 && profiler.startTime !== -1) {\n        profiler.data.addSample(now - profiler.startTime);\n        profiler.widget.invalidate();\n    }\n}\nfunction count(name, value = 1) {\n    const counter = counterInstances[name];\n    if (counter !== void 0) {\n        counter.data.inc(value);\n    }\n}\n\nexport { initPerfMonitor, startFPSMonitor, startMemMonitor, initProfiler, initCounter, startProfile, endProfile, count, MonitorWidgetFlags };","import { render, checkPropsIdentity, VNode, $h, $c } from \"ivi\";\nimport { DBList, DB, EMPTY_QUERY } from \"./db\";\nimport { startFPSMonitor, startMemMonitor, initProfiler, startProfile, endProfile } from \"perf-monitor\";\n\nfunction entryFormatElapsed(v: number): string {\n    if (!v) {\n        return \"\";\n    }\n\n    if (v > 60) {\n        const minutes = Math.floor(v / 60);\n        const comps = (v % 60).toFixed(2).split(\".\");\n        const seconds = comps[0];\n        const ms = comps[1];\n        return minutes + \":\" + seconds + \".\" + ms;\n    }\n\n    return v.toFixed(2);\n}\n\nfunction counterClasses(count: number): string {\n    if (count >= 20) {\n        return \"label label-important\";\n    } else if (count >= 10) {\n        return \"label label-warning\";\n    }\n    return \"label label-success\";\n}\n\nfunction queryClasses(elapsed: number): string {\n    if (elapsed >= 10.0) {\n        return \"Query elapsed warn_long\";\n    } else if (elapsed >= 1.0) {\n        return \"Query elapsed warn\";\n    }\n    return \"Query elapsed short\";\n}\n\ncheckPropsIdentity(Popover);\nfunction Popover(query: string) {\n    return $h(\"div\", \"popover left\").children([\n        $h(\"div\", \"popover-content\").children(query),\n        $h(\"div\", \"arrow\"),\n    ]);\n}\n\ncheckPropsIdentity(DatabaseView);\nfunction DatabaseView(db: DB) {\n    const topFiveQueries = db.getTopFiveQueries();\n    const count = db.queries!.length;\n\n    const children = new Array<VNode<any>>(7);\n    children[0] = $h(\"td\", \"dbname\").children(db.name);\n    children[1] = $h(\"td\", \"query-count\").children(\n        $h(\"span\", counterClasses(count)).children(count),\n    );\n\n    for (let i = 0; i < 5; i++) {\n        const q = topFiveQueries[i];\n        const elapsed = q.elapsed;\n\n        if (q !== EMPTY_QUERY) {\n            children[i + 2] = $h(\"td\", queryClasses(elapsed)).children([\n                entryFormatElapsed(elapsed),\n                $c(Popover, q.query),\n            ]);\n        } else {\n            children[i + 2] = $h(\"td\", \"\").children([\n                \"\",\n                $c(Popover, q.query),\n            ]);\n        }\n    }\n\n    return $h(\"tr\").children(children);\n}\n\nfunction Main(props: DBList) {\n    const dbs = props.dbs;\n    const rows = new Array<VNode<any>>(dbs.length);\n    for (let i = 0; i < dbs.length; i++) {\n        rows[i] = $c(DatabaseView, dbs[i]);\n    }\n\n    return $h(\"table\")\n        .className(\"table table-striped latest-data\")\n        .children($h(\"tbody\").children(rows));\n}\n\nfunction parseQueryString(a: string[]): { [key: string]: string } {\n    if (a.length === 0) {\n        return {};\n    }\n    const b = {} as { [key: string]: string };\n    for (let i = 0; i < a.length; ++i) {\n        const p = a[i].split(\"=\", 2);\n        if (p.length === 1) {\n            b[p[0]] = \"\";\n        } else {\n            b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n        }\n    }\n    return b;\n}\n\nlet mutations = 0.5;\nlet N = 50;\n\nconst qs = parseQueryString(window.location.search.substr(1).split(\"&\"));\nif (qs[\"n\"] !== undefined) {\n    N = parseInt(qs[\"n\"], 10);\n}\nif (qs[\"m\"] !== undefined) {\n    mutations = parseFloat(qs[\"m\"]);\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    startFPSMonitor();\n    startMemMonitor();\n    initProfiler(\"view update\");\n\n    const dbs = new DBList(N);\n\n    const sliderContainer = document.createElement(\"div\");\n    sliderContainer.style.display = \"flex\";\n    const slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.style.marginBottom = \"10px\";\n    slider.style.marginTop = \"5px\";\n    const text = document.createElement(\"label\");\n    text.textContent = \"mutations : \" + (mutations * 100).toFixed(0) + \"%\";\n\n    slider.addEventListener(\"change\", (e) => {\n        mutations = Number.parseFloat((e.target as HTMLInputElement).value) / 100;\n        text.textContent = \"mutations : \" + (mutations * 100).toFixed(0) + \"%\";\n    });\n    sliderContainer.appendChild(text);\n    sliderContainer.appendChild(slider);\n    document.body.insertBefore(sliderContainer, document.body.firstChild);\n\n\n    const container = document.getElementById(\"app\") !;\n    render($c(Main, dbs), container);\n\n    function update() {\n        dbs.randomUpdate(mutations);\n\n        startProfile(\"view update\");\n        render($c(Main, dbs), container);\n        endProfile(\"view update\");\n\n        setTimeout(update, 0);\n    }\n    setTimeout(update, 0);\n});\n"]}