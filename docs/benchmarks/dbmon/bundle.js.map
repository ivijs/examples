{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/vnode.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/vnode_collections.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/user_agent.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/noop.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/array.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/error.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-scheduler/src/index.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/tslib/tslib.es6.js","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/shortcuts.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-core/src/const.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-events/src/sync_events.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/sync_dom.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/implementation.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi/src/vdom/vnode_factories.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/ivi-html/src/index.ts","webpack:///./src/db.ts","webpack:////home/void/w/ts/ivi-examples/node_modules/perf-monitor/dist/es5/perf-monitor.js","webpack:///./src/main.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","VNode","flags","tag","props","className","children","this","_f","_l","_r","_c","_t","_k","_p","_i","_cs","_s","_e","k","key","style","e","events","a","attrs","arguments","first","prev","length","last","unsafeHTML","html","getDOMInstanceFromVNode","node","map","array","fn","ua","navigator","userAgent","IOS_UA","test","window","NOOP","unorderedArrayDelete","index","pop","ERROR_HANDLERS","catchError","args","apply","_a","ERROR_HANDLERS_1","handler","runRepeatableTasks","tasks","run","t","tasks_1","task","_isHidden","_flags","_microtasks","_tasks","_visibilityObservers","_animations","_readers","_updateDOMHandler","_currentFrame","f","w","_nextFrame","_autofocusedElement","runMicrotasks","MessageChannel","port1","onmessage","ev","handleVisibilityChange","newHidden","requestNextFrame","observers","module_autofocus","Element","_requestNextFrame","requestAnimationFrame","_handleNextFrame","Promise","resolve","then","push","document","hidden","addEventListener","time","frame","focus","addFrameTaskWrite","triggerNextFrame","performance","now","setPrototypeOf","Array","__assign","assign","nodeProto","Node","elementProto","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeReplaceChild","replaceChild","nodeCloneNode","cloneNode","elementSetAttribute","setAttribute","elementSetAttributeNS","setAttributeNS","elementRemoveAttribute","removeAttribute","SVG_NAMESPACE","XLINK_NAMESPACE","XML_NAMESPACE","registerEventHandler","src","add","unregisterEventHandler","remove","syncEvents","b","h1","h2","attachEvents","detachEvents","h","syncStyle","bValue","undefined","setProperty","removeProperty","setDOMAttribute","svg","charCodeAt","startsWith","syncDOMAttrs","removeVNode","parent","vnode","_detach","_attach","child","attached","component","detached","dirtyCheck","context","dirtyContext","instance","deepUpdate","syncVNode","render","updated","connect","selectData","select","_removeAllChildren","firstVNode","textContent","_setInputValue","input","checked","_render","createTextNode","createElementNS","createElement","_ev","innerHTML","renderVNode","refChild","aFlags","bFlags","aChild","bChild","data","_syncChildrenTrackByKeys","oldProps","newProps","newPropsReceived","shouldUpdate","prevSelectData","sc","aStartVNode","bStartVNode","aEndVNode","bEndVNode","step1Synced","outer","next","nextNode","aInnerLength","bInnerLength","lastPosition","bInnerArray","explicitKeyIndex","implicitKeyIndex","Map","set","prevPositionsForB","fill","step2Synced","seq","lis","u","v","j","slice","result","ROOTS","EMPTY_CONTEXT","_pendingUpdate","findRoot","container","ROOTS_1","root","_update","update","currentVNode","invalidated","newVNode","onclick","indexOf","root_render","renderNextFrame","updateNextFrame","statelessComponent","div","span","tbody","td","MonitorWidgetFlags","Query","elapsed","query","rand","Math","random","EMPTY_QUERY","DB","id","_nextId","queries","floor","getTopFiveQueries","qs","sort","DBList","dbs","randomUpdate","MonitorMaxSamples","MonitorSamplesResult","min","max","mean","MonitorSamples","maxSamples","samples","addSample","each","calc","sum","frameTasks","rafId","perf_monitor_extends","extendStatics","__proto__","__","constructor","create","MonitorGraphHeight","MonitorGraphWidth","Widget","_this","_sync","sync","_dirty","element","cssText","invalidate","Error","MonitorWidget","_super","unitName","label","text","HideMin","minText","appendChild","HideMax","maxText","HideMean","meanText","HideLast","lastText","HideGraph","canvas","width","height","ctx","getContext","scale","RoundValues","toFixed","round","toString","fillStyle","fillRect","perf_monitor_container","CounterWidget","counter","checkInit","body","startFPSMonitor","fps","startMemMonitor","memory","usedJSHeapSize","setTimeout","ProfilerDetails","widget","startTime","profilerInstances","initProfiler","profiler","endProfile","mutations","N","split","decodeURIComponent","replace","parseQueryString","location","search","substr","parseInt","parseFloat","store","entryFormatElapsed","minutes","comps","counterClasses","count","descriptor","Popover","DatabaseList","db","topFiveQueries","q","Main","sliderContainer","display","slider","type","marginBottom","marginTop","Number","target","firstChild","getElementById","tick"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { CSSStyleProps, NOOP } from \"ivi-core\";\nimport { EventHandler } from \"ivi-events\";\nimport { checkDOMAttributesForTypos, checkDOMStylesForTypos, checkDeprecatedDOMSVGAttributes } from \"../dev_mode/typos\";\nimport { VNodeFlags } from \"./flags\";\nimport { StatelessComponent, StatefulComponent, Component } from \"./component\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\n\n/**\n * Virtual DOM Node.\n *\n * @example\n *\n *     const vnode = div(\"div-class-name\")\n *       .a({ id: \"div-id\" })\n *       .e(Events.onClick((e) => console.log(\"click event\", e)))\n *       .c(\"Hello\");\n *\n * @final\n */\nexport class VNode<P = any, N = Node> {\n  /**\n   * Flags, see {@link VNodeFlags} for details.\n   */\n  _f: VNodeFlags;\n  /**\n   * Circular link to previous sibling node (left).\n   */\n  _l: VNode;\n  /**\n   * Next sibling node (right).\n   */\n  _r: VNode | null;\n  /**\n   * Children.\n   */\n  _c: VNode | string | number | boolean | null;\n  /**\n   * Tag property contains details about the type of the element.\n   */\n  _t:\n    | string\n    | VNode\n    | StatefulComponent<any>\n    | StatelessComponent<any>\n    | ConnectDescriptor<any, any, {}>\n    | null;\n  /**\n   * Children syncing algorithm is using key property to match nodes. Key should be unique among its siblings.\n   */\n  _k: any;\n  /**\n   * Properties.\n   */\n  _p: P | undefined;\n  /**\n   * Reference to HTML node or Component instance.\n   *\n   * It will be available after virtual node is created or synced. Each time VNode is synced, reference will be\n   * transferred from the old VNode to the new one.\n   */\n  _i: N | Component<any> | {} | null;\n  /**\n   * Class name.\n   */\n  _cs: string | undefined;\n  /**\n   * Style.\n   */\n  _s: CSSStyleProps | null;\n  /**\n   * Events.\n   */\n  _e: Array<EventHandler | null> | EventHandler | null;\n  /**\n   * Factory function that was used to instantiate this node.\n   *\n   * It is used for debugging and testing purposes.\n   */\n  factory!: Function;\n\n  constructor(\n    flags: number,\n    tag:\n      | string\n      | VNode\n      | StatelessComponent<P>\n      | StatefulComponent<P>\n      | ConnectDescriptor<any, any, {}>\n      | null,\n    props: P | undefined,\n    className: string | undefined,\n    children:\n      | VNode\n      | string\n      | number\n      | boolean\n      | null,\n  ) {\n    this._f = flags;\n    this._l = this;\n    this._r = null;\n    this._c = children;\n    this._t = tag;\n    this._k = 0;\n    this._p = props;\n    this._i = null;\n    this._cs = className;\n    this._s = null;\n    this._e = null;\n    if (DEBUG) {\n      this.factory = NOOP;\n    }\n  }\n\n  /**\n   * Assigns a key.\n   *\n   * Children reconciliation algorithm is using keys to match nodes. Key should be unique among its siblings.\n   *\n   * @param key - Unique key\n   * @returns this node\n   */\n  k(key: any): this {\n    this._f |= VNodeFlags.Key;\n    this._k = key;\n    return this;\n  }\n\n  /**\n   * Assigns style for an Element node.\n   *\n   * @param style - Style\n   * @returns this node\n   */\n  s<U extends CSSStyleProps>(style: U | null): this {\n    if (DEBUG) {\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set style, style is available on element nodes only.\");\n      }\n\n      if (style !== null) {\n        checkDOMStylesForTypos(style);\n      }\n    }\n    this._s = style;\n    return this;\n  }\n\n  /**\n   * Assign events for an Element node.\n   *\n   * @param events - Events\n   * @returns this node\n   */\n  e(events: Array<EventHandler | null> | EventHandler | null): this {\n    if (DEBUG) {\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set events, events are available on element nodes only.\");\n      }\n    }\n    this._f |= VNodeFlags.ElementPropsEvents;\n    this._e = events;\n    return this;\n  }\n\n  /**\n   * Assigns DOM attributes for an Element node.\n   *\n   * @param attrs - DOM attributes\n   * @returns this node\n   */\n  a(attrs: P | null): this {\n    if (DEBUG) {\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set attrs, attrs are available on element nodes only.\");\n      }\n\n      if (attrs) {\n        checkDOMAttributesForTypos(attrs);\n\n        if (this._f & VNodeFlags.SvgElement) {\n          checkDeprecatedDOMSVGAttributes(this._t as string, attrs);\n        }\n      }\n    }\n    this._p = attrs as P;\n    return this;\n  }\n\n  /**\n   * Assigns children for an Element node.\n   *\n   * @param children - Children can be a simple string, single VNode or recursive list of VNodes with strings and null\n   *   values. It will automatically normalize recursive lists by flattening, filtering out null values and replacing\n   *   strings with text nodes.\n   * @returns this node\n   */\n  c(...children: Array<VNode | string | number | null>): this;\n  c(): this {\n    if (DEBUG) {\n      if (this._f & (VNodeFlags.ChildrenVNode | VNodeFlags.UnsafeHTML)) {\n        throw new Error(\"Failed to set children, VNode element is already having children.\");\n      }\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set children, children are available on element nodes only.\");\n      }\n      if (this._f & VNodeFlags.InputElement) {\n        throw new Error(\"Failed to set children, input elements can't have children.\");\n      }\n      if (this._f & VNodeFlags.TextAreaElement) {\n        throw new Error(\"Failed to set children, textarea elements can't have children.\");\n      }\n      if (this._f & VNodeFlags.MediaElement) {\n        throw new Error(\"Failed to set children, media elements can't have children.\");\n      }\n      if (this._f & VNodeFlags.VoidElement) {\n        throw new Error(`Failed to set children, ${this._t} elements can't have children.`);\n      }\n    }\n\n    const children: Array<VNode | string | number | null> = arguments as any;\n    let first: VNode<any> | null = null;\n    let prev: VNode<any> | null = null;\n\n    for (let i = 0, p = 0; i < children.length; ++i, ++p) {\n      let n = children[i];\n\n      if (n !== null) {\n        if (typeof n !== \"object\") {\n          n = new VNode<null>(VNodeFlags.Text, null, null, void 0, n);\n        }\n        const last = n._l;\n        const flags = n._f;\n        if (last === n) {\n          if ((flags & VNodeFlags.Key) === 0) {\n            n._k = p;\n          }\n        } else if ((flags & VNodeFlags.KeyedList) === 0) {\n          let c: VNode | null = n;\n          do {\n            if ((c!._f & VNodeFlags.Key) === 0) {\n              c!._k = p;\n            }\n            ++p;\n            c = c!._r;\n          } while (c !== null);\n          --p;\n        }\n\n        if (prev !== null) {\n          n._l = prev;\n          prev._r = n;\n        } else {\n          first = n;\n        }\n        prev = last;\n      }\n    }\n    if (first !== null) {\n      first._l = prev!;\n      this._f |= VNodeFlags.ChildrenVNode;\n      this._c = first;\n      if (DEBUG) {\n        checkUniqueKeys(first);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Assigns children as an innerHTML string. It is potentially vulnerable to XSS attacks.\n   *\n   * @param html innerHTML in a string format\n   * @returns this node\n   */\n  unsafeHTML(html: string | null): this {\n    if (DEBUG) {\n      if (this._f & VNodeFlags.ChildrenVNode) {\n        throw new Error(\"Failed to set unsafeHTML, VNode element is already having children.\");\n      }\n      if (!(this._f & VNodeFlags.Element)) {\n        throw new Error(\"Failed to set unsafeHTML, unsafeHTML is available on element nodes only.\");\n      }\n      if (this._f & VNodeFlags.InputElement) {\n        throw new Error(\"Failed to set unsafeHTML, input elements can't have innerHTML.\");\n      }\n      if (this._f & VNodeFlags.TextAreaElement) {\n        throw new Error(\"Failed to set unsafeHTML, textarea elements can't have innerHTML.\");\n      }\n      if (this._f & VNodeFlags.MediaElement) {\n        throw new Error(\"Failed to set unsafeHTML, media elements can't have children.\");\n      }\n      if (this._f & VNodeFlags.VoidElement) {\n        throw new Error(`Failed to set unsafeHTML, ${this._t} elements can't have children.`);\n      }\n    }\n    this._f |= VNodeFlags.UnsafeHTML;\n    this._c = html;\n    return this;\n  }\n\n  /**\n   * Assigns value for an HTMLInputElement and HTMLTextAreaElement elements.\n   *\n   * @param value - Input value\n   * @returns this node\n   */\n  value(value: string | boolean | null): this {\n    if (DEBUG) {\n      if (!(this._f & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement))) {\n        throw new Error(\"Failed to set value, value is available on input and textarea elements only.\");\n      }\n    }\n    this._c = value;\n    return this;\n  }\n}\n\n/**\n * getDOMInstanceFromVNode retrieves a reference to a DOM node from a VNode object.\n *\n * @param node VNode which contains reference to a DOM node.\n * @returns null if VNode doesn't have a reference to a DOM node.\n */\nexport function getDOMInstanceFromVNode<T extends Node>(node: VNode<any, T>): T | null {\n  if ((node._f & (\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) !== 0) {\n    return getDOMInstanceFromVNode<T>(node._c as VNode<any, T>);\n  }\n  return node._i as T;\n}\n\n/**\n * getComponentInstanceFromVNode retrieves a reference to a Component instance from a VNode object.\n *\n * @param vnode - Virtual DOM node which contains reference to a Component instance\n * @returns `null` if `vnode` doesn't have a reference to a Component instance\n */\nexport function getComponentInstanceFromVNode<T extends Component<any>>(vnode: VNode): T | null {\n  if (DEBUG) {\n    if ((vnode._f & (\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    )) === 0) {\n      throw new Error(\"Failed to get component instance: VNode should represent a Component.\");\n    }\n  }\n  return vnode._i as T | null;\n}\n\n/**\n * autofocus makes an element focused after instantiation.\n *\n * @param vnode - Virtual DOM node\n * @return `vnode`\n */\nexport function autofocus<N extends VNode>(vnode: N): N {\n  if (DEBUG) {\n    if (!(vnode._f & (\n      VNodeFlags.Element |\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    ))) {\n      throw new Error(\"Failed to set autofocus, autofocus is available on element and component nodes only.\");\n    }\n  }\n  vnode._f |= VNodeFlags.Autofocus;\n  return vnode;\n}\n\n/**\n * stopDirtyChecking stops dirty checking process when it goes through this virtual DOM node.\n *\n * @param vnode - Virtual DOM node\n * @returns `vnode`\n */\nexport function stopDirtyChecking<N extends VNode>(vnode: N): N {\n  vnode._f |= VNodeFlags.StopDirtyChecking;\n  return vnode;\n}\n\n/**\n * checkUniqueKeys checks that all nodes have unique keys.\n *\n * @param children - Children nodes\n */\nfunction checkUniqueKeys(children: VNode): void {\n  let keys: Set<any> | undefined;\n  let node: VNode<any> | null = children;\n  while (node !== null) {\n    if (node._f & VNodeFlags.Key) {\n      if (keys === undefined) {\n        keys = new Set<any>();\n      } else if (keys.has(node._k)) {\n        throw new Error(`Failed to set children, invalid children list, key: \"${node._k}\" is used multiple times.`);\n      }\n      keys.add(node._k);\n    }\n    node = node._r;\n  }\n}\n","import { VNodeFlags } from \"./flags\";\nimport { VNode } from \"./vnode\";\n\n/**\n * fragment is a variadic function that creates a children collection.\n *\n * @example\n *\n *     const content = children(\n *       h.p().c(\"Paragraph 1\"),\n *       h.p().c(\"Paragraph 2\"),\n *     );\n *\n *     render(\n *       h.div().c(\n *         h.h1().c(\"Title\"),\n *         content,\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param args - Children\n * @returns Virtual DOM collection\n */\nexport function fragment(...args: Array<VNode | string | number | null>): VNode | null;\n\n/**\n * fragment is a variadic function that creates a children collection.\n *\n * @example\n *\n *     const content = children(\n *       h.p().c(\"Paragraph 1\"),\n *       h.p().c(\"Paragraph 2\"),\n *     );\n *\n *     render(\n *       h.div().c(\n *         h.h1().c(\"Title\"),\n *         content,\n *       ),\n *       DOMContainer,\n *     );\n *\n * @returns Virtual DOM collection\n */\nexport function fragment(): VNode | null {\n  const args: Array<VNode | string | number | null> = arguments as any;\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n\n  for (let i = 0; i < args.length; ++i) {\n    let n = args[i];\n\n    if (n !== null) {\n      if (typeof n !== \"object\") {\n        n = new VNode<null>(VNodeFlags.Text, null, null, void 0, n);\n      }\n      const last = n._l;\n      if (prev !== null) {\n        n._l = prev;\n        prev._r = n;\n      } else {\n        first = n;\n      }\n      prev = last;\n    }\n  }\n  if (first !== null) {\n    first._l = prev!;\n  }\n\n  return first;\n}\n\n/**\n * map creates a children collection with the results of calling a provided function on every element in the calling\n * array.\n *\n * @example\n *\n *     render(\n *       h.div().c(\n *         map([1, 2, 3], (item) => h.div().k(item)),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param items - Array\n * @param fn - Function that produces an element for the children collection\n * @returns Virtual DOM collection\n */\nexport function map<T, U>(array: Array<T>, fn: (item: T, index: number) => VNode<U> | null): VNode<U> | null {\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n  for (let i = 0; i < array.length; ++i) {\n    const n = fn(array[i], i);\n    if (n !== null) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if ((n._f & VNodeFlags.Key) === 0) {\n          throw new Error(`VNodes created with a map() function should have an explicit key`);\n        }\n        if (n._l !== n) {\n          throw new Error(`VNodes created with a map() function should be a singular nodes`);\n        }\n      }\n      if (prev !== null) {\n        n._l = prev;\n        prev._r = n;\n      } else {\n        first = n;\n      }\n      prev = n;\n    }\n  }\n  if (first !== null) {\n    first._l = prev!;\n    first._f |= VNodeFlags.KeyedList;\n    return first;\n  }\n  return null;\n}\n\n/**\n * mapRange creates a children collection with the results of calling a provided function on every number in the\n * provided range.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *\n *     render(\n *       h.div().c(\n *         mapRange(0, items.length, (i) => h.div().k(items[i])),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param start - Range start\n * @param end - Range end\n * @param fn - Function that produces an element for the children collection\n * @returns Virtual DOM collection\n */\nexport function mapRange<T>(start: number, end: number, fn: (idx: number) => VNode<T> | null): VNode<T> | null {\n  const length = end - start;\n  let first: VNode<any> | null = null;\n  let prev: VNode<any> | null = null;\n  while (start < length) {\n    const n = fn(start++);\n    if (n !== null) {\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if ((n._f & VNodeFlags.Key) === 0) {\n          throw new Error(`VNodes created with a mapRange() function should have an explicit key`);\n        }\n        if (n._l !== n) {\n          throw new Error(`VNodes created with a mapRange() function should be a singular nodes`);\n        }\n      }\n      if (prev !== null) {\n        n._l = prev;\n        prev._r = n;\n      } else {\n        first = n;\n      }\n      prev = n;\n    }\n  }\n  if (first !== null) {\n    first._l = prev!;\n    first._f |= VNodeFlags.KeyedList;\n    return first;\n  }\n  return null;\n}\n","/**\n * User Agent detection is used to fix some quirks like iOS event bubbling, etc.\n *\n * NOTE: Do not implement any browser detection that aren't used in `ivi` library.\n */\n\nconst ua = navigator.userAgent;\n\n/**\n * iOS User Agent.\n */\nexport const IOS_UA = (TARGET !== \"electron\") && (/iPad|iPhone|iPod/.test(ua) && !(\"MSStream\" in window));\n","/**\n * NOOP function.\n */\nexport function NOOP(): void {\n  /* tslint:disable:no-empty */\n  /* tslint:enable:no-empty */\n}\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport function NOOP_FALSE(): boolean {\n  return false;\n}\n","/**\n * append pushes item to an array and automatically create a new array when it doesn't exist.\n *\n * @param array Array\n * @param item Item\n * @returns Array\n */\nexport function append<T>(array: T[] | null, item: T): T[] {\n  if (array === null) {\n    return [item];\n  }\n  array.push(item);\n  return array;\n}\n\n/**\n * unorderedArrayDelete deletes element from an array with O(1) complexity.\n *\n * It swaps element at `index` position with the last element and removes the last one.\n *\n * @param array Array\n * @param index Index of an element to remove\n */\nexport function unorderedArrayDelete<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn function to decorate.\n * @returns function decorated with a catchError.\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T {\n  return (...args: any[]) => {\n    try {\n      return fn(...args);\n    } catch (e) {\n      for (const handler of ERROR_HANDLERS) {\n        handler(e);\n      }\n      throw e;\n    }\n  };\n}\n","import { unorderedArrayDelete } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | undefined>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks repeatable tasks.\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDelete(tasks, i--);\n    }\n  }\n}\n","import { RepeatableTaskList, runRepeatableTasks, NOOP, unorderedArrayDelete, catchError } from \"ivi-core\";\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  Hidden = 1,\n  VisibilityObserversCOW = 1 << 1,\n  MicrotaskPending = 1 << 2,\n  TaskPending = 1 << 3,\n  NextFramePending = 1 << 4,\n  CurrentFrameReady = 1 << 5,\n}\n\n/**\n * Frame Tasks Group flags.\n */\nconst enum FrameTasksGroupFlags {\n  /**\n   * Group contains update task.\n   */\n  Update = 1,\n  /**\n   * Group contains \"write\" tasks.\n   */\n  Write = 1 << 1,\n  /**\n   * Group contains \"read\" tasks\".\n   */\n  Read = 1 << 2,\n  /**\n   * Group contains \"after\" tasks.\n   */\n  After = 1 << 3,\n}\n\ninterface TaskList {\n  a: Array<() => void>;\n}\n\n/**\n * createTaskList creates a task list.\n *\n * @returns Task list.\n */\nfunction createTaskList(): TaskList {\n  return { a: [] };\n}\n\nfunction run(t: TaskList) {\n  const tasks = t.a;\n  t.a = [];\n  for (const task of tasks) {\n    task();\n  }\n}\n\n/**\n * FrameTasksGroup contains tasks for read and write DOM tasks, and tasks that should be executed after all other tasks\n * are finished.\n *\n * @final\n */\ninterface FrameTasksGroup {\n  /**\n   * See `FrameTasksGroupFlags` for details.\n   */\n  f: number;\n  /**\n   * Write DOM task queue.\n   */\n  w: TaskList;\n  /**\n   * Read DOM task queue.\n   */\n  r: TaskList;\n  /**\n   * Tasks that should be executed when all other frame tasks are finished.\n   */\n  a: TaskList;\n}\n\nfunction createFrameTasksGroup(): FrameTasksGroup {\n  return {\n    f: 0,\n    w: createTaskList(),\n    r: createTaskList(),\n    a: createTaskList(),\n  };\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _clock = 0;\nconst _microtasks = createTaskList();\nconst _tasks = createTaskList();\n\nlet _visibilityObservers: Array<(hidden: boolean) => void> = [];\nlet _isHidden: () => boolean;\n\nconst _animations: RepeatableTaskList = [];\nconst _readers: RepeatableTaskList = [];\nlet _updateDOMHandler: () => void = NOOP;\nlet _currentFrame = createFrameTasksGroup();\nlet _nextFrame = createFrameTasksGroup();\nlet _currentFrameStartTime = 0;\nlet _autofocusedElement: Element | null = null;\n\nconst runMicrotasks = catchError(() => {\n  while (_microtasks.a.length > 0) {\n    run(_microtasks);\n  }\n\n  _flags ^= SchedulerFlags.MicrotaskPending;\n  ++_clock;\n});\n\n// Task scheduler based on MessageChannel\nconst _taskChannel = new MessageChannel();\n_taskChannel.port1.onmessage = catchError((ev: MessageEvent) => {\n  _flags ^= SchedulerFlags.TaskPending;\n  run(_tasks);\n  ++_clock;\n});\n\nconst handleVisibilityChange = catchError(() => {\n  const newHidden = _isHidden();\n  if (((_flags & SchedulerFlags.Hidden) !== 0) !== newHidden) {\n    _flags ^= SchedulerFlags.Hidden | SchedulerFlags.VisibilityObserversCOW;\n\n    if (!newHidden && (_animations.length > 0)) {\n      requestNextFrame();\n    }\n\n    const observers = _visibilityObservers;\n    for (let i = 0; i < observers.length; ++i) {\n      observers[i](newHidden);\n    }\n    _flags ^= SchedulerFlags.VisibilityObserversCOW;\n  }\n});\n\nif (TARGET !== \"browser\" || typeof document[\"hidden\"] !== \"undefined\") {\n  _isHidden = () => document.hidden;\n  document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n} else if (typeof (document as any)[\"webkitHidden\"] !== \"undefined\") {\n  /**\n   * #quirks\n   *\n   * Android 4.4\n   */\n  _isHidden = () => (document as any)[\"webkitHidden\"];\n  document.addEventListener(\"webkitvisibilitychange\", handleVisibilityChange);\n} else {\n  _isHidden = () => false;\n}\nif (_isHidden()) {\n  _flags |= SchedulerFlags.Hidden;\n}\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport function clock(): number {\n  return _clock;\n}\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task Microtask.\n */\nexport function scheduleMicrotask(task: () => void): void {\n  if (!(_flags & SchedulerFlags.MicrotaskPending)) {\n    _flags |= SchedulerFlags.MicrotaskPending;\n    Promise.resolve().then(runMicrotasks);\n  }\n  _microtasks.a.push(task);\n}\n\n/**\n * scheduleTask adds task to the task queue.\n *\n * @param task Task.\n */\nexport function scheduleTask(task: () => void): void {\n  if (!(_flags & SchedulerFlags.TaskPending)) {\n    _flags |= SchedulerFlags.TaskPending;\n    _taskChannel.port2.postMessage(0);\n  }\n  _tasks.a.push(task);\n}\n\nexport function isHidden(): boolean {\n  return (_flags & SchedulerFlags.Hidden) !== 0;\n}\n\nexport function addVisibilityObserver(observer: (visible: boolean) => void): void {\n  if (_flags & SchedulerFlags.VisibilityObserversCOW) {\n    _visibilityObservers = _visibilityObservers.slice();\n  }\n  _visibilityObservers.push(observer);\n}\n\nexport function removeVisibilityObserver(observer: (visible: boolean) => void): void {\n  if (_flags & SchedulerFlags.VisibilityObserversCOW) {\n    _visibilityObservers = _visibilityObservers.slice();\n  }\n  const index = _visibilityObservers.indexOf(observer);\n  if (index > -1) {\n    unorderedArrayDelete(_visibilityObservers, index);\n  }\n}\n\nexport function setUpdateDOMHandler(handler: () => void): void {\n  _updateDOMHandler = handler;\n}\n\n/**\n * addAnimation adds animation to the RepeatableTaskList.\n *\n * @param animation Animation task.\n */\nexport function addAnimation(animation: () => boolean | undefined): void {\n  _animations.push(animation);\n  requestNextFrame();\n}\n\n/**\n * addDOMReader adds DOM Reader to the RepeatableTaskList.\n *\n * DOM Reader will be be invoked on each frame in the read phase.\n *\n * @param reader Task that will be executed until it returns `false`.\n */\nexport function addDOMReader(reader: () => boolean | undefined): void {\n  _readers.push(reader);\n}\n\nexport function autofocus(node: Node): void {\n  if (node instanceof Element) {\n    _autofocusedElement = node;\n  }\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport function currentFrameStartTime(): number {\n  return _currentFrameStartTime;\n}\n\nfunction _requestNextFrame(): void {\n  if (_flags & SchedulerFlags.NextFramePending) {\n    requestAnimationFrame(_handleNextFrame);\n  }\n}\n\n/**\n * requestNextFrame triggers next frame tasks execution.\n */\nexport function requestNextFrame(): void {\n  if (!(_flags & SchedulerFlags.NextFramePending)) {\n    _flags |= SchedulerFlags.NextFramePending;\n    scheduleMicrotask(_requestNextFrame);\n  }\n}\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = catchError((time: number) => {\n  _flags ^= SchedulerFlags.NextFramePending | SchedulerFlags.CurrentFrameReady;\n  _currentFrameStartTime = time;\n\n  const frame = _nextFrame;\n  _nextFrame = _currentFrame;\n  _currentFrame = frame;\n\n  runRepeatableTasks(_readers);\n\n  // Perform read/write batching. Start with executing read DOM tasks, then update components, execute write DOM tasks\n  // and repeat until all read and write tasks are executed.\n  do {\n    while (frame.f & FrameTasksGroupFlags.Read) {\n      frame.f ^= FrameTasksGroupFlags.Read;\n      run(frame.r);\n    }\n\n    while (frame.f & (FrameTasksGroupFlags.Update | FrameTasksGroupFlags.Write)) {\n      if (frame.f & FrameTasksGroupFlags.Write) {\n        frame.f ^= FrameTasksGroupFlags.Write;\n        run(frame.w);\n      }\n\n      if (frame.f & FrameTasksGroupFlags.Update) {\n        frame.f ^= FrameTasksGroupFlags.Update;\n        _updateDOMHandler();\n      }\n    }\n  } while (frame.f & (\n    FrameTasksGroupFlags.Update |\n    FrameTasksGroupFlags.Write |\n    FrameTasksGroupFlags.Read\n  ));\n\n  _flags ^= SchedulerFlags.CurrentFrameReady;\n\n  if (!(_flags & SchedulerFlags.Hidden)) {\n    runRepeatableTasks(_animations);\n  }\n\n  // Perform tasks that should be executed when all DOM ops are finished.\n  while ((frame.f & FrameTasksGroupFlags.After)) {\n    frame.f ^= FrameTasksGroupFlags.After;\n    run(frame.a);\n  }\n\n  if (_autofocusedElement !== null) {\n    (_autofocusedElement as HTMLElement).focus();\n    _autofocusedElement = null;\n  }\n\n  if (_animations.length) {\n    requestNextFrame();\n  }\n\n  ++_clock;\n});\n\nfunction addFrameTaskUpdate(frame: FrameTasksGroup): void {\n  frame.f |= FrameTasksGroupFlags.Update;\n}\n\nfunction addFrameTaskWrite(frame: FrameTasksGroup, task: () => void): void {\n  frame.f |= FrameTasksGroupFlags.Write;\n  frame.w.a.push(task);\n}\n\nfunction addFrameTaskRead(frame: FrameTasksGroup, task: () => void): void {\n  frame.f |= FrameTasksGroupFlags.Read;\n  frame.r.a.push(task);\n}\n\nfunction addFrameTaskAfter(frame: FrameTasksGroup, task: () => void): void {\n  frame.f |= FrameTasksGroupFlags.After;\n  frame.a.a.push(task);\n}\n\nexport function nextFrameUpdate(): void {\n  requestNextFrame();\n  addFrameTaskUpdate(_nextFrame);\n}\n\nexport function nextFrameWrite(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskWrite(_nextFrame, task);\n}\n\nexport function nextFrameRead(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskRead(_nextFrame, task);\n}\n\nexport function nextFrameAfter(task: () => void): void {\n  requestNextFrame();\n  addFrameTaskAfter(_nextFrame, task);\n}\n\nexport function currentFrameUpdate(): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskUpdate(_currentFrame);\n  } else {\n    nextFrameUpdate();\n  }\n}\n\nexport function currentFrameWrite(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskWrite(_currentFrame, task);\n  } else {\n    nextFrameWrite(task);\n  }\n}\n\nexport function currentFrameRead(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskRead(_currentFrame, task);\n  } else {\n    nextFrameRead(task);\n  }\n}\n\nexport function currentFrameAfter(task: () => void): void {\n  if (_flags & SchedulerFlags.CurrentFrameReady) {\n    addFrameTaskAfter(_currentFrame, task);\n  } else {\n    nextFrameAfter(task);\n  }\n}\n\n/**\n * triggerNextFrame triggers an update for the next frame.\n */\nexport function triggerNextFrame(): void {\n  if (_flags & SchedulerFlags.NextFramePending) {\n    _handleNextFrame(performance.now());\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\nexport const nodeInsertBefore = nodeProto.insertBefore;\nexport const nodeRemoveChild = nodeProto.removeChild;\nexport const nodeReplaceChild = nodeProto.replaceChild;\nexport const nodeCloneNode = nodeProto.cloneNode;\nexport const elementSetAttribute = elementProto.setAttribute;\nexport const elementSetAttributeNS = elementProto.setAttributeNS;\nexport const elementRemoveAttribute = elementProto.removeAttribute;\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n\n/**\n * KeyboardEvent keyCode values.\n */\nexport const enum KeyCode {\n  WinKeyFFLinux = 0,\n  MacEnter = 3,\n  Backspace = 8,\n  Tab = 9,\n  Clear = 12,\n  Enter = 13,\n  Shift = 16,\n  Control = 17,\n  Alt = 18,\n  Pause = 19,\n  CapsLock = 20,\n  Escape = 27,\n  Space = 32,\n  PageUp = 33,\n  PageDown = 34,\n  End = 35,\n  Home = 36,\n  ArrowLeft = 37,\n  ArrowUp = 38,\n  ArrowRight = 39,\n  ArrowDown = 40,\n  NumNorthEast = 33,\n  NumSouthEast = 34,\n  NumSouthWest = 35,\n  NumNorthWest = 36,\n  NumWest = 37,\n  NumNorth = 38,\n  NumEast = 39,\n  NumSouth = 40,\n  PrintScreen = 44,\n  Insert = 45,\n  NumInsert = 45,\n  Delete = 46,\n  NumDelete = 46,\n  Zero = 48,\n  Ono = 49,\n  Two = 50,\n  Three = 51,\n  Four = 52,\n  Five = 53,\n  Six = 54,\n  Seven = 55,\n  Eight = 56,\n  Nine = 57,\n  FFSemicolon = 59,\n  FFEquals = 61,\n  /**\n   * US keyboard layouts only.\n   */\n  QuestionMark = 63,\n  A = 65,\n  B = 66,\n  C = 67,\n  D = 68,\n  E = 69,\n  F = 70,\n  G = 71,\n  H = 72,\n  I = 73,\n  J = 74,\n  K = 75,\n  L = 76,\n  M = 77,\n  N = 78,\n  O = 79,\n  P = 80,\n  Q = 81,\n  R = 82,\n  S = 83,\n  T = 84,\n  U = 85,\n  V = 86,\n  W = 87,\n  X = 88,\n  Y = 89,\n  Z = 90,\n  Meta = 91,\n  WinKeyLeft = 91,\n  WinKeyRight = 92,\n  ContextMenu = 93,\n  NumZero = 96,\n  NumOne = 97,\n  NumTwo = 98,\n  NumThree = 99,\n  NumFour = 100,\n  NumFive = 101,\n  NumSix = 102,\n  NumSeven = 103,\n  NumEight = 104,\n  NumNine = 105,\n  NumMultiply = 106,\n  NumPlus = 107,\n  NumMinus = 109,\n  NumPeriod = 110,\n  NumDivision = 111,\n  F1 = 112,\n  F2 = 113,\n  F3 = 114,\n  F4 = 115,\n  F5 = 116,\n  F6 = 117,\n  F7 = 118,\n  F8 = 119,\n  F9 = 120,\n  F10 = 121,\n  F11 = 122,\n  F12 = 123,\n  NumLock = 144,\n  ScrollLock = 145,\n  /**\n   * First OS specific media key.\n   */\n  FirstMediaKey = 166,\n  /**\n   * Last OS specific media key.\n   */\n  LastMediaKey = 183,\n  /**\n   * US keyboard layouts only.\n   */\n  Semicolon = 186,\n  /**\n   * US keyboard layouts only.\n   */\n  Dash = 189,\n  /**\n   * US keyboard layouts only.\n   */\n  Equals = 187,\n  /**\n   * US keyboard layouts only.\n   */\n  Comma = 188,\n  /**\n   * US keyboard layouts only.\n   */\n  Period = 190,\n  /**\n   * US keyboard layouts only.\n   */\n  Slash = 191,\n  /**\n   * US keyboard layouts only.\n   */\n  Apostrophe = 192,\n  /**\n   * US keyboard layouts only.\n   */\n  Tilde = 192,\n  /**\n   * US keyboard layouts only.\n   */\n  SingleQuote = 222,\n  /**\n   * US keyboard layouts only.\n   */\n  OpenSquareBracket = 219,\n  /**\n   * US keyboard layouts only.\n   */\n  Backslash = 220,\n  /**\n   * US keyboard layouts only.\n   */\n  CloseSquareBracket = 221,\n  Win = 224,\n  MacFFMeta = 224,\n  WinIME = 229,\n}\n\n/**\n * KeyboardEvent keyLocation values.\n */\nexport const enum KeyLocation {\n  Standard = 0,\n  Left = 1,\n  Right = 2,\n  NumPad = 3,\n  Mobile = 4,\n  Joystick = 5,\n}\n\n/**\n * Flags for MouseEvent buttons property.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nexport const enum MouseButtons {\n  Left = 1,\n  Right = 1 << 1,\n  /**\n   * Wheel or middle button.\n   */\n  Middle = 1 << 2,\n  /**\n   * Typically the \"Browser Back\" button.\n   */\n  Fourh = 1 << 3,\n  /**\n   * Typically the \"Browser Forward\" button.\n   */\n  Fifth = 1 << 4,\n}\n\nexport type KeyName =\n  \"Accept\" |\n  \"Add\" |\n  \"Again\" |\n  \"AllCandidates\" |\n  \"Alphanumeric\" |\n  \"Alt\" |\n  \"AltGraph\" |\n  \"Apps\" |\n  \"Attn\" |\n  \"BrowserBack\" |\n  \"BrowserFavorites\" |\n  \"BrowserForward\" |\n  \"BrowserHome\" |\n  \"BrowserRefresh\" |\n  \"BrowserSearch\" |\n  \"BrowserStop\" |\n  \"Camera\" |\n  \"CapsLock\" |\n  \"Clear\" |\n  \"CodeInput\" |\n  \"Compose\" |\n  \"Control\" |\n  \"Crsel\" |\n  \"Convert\" |\n  \"Copy\" |\n  \"Cut\" |\n  \"Decimal\" |\n  \"Divide\" |\n  \"Down\" |\n  \"DownLeft\" |\n  \"DownRight\" |\n  \"Eject\" |\n  \"End\" |\n  \"Enter\" |\n  \"EraseEof\" |\n  \"Execute\" |\n  \"Exsel\" |\n  \"Fn\" |\n  \"F1\" |\n  \"F2\" |\n  \"F3\" |\n  \"F4\" |\n  \"F5\" |\n  \"F6\" |\n  \"F7\" |\n  \"F8\" |\n  \"F9\" |\n  \"F10\" |\n  \"F11\" |\n  \"F12\" |\n  \"F13\" |\n  \"F14\" |\n  \"F15\" |\n  \"F16\" |\n  \"F17\" |\n  \"F18\" |\n  \"F19\" |\n  \"F20\" |\n  \"F21\" |\n  \"F22\" |\n  \"F23\" |\n  \"F24\" |\n  \"FinalMode\" |\n  \"Find\" |\n  \"FullWidth\" |\n  \"HalfWidth\" |\n  \"HangulMode\" |\n  \"HanjaMode\" |\n  \"Help\" |\n  \"Hiragana\" |\n  \"Home\" |\n  \"Insert\" |\n  \"JapaneseHiragana\" |\n  \"JapaneseKatakana\" |\n  \"JapaneseRomaji\" |\n  \"JunjaMode\" |\n  \"KanaMode\" |\n  \"KanjiMode\" |\n  \"Katakana\" |\n  \"LaunchApplication1\" |\n  \"LaunchApplication2\" |\n  \"LaunchMail\" |\n  \"Left\" |\n  \"Menu\" |\n  \"Meta\" |\n  \"MediaNextTrack\" |\n  \"MediaPlayPause\" |\n  \"MediaPreviousTrack\" |\n  \"MediaStop\" |\n  \"ModeChange\" |\n  \"NextCandidate\" |\n  \"Nonconvert\" |\n  \"NumLock\" |\n  \"PageDown\" |\n  \"PageUp\" |\n  \"Paste\" |\n  \"Pause\" |\n  \"Play\" |\n  \"Power\" |\n  \"PreviousCandidate\" |\n  \"PrintScreen\" |\n  \"Process\" |\n  \"Props\" |\n  \"Right\" |\n  \"RomanCharacters\" |\n  \"Scroll\" |\n  \"Select\" |\n  \"SelectMedia\" |\n  \"Separator\" |\n  \"Shift\" |\n  \"Soft1\" |\n  \"Soft2\" |\n  \"Soft3\" |\n  \"Soft4\" |\n  \"Stop\" |\n  \"Subtract\" |\n  \"SymbolLock\" |\n  \"Up\" |\n  \"UpLeft\" |\n  \"UpRight\" |\n  \"Undo\" |\n  \"VolumeDown\" |\n  \"VolumeMute\" |\n  \"VolumeUp\" |\n  \"Win\" |\n  \"Zoom\" |\n  \"Backspace\" |\n  \"Tab\" |\n  \"Cancel\" |\n  \"Esc\" |\n  \"Spacebar\" |\n  \"Del\" |\n  \"DeadGrave\" |\n  \"DeadEacute\" |\n  \"DeadCircumflex\" |\n  \"DeadTilde\" |\n  \"DeadMacron\" |\n  \"DeadBreve\" |\n  \"DeadAboveDot\" |\n  \"DeadUmlaut\" |\n  \"DeadAboveRing\" |\n  \"DeadDoubleacute\" |\n  \"DeadCaron\" |\n  \"DeadCedilla\" |\n  \"DeadOgonek\" |\n  \"DeadIota\" |\n  \"DeadVoicedSound\" |\n  \"DeadSemivoicedSound\" |\n  \"Unidentified\";\n","import { EventHandler } from \"./event_handler\";\nimport { EventHandlerFlags } from \"./flags\";\n\n/**\n * registerEventHandler is a shortcut for Event Handler registration.\n *\n * @param handler Event Handler.\n */\nfunction registerEventHandler(handler: EventHandler<any>): void {\n  if (DEBUG) {\n    handler.flags |= EventHandlerFlags.Active;\n  }\n  handler.src.add(handler);\n}\n\n/**\n * unregisterEventHandler is a shortcut for Event Handler unregistration.\n *\n * @param handler Event Handler.\n */\nfunction unregisterEventHandler(handler: EventHandler<any>): void {\n  if (DEBUG) {\n    handler.flags &= ~EventHandlerFlags.Active;\n  }\n  handler.src.remove(handler);\n}\n\n/**\n * syncEvents syncs event handlers and invokes EventSource callbacks when event handler is attached or detached.\n *\n * @param a Old event handlers.\n * @param b New event handlers.\n */\nexport function syncEvents(\n  a: Array<EventHandler | null> | EventHandler | null,\n  b: Array<EventHandler | null> | EventHandler | null,\n): void {\n  let i: number;\n  let h1: EventHandler | null;\n  let h2: EventHandler | null;\n\n  if (a === null) {\n    attachEvents(b!);\n  } else if (b === null) {\n    detachEvents(a);\n  } else {\n    if (a instanceof Array) {\n      if (b instanceof Array) {\n        i = 0;\n        while (i < a.length && i < b.length) {\n          h1 = a[i];\n          h2 = b[i++];\n          if (h1 !== h2) {\n            if (h2 !== null) {\n              registerEventHandler(h2);\n            }\n            if (h1 !== null) {\n              unregisterEventHandler(h1);\n            }\n          }\n        }\n        while (i < b.length) {\n          h1 = b[i++];\n          if (h1 !== null) {\n            registerEventHandler(h1);\n          }\n        }\n        while (i < a.length) {\n          h1 = a[i++];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      } else {\n        registerEventHandler(b as EventHandler);\n\n        for (i = 0; i < a.length; ++i) {\n          h1 = a[i];\n          if (h1 !== null) {\n            unregisterEventHandler(h1);\n          }\n        }\n      }\n    } else {\n      attachEvents(b);\n      unregisterEventHandler(a as EventHandler);\n    }\n  }\n}\n\n/**\n * attachEvents attaches event handlers and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function attachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        registerEventHandler(h);\n      }\n    }\n  } else {\n    registerEventHandler(events as EventHandler);\n  }\n}\n\n/**\n * detachEvents detaches events handles and invokes EventSource callbacks.\n *\n * @param events Event handlers.\n */\nexport function detachEvents(events: Array<EventHandler | null> | EventHandler): void {\n  if (events instanceof Array) {\n    for (let i = 0; i < events.length; ++i) {\n      const h = events[i];\n      if (h !== null) {\n        unregisterEventHandler(h);\n      }\n    }\n  } else {\n    unregisterEventHandler(events as EventHandler);\n  }\n}\n","import {\n  XML_NAMESPACE, XLINK_NAMESPACE, CSSStyleProps, elementRemoveAttribute, elementSetAttribute, elementSetAttributeNS,\n} from \"ivi-core\";\n\n/**\n * Sync DOM styles.\n *\n * @param node - HTML or SVG Element\n * @param a - Prev styles\n * @param b - Next styles\n */\nexport function syncStyle(\n  node: HTMLElement | SVGElement,\n  a: CSSStyleProps | null,\n  b: CSSStyleProps | null,\n): void {\n  const style = node.style;\n  let key: string;\n  let bValue;\n\n  if (a === null) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== undefined) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b !== null) {\n    for (key in b) {\n      bValue = (b as { [key: string]: string })[key];\n      if ((a as { [key: string]: string })[key] !== bValue) {\n        if (bValue !== undefined) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Set DOM attribute.\n *\n * @param node - HTML or SVG Element\n * @param svg - SVG Element\n * @param key - Attribute name\n * @param value - Attribute value\n */\nfunction setDOMAttribute(node: Element, svg: boolean, key: string, value: any): void {\n  if (typeof value === \"boolean\") {\n    if (value) {\n      value = \"\";\n    } else {\n      return;\n    }\n  }\n  if (svg === true) {\n    if (key.length > 5) {\n      if (key.charCodeAt(0) === 120 &&\n        // 58 === \":\"\n        (\n          key.charCodeAt(3) === 58 || // \"xml:\"\n          key.charCodeAt(5) === 58    // \"xlink:\"\n        )\n      ) {\n        if (key.startsWith(\"xml:\")) {\n          /**\n           * All attributes that starts with an \"xml:\" prefix will be assigned with XML namespace.\n           */\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.setAttributeNS(XML_NAMESPACE, key, value);\n          } else {\n            elementSetAttributeNS.call(node, XML_NAMESPACE, key, value);\n          }\n          return;\n        } else if (key.startsWith(\"xlink:\")) {\n          /**\n           * All attributes that starts with an \"xlink:\" prefix will be assigned with XLINK namespace.\n           */\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.setAttributeNS(XLINK_NAMESPACE, key, value);\n          } else {\n            elementSetAttributeNS.call(node, XLINK_NAMESPACE, key, value);\n          }\n          return;\n        }\n      }\n    }\n  }\n  /* istanbul ignore else */\n  if (DEBUG) {\n    node.setAttribute(key, value);\n  } else {\n    elementSetAttribute.call(node, key, value);\n  }\n}\n\n/**\n * Sync DOM attributes.\n *\n * @param node - HTML or SVG Element\n * @param svg - SVG Element\n * @param a - Prev DOM properties\n * @param b - Next DOM properties\n */\nexport function syncDOMAttrs(\n  node: Element,\n  svg: boolean,\n  a: { [key: string]: any } | null,\n  b: { [key: string]: any } | null,\n): void {\n  let key: string;\n  let bValue;\n\n  if (a === null) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      bValue = b![key];\n      if (bValue !== undefined) {\n        setDOMAttribute(node, svg, key, bValue);\n      }\n    }\n  } else if (b !== null) {\n    for (key in b) {\n      bValue = b[key];\n      if (a[key] !== bValue) {\n        if (bValue !== undefined) {\n          setDOMAttribute(node, svg, key, bValue);\n        } else {\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node.removeAttribute(key);\n          } else {\n            elementRemoveAttribute.call(node, key);\n          }\n        }\n      }\n    }\n  }\n}\n","/**\n * DO NOT MOVE THIS FUNCTIONS TO SEPARATE MODULES!\n *\n * There are so many circular dependencies between functions in this module, so just leave it all here instead of\n * creating many circular dependencies between JS modules.\n */\n\nimport {\n  SVG_NAMESPACE, nodeRemoveChild, nodeInsertBefore, elementSetAttribute, nodeCloneNode, nodeReplaceChild,\n} from \"ivi-core\";\nimport { autofocus } from \"ivi-scheduler\";\nimport { syncEvents, attachEvents, detachEvents } from \"ivi-events\";\nimport { VNodeFlags, ComponentFlags } from \"./flags\";\nimport { VNode, getDOMInstanceFromVNode } from \"./vnode\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\nimport { StatefulComponent, StatelessComponent, Component } from \"./component\";\nimport { syncDOMAttrs, syncStyle } from \"./sync_dom\";\n\n/**\n * Removes VNode.\n *\n * @param parent - Parent DOM node\n * @param vnode - Virtual DOM node to remove\n */\nexport function removeVNode(parent: Node, vnode: VNode): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.removeChild(getDOMInstanceFromVNode(vnode)!);\n  } else {\n    nodeRemoveChild.call(parent, getDOMInstanceFromVNode(vnode)!);\n  }\n  _detach(vnode);\n}\n\n/**\n * Recursively attach all nodes.\n *\n * @param vnode - Virtual DOM node\n */\nfunction _attach(vnode: VNode): void {\n  const flags = vnode._f;\n\n  if ((flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ElementPropsEvents)) !== 0) {\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      let child: VNode | null = vnode._c as VNode;\n      do {\n        _attach(child!);\n        child = child._r;\n      } while (child !== null);\n    }\n    if ((flags & VNodeFlags.ElementPropsEvents) !== 0) {\n      if (vnode._e !== null) {\n        attachEvents(vnode._e);\n      }\n    }\n  } else if (\n    (flags & (\n      VNodeFlags.StatelessComponent |\n      VNodeFlags.StatefulComponent |\n      VNodeFlags.Connect |\n      VNodeFlags.UpdateContext\n    )) !== 0) {\n    if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      (vnode._i as Component<any>).attached();\n    }\n    _attach(vnode._c as VNode);\n  }\n}\n\n/**\n * Recursively detach all nodes.\n *\n * @param vnode - Virtual DOM node\n */\nfunction _detach(vnode: VNode): void {\n  const flags = vnode._f;\n\n  if ((flags & (VNodeFlags.ChildrenVNode | VNodeFlags.ElementPropsEvents)) !== 0) {\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      let child: VNode | null = vnode._c as VNode;\n      do {\n        _detach(child!);\n        child = child._r;\n      } while (child !== null);\n    }\n    if ((flags & VNodeFlags.ElementPropsEvents) !== 0) {\n      if (vnode._e !== null) {\n        detachEvents(vnode._e);\n      }\n    }\n  } else if ((flags & (\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) !== 0) {\n    _detach(vnode._c as VNode);\n    if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      const component = vnode._i as Component<any>;\n      component.flags |= ComponentFlags.Detached;\n      component.detached();\n    }\n  }\n}\n\n/**\n * Recursively perform dirty checking.\n *\n * @param parent - Parent DOM Node\n * @param vnode - VNode\n * @param context - Current context\n * @param dirtyContext - Context is dirty\n */\nexport function dirtyCheck(parent: Node, vnode: VNode, context: {}, dirtyContext: boolean): number {\n  const flags = vnode._f;\n  let deepUpdate = 0;\n  let children: VNode | null | undefined;\n  let instance: Node | Component<any> | {} | undefined;\n\n  if ((flags & (\n    VNodeFlags.StopDirtyChecking | // StopDirtyChecking will convert this value to -value\n    VNodeFlags.ChildrenVNode |\n    VNodeFlags.StatelessComponent |\n    VNodeFlags.StatefulComponent |\n    VNodeFlags.Connect |\n    VNodeFlags.UpdateContext\n  )) > 0) {\n    children = vnode._c as VNode;\n    if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n      instance = vnode._i as Node;\n      do {\n        deepUpdate |= dirtyCheck(instance as Node, children, context, dirtyContext);\n        children = children._r;\n      } while (children !== null);\n    } else if ((flags & VNodeFlags.StatefulComponent) !== 0) {\n      instance = vnode._i as Component<any>;\n      if (((instance as Component<any>).flags & ComponentFlags.Dirty) !== 0) {\n        syncVNode(\n          parent,\n          children,\n          vnode._c = DEBUG ?\n            shouldBeSingleVNode((instance as Component<any>).render()) :\n            /* istanbul ignore next */(instance as Component<any>).render(),\n          context,\n          dirtyContext,\n        );\n        (instance as Component<any>).flags &= ~ComponentFlags.Dirty;\n        (instance as Component<any>).updated(true);\n        deepUpdate = 1;\n      } else {\n        deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n        if (deepUpdate !== 0) {\n          (instance as Component<any>).updated(false);\n        }\n      }\n    } else { // (flags & (VNodeFlags.StatelessComponent | VNodeFlags.Connect | VNodeFlags.UpdateContext))\n      if ((flags & VNodeFlags.Connect) !== 0) {\n        const connect = vnode._t as ConnectDescriptor<any, any, {}>;\n        instance = vnode._i as {};\n        const selectData = connect.select(instance, vnode._p, context);\n        if (instance === selectData) {\n          deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n        } else {\n          deepUpdate = 1;\n          vnode._i = selectData;\n          syncVNode(\n            parent,\n            children,\n            vnode._c = DEBUG ?\n              shouldBeSingleVNode(connect.render(selectData)) :\n              /* istanbul ignore next */connect.render(selectData),\n            context,\n            dirtyContext,\n          );\n        }\n      } else {\n        if ((flags & VNodeFlags.UpdateContext) !== 0) {\n          if (dirtyContext === true) {\n            vnode._i = { ...context, ...vnode._p };\n          }\n          context = vnode._i as {};\n        }\n        deepUpdate = dirtyCheck(parent, children, context, dirtyContext);\n      }\n    }\n  }\n  return deepUpdate;\n}\n\n/**\n * Remove all children.\n *\n * `detach()` lifecycle methods will be invoked for all children and their subtrees.\n *\n * @param parent - Parent DOM element\n * @param firstVNode - First Virtual DOM node\n */\nfunction _removeAllChildren(parent: Node, firstVNode: VNode): void {\n  parent.textContent = \"\";\n  let vnode: VNode | null = firstVNode;\n  do {\n    _detach(vnode);\n    vnode = vnode._r;\n  } while (vnode !== null);\n}\n\n/**\n * Set value for `HTMLInputElement`.\n *\n * When value has a string type it is assigned to `value` property, otherwise it is assigned to `checked` property.\n *\n * @param input - HTMLInputElement\n * @param value - Value\n */\nfunction _setInputValue(input: HTMLInputElement, value: string | boolean): void {\n  if (typeof value === \"string\") {\n    input.value = value;\n  } else {\n    input.checked = value;\n  }\n}\n\n/**\n * Render virtual DOM node.\n *\n * @param parent - Parent DOM element\n * @param vnode - Virtual DOM node to render\n * @param context - Current context\n * @returns Rendered DOM Node\n */\nfunction _render(parent: Node, vnode: VNode, context: {}): Node {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (vnode._i !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times, \" +\n        \"clone VNode with `cloneVNode`.\");\n    }\n  }\n\n  const flags = vnode._f;\n  let instance: Node | Component<any> | null = null;\n  let node: Node;\n\n  if ((flags & VNodeFlags.Text) !== 0) {\n    instance = node = document.createTextNode(vnode._c as string);\n  } else {\n    const tag = vnode._t;\n    if ((flags & (VNodeFlags.Element | VNodeFlags.StatefulComponent)) !== 0) {\n      if ((flags & VNodeFlags.Element) !== 0) {\n        const svg = (flags & VNodeFlags.SvgElement) !== 0;\n        if ((flags & VNodeFlags.ElementFactory) === 0) {\n          node = svg ?\n            document.createElementNS(SVG_NAMESPACE, tag as string) :\n            document.createElement(tag as string);\n        } else {\n          if ((tag as VNode)._i === null) {\n            _render(parent, (tag as VNode), context);\n          }\n          /* istanbul ignore else */\n          if (DEBUG) {\n            node = ((tag as VNode)._i as Node).cloneNode(false);\n          } else {\n            node = nodeCloneNode.call((tag as VNode)._i as Node, false);\n          }\n        }\n\n        if (vnode._cs !== void 0) {\n          /**\n           * SVGElement.className returns `SVGAnimatedString`\n           */\n          if (svg === true) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (node as Element).setAttribute(\"class\", vnode._cs);\n            } else {\n              elementSetAttribute.call(node as Element, \"class\", vnode._cs);\n            }\n          } else {\n            (node as Element).className = vnode._cs;\n          }\n        }\n\n        if (vnode._p !== null) {\n          syncDOMAttrs(node as Element, svg, null, vnode._p);\n        }\n        if (vnode._s !== null) {\n          syncStyle(node as HTMLElement, null, vnode._s);\n        }\n        if (vnode._e !== null) {\n          (node as Element)._ev = vnode._e;\n        }\n\n        let children = vnode._c;\n        if (children !== null) {\n          if ((flags & VNodeFlags.ChildrenVNode) !== 0) {\n            children = children as VNode;\n            do {\n              /* istanbul ignore else */\n              if (DEBUG) {\n                node.insertBefore(_render(node, children, context), null);\n              } else {\n                nodeInsertBefore.call(node, _render(node, children, context), null);\n              }\n              children = children._r;\n            } while (children !== null);\n          } else if ((flags & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement)) !== 0) {\n            /**\n             * #quirks\n             *\n             * It is important that input value is assigned after all properties. It prevents some issues with\n             * rounding, etc. `value` should be assigned after `step`, `min` and `max` properties.\n             */\n            _setInputValue(node as HTMLInputElement, children as string | boolean);\n          } else { // (flags & VNodeFlags.UnsafeHTML)\n            (node as Element).innerHTML = children as string;\n          }\n        }\n\n        instance = node;\n      } else { // ((flags & VNodeFlags.StatefulComponent) !== 0)\n        const component = instance = new (tag as StatefulComponent<any>)(vnode._p);\n        const root = vnode._c = DEBUG ?\n          shouldBeSingleVNode(component.render()) :\n          /* istanbul ignore next */component.render();\n        node = _render(parent, root, context);\n      }\n    } else { // ((flags & (VNodeFlags.StatelessComponent | VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0)\n      if ((flags & (VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0) {\n        if ((flags & VNodeFlags.Connect) !== 0) {\n          const connect = (tag as ConnectDescriptor<any, any, {}>);\n          const selectData = instance = connect.select(null, vnode._p, context);\n          vnode._c = DEBUG ?\n            shouldBeSingleVNode(connect.render(selectData)) :\n            /* istanbul ignore next */connect.render(selectData);\n        } else {\n          context = instance = { ...context, ...vnode._p };\n        }\n      } else {\n        vnode._c = DEBUG ?\n          shouldBeSingleVNode((tag as StatelessComponent<any>).render(vnode._p)) :\n          /* istanbul ignore next */(tag as StatelessComponent<any>).render(vnode._p);\n      }\n      node = _render(parent, vnode._c as VNode, context);\n    }\n\n    if ((flags & VNodeFlags.Autofocus) !== 0) {\n      autofocus(node as Element);\n    }\n  }\n\n  vnode._i = instance;\n\n  return node;\n}\n\n/**\n * Render virtual DOM node into container and invoke `attached()` lifecycle methods after node is inserted into\n * container.\n *\n * It is important that `attached()` methods are invoked only after DOM nodes have been inserted into container, so it\n * goes twice through the entire vnode tree, first time when everything is rendered and the second time when\n * `attached()` methods are invoked.\n *\n * @param parent - Parent DOM element\n * @param refChild - Reference to the next DOM node, when it is `null` child will be inserted at the end\n * @param vnode - Virtual DOM node\n * @param context - Current context\n * @returns Rendered DOM Node\n */\nexport function renderVNode(\n  parent: Node,\n  refChild: Node | null,\n  vnode: VNode,\n  context: {},\n): Node {\n  const node = _render(parent, vnode, context);\n  /* istanbul ignore else */\n  if (DEBUG) {\n    parent.insertBefore(node, refChild);\n  } else {\n    nodeInsertBefore.call(parent, node, refChild);\n  }\n  _attach(vnode);\n  return node;\n}\n\n/**\n * Sync virtual DOM nodes.\n *\n * When node `a` is synced with node `b`, `a` node should be considered as destroyed, and any access to it after sync\n * is an undefined behavior.\n *\n * @param parent - Parent DOM element\n * @param a - Previous virtual DOM node\n * @param b - Next virtual DOM node\n * @param context - Current context\n * @param dirtyContext - Context is dirty\n */\nexport function syncVNode(\n  parent: Node,\n  a: VNode,\n  b: VNode,\n  context: {},\n  dirtyContext: boolean,\n): void {\n  if (a === b) {\n    dirtyCheck(parent, b, context, dirtyContext);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (b._i !== null) {\n      throw new Error(\"VNode is already have a reference to an instance. VNodes can't be used mutliple times\");\n    }\n  }\n\n  let instance;\n  const aFlags = a._f;\n  const bFlags = b._f;\n  if (\n    (((aFlags ^ bFlags) & VNodeFlags.Syncable) === 0) &&\n    (\n      (aFlags & (\n        VNodeFlags.ElementFactory |\n        VNodeFlags.StatelessComponent |\n        VNodeFlags.StatefulComponent |\n        VNodeFlags.Connect\n      )) === 0 ||\n      a._t === b._t\n    ) &&\n    a._k === b._k\n  ) {\n    b._i = instance = a._i;\n\n    if ((bFlags & (VNodeFlags.Text | VNodeFlags.Element)) !== 0) {\n      const aChild = a._c;\n      let bChild = b._c;\n      if ((bFlags & VNodeFlags.Text) !== 0) {\n        if (aChild !== bChild) {\n          (instance as Text).data = bChild as string;\n        }\n      } else { // (flags & VNodeFlags.Element)\n        const svg = (bFlags & VNodeFlags.SvgElement) !== 0;\n\n        if (a._cs !== b._cs) {\n          const className = b._cs === void 0 ? \"\" : b._cs;\n          if (svg === true) {\n            /* istanbul ignore else */\n            if (DEBUG) {\n              (instance as Element).setAttribute(\"class\", className);\n            } else {\n              elementSetAttribute.call(instance, \"class\", className);\n            }\n          } else {\n            (instance as Element).className = className;\n          }\n        }\n\n        if (a._p !== b._p) {\n          syncDOMAttrs(instance as Element, svg, a._p, b._p);\n        }\n        if (a._s !== b._s) {\n          syncStyle(instance as HTMLElement, a._s, b._s);\n        }\n        if (a._e !== b._e) {\n          syncEvents(a._e, b._e);\n          (instance as Element)._ev = b._e;\n        }\n\n        if (aChild !== bChild) {\n          if (aChild === null) {\n            if ((bFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              bChild = bChild as VNode;\n              do {\n                renderVNode(instance as Element, null, bChild, context);\n                bChild = bChild._r!;\n              } while (bChild !== null);\n            } else if ((bFlags & (VNodeFlags.InputElement | VNodeFlags.TextAreaElement)) !== 0) {\n              _setInputValue(instance as HTMLInputElement, bChild as string | boolean);\n            } else { // (bParentFlags & VNodeFlags.UnsafeHTML)\n              (instance as Element).innerHTML = bChild as string;\n            }\n          } else if (bChild === null) {\n            if ((aFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              _removeAllChildren(instance as Element, aChild as VNode);\n            } else if ((aFlags & VNodeFlags.UnsafeHTML) !== 0) {\n              (instance as Element).textContent = \"\";\n            } else { // (bParentFlags & VNodeFlags.InputElement)\n              /**\n               * When value/checked isn't specified, we should just ignore it.\n               */\n            }\n          } else {\n            if ((aFlags & VNodeFlags.ChildrenVNode) !== 0) {\n              _syncChildrenTrackByKeys(instance as Element, aChild as VNode, bChild as VNode, context, dirtyContext);\n            } else if ((aFlags & VNodeFlags.UnsafeHTML) !== 0) {\n              (instance as Element).innerHTML = bChild as string;\n            } else { // (aParentFlags & VNodeFlags.InputElement)\n              /**\n               * Input elements has an internal state with a `value` property, so it should be checked before an\n               * assignment to prevent unnecessary events when `value` is the same as the `value` in the internal\n               * state.\n               *\n               * In general we don't want to override behaviour of DOM Elements with an internal state. Assigning props\n               * to such elements should be treated as a one-time assignment, so it works almost like `value` attribute,\n               * except when a new value is passed down, it can override previous value when it doesn't match the\n               * previous one. There is absolutely no reasons to overcomplicate such behaviour just to make it more\n               * beatiful like it is a declarative assignment and can't be changed, because in real applications,\n               * component that controls this element will always track changes, and when it changes it will invalidate\n               * its representation, so everything will stay in-sync.\n               */\n              if (typeof bChild === \"string\") {\n                if ((instance as HTMLInputElement).value !== bChild) {\n                  (instance as HTMLInputElement).value = bChild;\n                }\n              } else {\n                (instance as HTMLInputElement).checked = bChild as boolean;\n              }\n            }\n          }\n        }\n      }\n    } else { // (flags & VNodeFlags.Component)\n      if ((bFlags & VNodeFlags.StatefulComponent) !== 0) {\n        const component = instance as Component<any>;\n        // Update component props\n        const oldProps = a._p;\n        const newProps = b._p;\n        if (oldProps !== newProps) {\n          // There is no reason to call `newPropsReceived` when props aren't changed, even when they are\n          // reassigned later to reduce memory usage.\n          component.newPropsReceived(oldProps, newProps);\n        }\n        // Reassign props even when they aren't changed to reduce overall memory usage.\n        //\n        // New value always stays alive because it is referenced from virtual dom tree, so instead of keeping\n        // in memory two values even when they are the same, we just always reassign it to the new value.\n        component.props = newProps;\n\n        if (\n          ((component.flags & ComponentFlags.Dirty) !== 0) ||\n          (component.shouldUpdate(oldProps, newProps) === true)\n        ) {\n          syncVNode(\n            parent,\n            a._c as VNode,\n            b._c = DEBUG ?\n              shouldBeSingleVNode(component.render()) :\n              /* istanbul ignore next */component.render(),\n            context,\n            dirtyContext,\n          );\n          component.flags &= ~ComponentFlags.Dirty;\n          component.updated(true);\n        } else {\n          if (dirtyCheck(parent, b._c = a._c as VNode, context, dirtyContext) !== 0) {\n            component.updated(false);\n          }\n        }\n      } else { // (flags & VNodeFlags.ComponentFunction)\n        if ((bFlags & (VNodeFlags.UpdateContext | VNodeFlags.Connect)) !== 0) {\n          if ((bFlags & VNodeFlags.Connect) !== 0) {\n            const connect = b._t as ConnectDescriptor<any, any, {}>;\n            const prevSelectData = instance;\n            const selectData = b._i = connect.select(prevSelectData, b._p, context);\n            if (prevSelectData === selectData) {\n              dirtyCheck(parent, b._c = a._c as VNode, context, dirtyContext);\n            } else {\n              syncVNode(\n                parent,\n                a._c as VNode,\n                b._c = DEBUG ?\n                  shouldBeSingleVNode(connect.render(selectData)) :\n                  /* istanbul ignore next */connect.render(selectData),\n                context,\n                dirtyContext,\n              );\n            }\n          } else {\n            if (a._p !== b._p) {\n              dirtyContext = true;\n            }\n            b._i = context = (dirtyContext === true) ?\n              { ...context, ...b._p } :\n              instance as {};\n            syncVNode(parent, a._c as VNode, b._c as VNode, context, dirtyContext);\n          }\n        } else {\n          const sc = b._t as StatelessComponent<any>;\n          if (\n            (a._p !== b._p) &&\n            ((bFlags & VNodeFlags.ShouldUpdateHint) === 0 || sc.shouldUpdate!(a._p, b._p) === true)\n          ) {\n            syncVNode(\n              parent,\n              a._c as VNode,\n              b._c = DEBUG ?\n                shouldBeSingleVNode(sc.render(b._p)) :\n                /* istanbul ignore next */sc.render(b._p),\n              context,\n              dirtyContext,\n            );\n          } else {\n            dirtyCheck(parent, b._c = a._c as VNode, context, dirtyContext);\n          }\n        }\n      }\n    }\n  } else {\n    instance = _render(parent, b, context);\n    /* istanbul ignore else */\n    if (DEBUG) {\n      parent.replaceChild(instance, getDOMInstanceFromVNode(a)!);\n    } else {\n      nodeReplaceChild.call(parent, instance, getDOMInstanceFromVNode(a)!);\n    }\n    _detach(a);\n    _attach(b);\n  }\n}\n\n/**\n * Sync children.\n *\n * High-level overview of the algorithm that is implemented in this function (this overview doesn't include some details\n * how it handles nodes with implicit keys and many small tricks to reduce memory allocations and unnecessary work).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parent - Parent DOM element\n * @param aStartVNode - Previous virtual DOM node\n * @param bStartVNode - Next virtual DOM node\n * @param context - Current context\n * @param dirtyContext - Context is dirty\n */\nfunction _syncChildrenTrackByKeys(\n  parent: Node,\n  aStartVNode: VNode,\n  bStartVNode: VNode,\n  context: {},\n  dirtyContext: boolean,\n): void;\nfunction _syncChildrenTrackByKeys(\n  parent: Node,\n  aStartVNode: VNode | null, // should not be null, it is a workaroud to slightly reduce code size\n  bStartVNode: VNode | null, // should not be null, it is a workaroud to slightly reduce code size\n  context: {},\n  dirtyContext: boolean,\n): void {\n  let aEndVNode: VNode = aStartVNode!._l!;\n  let bEndVNode: VNode = bStartVNode!._l!;\n  let i: number | undefined = 0;\n  let step1Synced = 0;\n\n  // Step 1\n  outer: while (1) {\n    // Sync nodes with the same key at the beginning.\n    while (\n      (aStartVNode!._k === bStartVNode!._k) &&\n      (((aStartVNode!._f ^ bStartVNode!._f) & VNodeFlags.Key) === 0)\n    ) {\n      syncVNode(parent, aStartVNode!, bStartVNode!, context, dirtyContext);\n      step1Synced++;\n      if (aStartVNode === aEndVNode) {\n        i = 1;\n      } else {\n        aStartVNode = aStartVNode!._r;\n      }\n      if (bStartVNode === bEndVNode) {\n        i |= 2;\n      } else {\n        bStartVNode = bStartVNode!._r;\n      }\n      if (i) {\n        break outer;\n      }\n    }\n\n    // Sync nodes with the same key at the end.\n    while (\n      (aEndVNode!._k === bEndVNode!._k) &&\n      (((aEndVNode!._f ^ bEndVNode!._f) & VNodeFlags.Key) === 0)\n    ) {\n      syncVNode(parent, aEndVNode, bEndVNode, context, dirtyContext);\n      step1Synced++;\n      if (aStartVNode === aEndVNode) {\n        i = 1;\n      } else {\n        aEndVNode = aEndVNode._l;\n      }\n      if (bStartVNode === bEndVNode) {\n        i |= 2;\n      } else {\n        bEndVNode = bEndVNode._l;\n      }\n      if (i) {\n        break outer;\n      }\n    }\n\n    break;\n  }\n\n  if (i) {\n    if (i < 3) {\n      if (i < 2) {\n        // All nodes from a are synced, insert the rest from b.\n        const next = nextNode(bEndVNode);\n        while (1) {\n          renderVNode(parent, next, bStartVNode!, context);\n          if (bStartVNode === bEndVNode) {\n            break;\n          }\n          bStartVNode = bStartVNode!._r;\n        }\n      } else {\n        // All nodes from b are synced, remove the rest from a.\n        while (1) {\n          removeVNode(parent, aStartVNode!);\n          if (aStartVNode === aEndVNode) {\n            break;\n          }\n          aStartVNode = aStartVNode!._r;\n        }\n      }\n    }\n  } else { // Step 2\n    // Inner length after prefix/suffix optimization.\n    let aInnerLength = 0;\n    let bInnerLength = 0;\n\n    // When lastPosition === 1000000000, it means that one of the nodes in the wrong position.\n    let lastPosition = 0;\n\n    const bInnerArray: VNode[] = [];\n    // Reverse indexes for keys.\n    let explicitKeyIndex: Map<any, number> | undefined;\n    let implicitKeyIndex: Map<number, number> | undefined;\n    let key;\n\n    // Temporary vnode\n    let vnode = bStartVNode;\n    while (1) {\n      key = vnode!._k;\n      if (vnode!._f & VNodeFlags.Key) {\n        if (explicitKeyIndex === void 0) {\n          explicitKeyIndex = new Map<any, number>();\n        }\n        explicitKeyIndex.set(key, bInnerLength);\n      } else {\n        if (implicitKeyIndex === void 0) {\n          implicitKeyIndex = new Map<number, number>();\n        }\n        implicitKeyIndex.set(key, bInnerLength);\n      }\n      bInnerArray[bInnerLength++] = vnode!;\n      if (vnode === bEndVNode) {\n        break;\n      }\n      vnode = vnode!._r;\n    }\n\n    // Mark all nodes as inserted (-1).\n    const prevPositionsForB = new Array<number>(bInnerLength).fill(-1);\n\n    let step2Synced = 0;\n    vnode = aStartVNode;\n    while (1) {\n      key = vnode!._k;\n      if (vnode!._f & VNodeFlags.Key) {\n        i = explicitKeyIndex ? explicitKeyIndex.get(key) : void 0;\n      } else {\n        i = implicitKeyIndex ? implicitKeyIndex.get(key) : void 0;\n      }\n\n      if (i === void 0) {\n        vnode!._k = null;\n      } else {\n        lastPosition = (lastPosition > i) ? 1000000000 : i;\n        prevPositionsForB[i] = aInnerLength;\n        syncVNode(parent, vnode!, bInnerArray[i], context, dirtyContext);\n        step2Synced++;\n      }\n      aInnerLength++;\n      if (vnode === aEndVNode) {\n        break;\n      }\n      vnode = vnode!._r;\n    }\n\n    if (!step1Synced && !step2Synced) {\n      // Noone is synced, remove all children with one dom op.\n      _removeAllChildren(parent, aStartVNode!);\n      do {\n        renderVNode(parent, null, bStartVNode!, context);\n        bStartVNode = bStartVNode!._r;\n      } while (bStartVNode !== null);\n    } else {\n      i = aInnerLength - step2Synced;\n      while (i > 0) {\n        if (aStartVNode!._k === null) {\n          removeVNode(parent, aStartVNode!);\n          i--;\n        }\n        aStartVNode = aStartVNode!._r;\n      }\n\n      // Step 3\n      if (lastPosition === 1000000000) {\n        const seq = lis(prevPositionsForB);\n        i = seq.length - 1;\n        while (bInnerLength > 0) {\n          if (prevPositionsForB[--bInnerLength] < 0) {\n            renderVNode(parent, nextNode(bEndVNode), bEndVNode, context);\n          } else {\n            if (i < 0 || bInnerLength !== seq[i]) {\n              /* istanbul ignore else */\n              if (DEBUG) {\n                parent.insertBefore(getDOMInstanceFromVNode(bEndVNode)!, nextNode(bEndVNode));\n              } else {\n                nodeInsertBefore.call(parent, getDOMInstanceFromVNode(bEndVNode)!, nextNode(bEndVNode));\n              }\n            } else {\n              i--;\n            }\n          }\n          bEndVNode = bEndVNode._l;\n        }\n      } else if (step2Synced !== bInnerLength) {\n        while (bInnerLength > 0) {\n          if (prevPositionsForB[--bInnerLength] < 0) {\n            renderVNode(parent, nextNode(bEndVNode), bEndVNode, context);\n          }\n          bEndVNode = bEndVNode._l;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves a next DOM node from a virtual DOM node.\n *\n * @param vnode - Virtual DOM node\n * @returns Next DOM node\n */\nfunction nextNode(vnode: VNode): Node | null {\n  const next = vnode._r;\n  return next === null ? null : getDOMInstanceFromVNode(next);\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * @param a - Array of numbers\n * @returns Longest increasing subsequence\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  const result: number[] = [];\n  result.push(0);\n  let u: number;\n  let v: number;\n  let j: number;\n\n  for (let i = 0; i < a.length; ++i) {\n    const k = a[i];\n    if (k === -1) {\n      continue;\n    }\n\n    j = result[result.length - 1];\n    if (a[j] < k) {\n      p[i] = j;\n      result.push(i);\n      continue;\n    }\n\n    u = 0;\n    v = result.length - 1;\n\n    while (u < v) {\n      j = ((u + v) / 2) | 0;\n      if (a[result[j]] < k) {\n        u = j + 1;\n      } else {\n        v = j;\n      }\n    }\n\n    if (k < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Check virtual DOM node returned from a `render()` function in `DEBUG` mode.\n *\n * @param vnode - Virtual DOM node\n * @return `vnode`\n */\nfunction shouldBeSingleVNode<T extends VNode>(vnode: T): T {\n  if (vnode._l !== vnode) {\n    throw new Error(\"Invalid render function. Render function should return singular VNode.\");\n  }\n  return vnode;\n}\n","import { IOS_UA, NOOP, unorderedArrayDelete } from \"ivi-core\";\nimport { setUpdateDOMHandler, nextFrameWrite, triggerNextFrame } from \"ivi-scheduler\";\nimport { VNode } from \"./vnode\";\nimport { renderVNode, syncVNode, removeVNode, dirtyCheck } from \"./implementation\";\nimport { checkNestingViolations } from \"../dev_mode/html_nesting_rules\";\n\n/**\n * Root.\n */\nexport interface Root {\n  container: Element;\n  currentVNode: VNode | null;\n  newVNode: VNode | null;\n  invalidated: boolean;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Empty Context object.\n */\nconst EMPTY_CONTEXT = {};\n\nlet _pendingUpdate = 0;\n\n/**\n * Find Root node in container.\n *\n * @param container - DOM Node that contains root node\n * @returns root node or undefined when root node doesn't exist\n */\nexport function findRoot(container: Element): Root | void {\n  for (const root of ROOTS) {\n    if (root.container === container) {\n      return root;\n    }\n  }\n}\n\n/**\n * Update root nodes.\n */\nfunction _update() {\n  if (_pendingUpdate) {\n    _pendingUpdate = 0;\n    setUpdateDOMHandler(update);\n    for (let i = 0; i < ROOTS.length; ++i) {\n      const root = ROOTS[i];\n      const container = root.container;\n      const currentVNode = root.currentVNode;\n\n      if (root.invalidated) {\n        const newVNode = root.newVNode;\n\n        if (newVNode) {\n          if (currentVNode) {\n            syncVNode(container, currentVNode, newVNode, EMPTY_CONTEXT, false);\n          } else {\n            renderVNode(container, null, newVNode!, EMPTY_CONTEXT);\n            /* istanbul ignore if */\n            /**\n             * Fix for the Mouse Event bubbling on iOS devices.\n             *\n             * #quirks\n             *\n             * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n             */\n            if (TARGET === \"browser\" && IOS_UA) {\n              (container as HTMLElement).onclick = NOOP;\n            }\n          }\n          root.currentVNode = newVNode;\n        } else if (currentVNode) {\n          removeVNode(container, currentVNode);\n          unorderedArrayDelete(ROOTS, ROOTS.indexOf(root));\n          --i;\n        }\n\n        root.newVNode = null;\n        root.invalidated = false;\n      } else if (currentVNode) {\n        dirtyCheck(container, currentVNode, EMPTY_CONTEXT, false);\n      }\n\n      /* istanbul ignore else */\n      if (DEBUG) {\n        if (root.currentVNode) {\n          checkNestingViolations(container, root.currentVNode);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Render virtual DOM node into container.\n *\n * @param vnode - Virtual DOM node to render\n * @param container - DOM Node that will contain rendered node\n */\nexport function render(vnode: VNode | null, container: Element): void {\n  renderNextFrame(vnode, container);\n  triggerNextFrame();\n}\n\n/**\n * Render virtual DOM node into container on the next frame.\n *\n * @param vnode - Virtual DOM node to render\n * @param container - DOM Node that will contain rendered node\n */\nexport function renderNextFrame(vnode: VNode | null, container: Element): void {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (container === document.body) {\n      throw new Error(\"Rendering in the <body> aren't allowed, create an element inside body that will contain \" +\n        \"your application.\");\n    }\n    if (!document.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document.\");\n    }\n  }\n\n  const root = findRoot(container);\n  if (root) {\n    root.newVNode = vnode;\n    root.invalidated = true;\n  } else {\n    ROOTS.push({\n      container,\n      currentVNode: null,\n      newVNode: vnode,\n      invalidated: true,\n    });\n  }\n\n  updateNextFrame();\n}\n\n/**\n * Update dirty components.\n */\nexport function update() {\n  updateNextFrame();\n  triggerNextFrame();\n}\n\n/**\n * Add a task to update dirty components that will be executed at the next frame.\n */\nexport function updateNextFrame() {\n  if (!_pendingUpdate) {\n    _pendingUpdate = 1;\n    nextFrameWrite(_update);\n  }\n}\n","import { VNodeFlags } from \"./flags\";\nimport { StatefulComponent, StatelessComponent } from \"./component\";\nimport { VNode } from \"./vnode\";\nimport { ConnectDescriptor } from \"./connect_descriptor\";\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render - Render function\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent(c: () => VNode): () => VNode<undefined>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render - Render function\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent<P>(\n  render: undefined extends P ? (props?: P) => VNode<any> : (props: P) => VNode<any>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * statelessComponent creates a virtual DOM node factory that produces nodes for stateless components.\n *\n * @example\n *\n *     const A = statelessComponent<{ text: string }>(\n *       (props) => h.div().c(props.text),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param render - Render function\n * @returns factory that produces stateless component nodes\n */\nexport function statelessComponent<P>(render: (props: P) => VNode<any>): (props: P) => VNode<P> {\n  const d = { render, shouldUpdate: null };\n  const f = (props: P) => {\n    const n = new VNode<P>(\n      VNodeFlags.StatelessComponent,\n      d,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * withShouldUpdate creates a virtual DOM node factory that produces nodes for stateless components with custom\n * `shouldUpdate` function to prevent unnecessary updates.\n *\n * @example\n *\n *     const A = withShouldUpdate<{ text: string }>(\n *       (prevProps, nextProps) => prevProps.text !== nextProps.text,\n *       statelessComponent(\n *         (props) => h.div().c(props.text),\n *       ),\n *     );\n *\n *     render(\n *       A({ text: \"Hello\" }),\n *       DOMContainer,\n *     );\n *\n * @param shouldUpdate - Function that performs an early check that prevent unnecessary updates\n * @param factory - Factory that produces stateless component nodes\n * @returns factory that produces stateless component nodes\n */\nexport function withShouldUpdate<P>(\n  shouldUpdate: (oldProps: P, newProps: P) => boolean,\n  factory: (props: P) => VNode<P>,\n): (props: P) => VNode<P> {\n  const v = factory(null as any);\n  const d = { render: (v._t as StatelessComponent<P>).render, shouldUpdate };\n  const f = (props: P) => {\n    const n = new VNode<P>(\n      VNodeFlags.StatelessComponent | VNodeFlags.ShouldUpdateHint,\n      d,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n * @example\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c - Stateful component\n * @returns factory that produces stateful component nodes\n */\nexport function statefulComponent(c: StatefulComponent<undefined>): () => VNode<undefined>;\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n * @example\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c - Stateful component\n * @returns factory that produces stateful component nodes\n */\nexport function statefulComponent<P>(\n  c: StatefulComponent<P>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * statefulComponent creates a virtual DOM node factory that produces nodes for stateful components.\n *\n * @example\n *\n *     const A = component(class extends Component<string> {\n *       onClick = Events.onClick(() => console.log(this.props));\n *\n *       render() {\n *         return (\n *           h.button()\n *             .e(this.onClick)\n *             .c(\"Click Me\")\n *         );\n *       }\n *     });\n *\n *     render(\n *       A(\"clicked\"),\n *       DOMContainer,\n *     );\n *\n * @param c - Stateful component\n * @returns factory that produces stateful component nodes\n */\nexport function statefulComponent<P>(\n  c: StatefulComponent<P>,\n): (props: P) => VNode<P> {\n  const f = (props: P) => {\n    const n = new VNode<P>(\n      VNodeFlags.StatefulComponent,\n      c,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n\n/**\n * context creates a virtual DOM node that will modify current context.\n *\n * @example\n *\n *     render(\n *       context({ key: 123 },\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param ctx - Context object\n * @param child - child Virtual DOM node\n * @returns context node\n */\nexport function context<T = {}>(ctx: T, child: VNode): VNode<T> {\n  /* istanbul ignore else */\n  if (DEBUG) {\n    if (child._l !== child) {\n      throw new Error(\"Context node contains an invalid child. Child should be a singular VNode.\");\n    }\n  }\n  return new VNode<T>(\n    VNodeFlags.UpdateContext,\n    null,\n    ctx,\n    void 0,\n    child,\n  );\n}\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n * @example\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select - Selector function\n * @param render - Render function\n * @returns factory that produces connector nodes\n */\nexport function connect<T>(\n  select: (prev: T | null) => T,\n  render: (props: T) => VNode<any>,\n): () => VNode<undefined>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n * @example\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select - Selector function\n * @param render - Render function\n * @returns factory that produces connector nodes\n */\nexport function connect<T, P>(\n  select: undefined extends P ? (prev: T | null, props?: P) => T : (prev: T | null, props: P) => T,\n  render: (props: T) => VNode<any>,\n): undefined extends P ? (props?: P) => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n * @example\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select - Selector function\n * @param render - Render function\n * @returns factory that produces connector nodes\n */\nexport function connect<T, P, C>(\n  select: (prev: T | null, props: P, context: C) => T,\n  render: (props: T) => VNode<any>,\n): undefined extends P ? () => VNode<P> : (props: P) => VNode<P>;\n\n/**\n * connect creates a virtual DOM node factory that produces connector nodes.\n *\n * @example\n *\n *     const Connector = connect<string, undefined, { result: string }>(\n *       (prev, props, context) => {\n *         const result = context.result;\n *\n *         return (prev !== null && prev === result) ? prev :\n *           result;\n *       },\n *       (text) => h.div().c(text),\n *     );\n *\n *     render(\n *       context({ result: \"text\" },\n *         Connector(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param select - Selector function\n * @param render - Render function\n * @returns factory that produces connector nodes\n */\nexport function connect<T, P, C>(\n  select: (prev: T | null, props: P, context: C) => T,\n  render: (props: T) => VNode<any>,\n): (props: P) => VNode<P> {\n  const descriptor = { select, render };\n  const f = (props: P) => {\n    const n = new VNode<P>(\n      VNodeFlags.Connect,\n      descriptor as ConnectDescriptor<any, any, {}>,\n      props,\n      void 0,\n      null,\n    );\n    /* istanbul ignore else */\n    if (DEBUG) {\n      n.factory = f;\n    }\n    return n;\n  };\n  return f;\n}\n","import {\n  HTMLAnchorElementProps, HTMLElementProps, HTMLAreaElementProps, HTMLAudioElementProps,\n  HTMLBaseElementProps, HTMLBaseFontElementProps, HTMLBodyElementProps, HTMLBRElementProps, HTMLButtonElementProps,\n  HTMLCanvasElementProps, HTMLQuoteElementProps, HTMLTableCaptionElementProps, HTMLTableColElementProps,\n  HTMLDataListElementProps, HTMLModElementProps, HTMLDirectoryElementProps, HTMLDivElementProps,\n  HTMLDListElementProps, HTMLEmbedElementProps, HTMLFieldSetElementProps, HTMLFontElementProps, HTMLFormElementProps,\n  HTMLFrameElementProps, HTMLFrameSetElementProps, HTMLHeadElementProps, HTMLHeadingElementProps, HTMLHRElementProps,\n  HTMLHtmlElementProps, HTMLIFrameElementProps, HTMLImageElementProps, HTMLInputElementProps, HTMLLabelElementProps,\n  HTMLLegendElementProps, HTMLLIElementProps, HTMLLinkElementProps, HTMLMapElementProps,\n  HTMLMenuElementProps, HTMLMetaElementProps, HTMLMeterElementProps, HTMLObjectElementProps, HTMLOListElementProps,\n  HTMLOptGroupElementProps, HTMLOptionElementProps, HTMLParagraphElementProps, HTMLParamElementProps,\n  HTMLPictureElementProps, HTMLPreElementProps, HTMLProgressElementProps, HTMLScriptElementProps,\n  HTMLSelectElementProps, HTMLSourceElementProps, HTMLSpanElementProps, HTMLStyleElementProps,\n  HTMLTableDataCellElementProps, HTMLTableElementProps, HTMLTableHeaderCellElementProps, HTMLTableRowElementProps,\n  HTMLTableSectionElementProps, HTMLTemplateElementProps, HTMLTextAreaElementProps, HTMLTitleElementProps,\n  HTMLTrackElementProps, HTMLUListElementProps, HTMLVideoElementProps,\n} from \"ivi-core\";\nimport { VNode, VNodeFlags } from \"ivi\";\n\nconst enum TagId {\n  A = 1,\n  Abbr = 2,\n  Acronym = 3,\n  Address = 4,\n  Area = 5,\n  Article = 6,\n  Aside = 7,\n  B = 8,\n  Base = 9,\n  Basefont = 10,\n  Bdo = 11,\n  Big = 12,\n  Blockquote = 13,\n  Body = 14,\n  Br = 15,\n  Button = 16,\n  Canvas = 17,\n  Caption = 18,\n  Center = 19,\n  Cite = 20,\n  Code = 21,\n  Col = 22,\n  Colgroup = 23,\n  Data = 24,\n  Datalist = 25,\n  Dd = 26,\n  Del = 27,\n  Dfn = 28,\n  Dir = 29,\n  Div = 30,\n  Dl = 31,\n  Dt = 32,\n  Em = 33,\n  Embed = 34,\n  Fieldset = 35,\n  Figcaption = 36,\n  Figure = 37,\n  Font = 38,\n  Footer = 39,\n  Form = 40,\n  Frame = 41,\n  Frameset = 42,\n  H1 = 43,\n  H2 = 44,\n  H3 = 45,\n  H4 = 46,\n  H5 = 47,\n  H6 = 48,\n  Head = 49,\n  Header = 50,\n  Hgroup = 51,\n  Hr = 52,\n  Html = 53,\n  I = 54,\n  Iframe = 55,\n  Img = 56,\n  Input = 57,\n  Ins = 58,\n  Kbd = 59,\n  Label = 60,\n  Legend = 61,\n  Li = 62,\n  Link = 63,\n  Listing = 64,\n  Main = 65,\n  Map = 66,\n  Mark = 67,\n  Menu = 68,\n  Meta = 69,\n  Meter = 70,\n  Nav = 71,\n  Nobr = 72,\n  Noframes = 73,\n  Noscript = 74,\n  Object = 75,\n  Ol = 76,\n  Optgroup = 77,\n  Option = 78,\n  P = 79,\n  Param = 80,\n  Picture = 81,\n  Plaintext = 82,\n  Pre = 83,\n  Progress = 84,\n  Q = 85,\n  Rt = 86,\n  Ruby = 87,\n  S = 88,\n  Samp = 89,\n  Script = 90,\n  Section = 91,\n  Select = 92,\n  Small = 93,\n  Source = 94,\n  Span = 95,\n  Strike = 96,\n  Strong = 97,\n  Style = 98,\n  Sub = 99,\n  Sup = 100,\n  Table = 101,\n  Tbody = 102,\n  Td = 103,\n  Template = 104,\n  Textarea = 105,\n  Tfoot = 106,\n  Th = 107,\n  Thead = 108,\n  Time = 109,\n  Title = 110,\n  Tr = 111,\n  Track = 112,\n  Tt = 113,\n  U = 114,\n  Ul = 115,\n  Wbr = 116,\n  Xmp = 117,\n  Audio = 118,\n  Video = 119,\n}\n\n/**\n * Create a VNode representing a Text node.\n *\n * @param content Text content.\n * @returns VNode object.\n */\nexport function t(content: string | number | null): VNode<null, Text> {\n  return new VNode(VNodeFlags.Text, null, null, void 0, content);\n}\n\n// HTML Elements:\nexport function a(className?: string): VNode<HTMLAnchorElementProps | null, HTMLAnchorElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.A << VNodeFlags.ElementIdOffset),\n    \"a\",\n    null,\n    className,\n    null,\n  );\n}\nexport function abbr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Abbr << VNodeFlags.ElementIdOffset),\n    \"abbr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function acronym(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Acronym << VNodeFlags.ElementIdOffset),\n    \"acronym\",\n    null,\n    className,\n    null,\n  );\n}\nexport function address(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Address << VNodeFlags.ElementIdOffset),\n    \"address\",\n    null,\n    className,\n    null,\n  );\n}\nexport function area(className?: string): VNode<HTMLAreaElementProps | null, HTMLAreaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Area << VNodeFlags.ElementIdOffset),\n    \"area\",\n    null,\n    className,\n    null,\n  );\n}\nexport function article(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Article << VNodeFlags.ElementIdOffset),\n    \"article\",\n    null,\n    className,\n    null,\n  );\n}\nexport function aside(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Aside << VNodeFlags.ElementIdOffset),\n    \"aside\",\n    null,\n    className,\n    null,\n  );\n}\nexport function b(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.B << VNodeFlags.ElementIdOffset),\n    \"b\",\n    null,\n    className,\n    null,\n  );\n}\nexport function base(className?: string): VNode<HTMLBaseElementProps | null, HTMLBaseElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Base << VNodeFlags.ElementIdOffset),\n    \"base\",\n    null,\n    className,\n    null,\n  );\n}\nexport function basefont(className?: string): VNode<HTMLBaseFontElementProps | null, HTMLBaseFontElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Basefont << VNodeFlags.ElementIdOffset),\n    \"basefont\",\n    null,\n    className,\n    null,\n  );\n}\nexport function bdo(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Bdo << VNodeFlags.ElementIdOffset),\n    \"bdo\",\n    null,\n    className,\n    null,\n  );\n}\nexport function big(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Big << VNodeFlags.ElementIdOffset),\n    \"big\",\n    null,\n    className,\n    null,\n  );\n}\nexport function blockquote(className?: string): VNode<HTMLQuoteElementProps | null, HTMLQuoteElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Blockquote << VNodeFlags.ElementIdOffset),\n    \"blockquote\",\n    null,\n    className,\n    null,\n  );\n}\nexport function body(className?: string): VNode<HTMLBodyElementProps | null, HTMLBodyElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Body << VNodeFlags.ElementIdOffset),\n    \"body\",\n    null,\n    className,\n    null,\n  );\n}\nexport function br(className?: string): VNode<HTMLBRElementProps | null, HTMLBRElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Br << VNodeFlags.ElementIdOffset),\n    \"br\",\n    null,\n    className,\n    null,\n  );\n}\nexport function button(className?: string): VNode<HTMLButtonElementProps | null, HTMLButtonElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Button << VNodeFlags.ElementIdOffset),\n    \"button\",\n    null,\n    className,\n    null,\n  );\n}\nexport function canvas(className?: string): VNode<HTMLCanvasElementProps | null, HTMLCanvasElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Canvas << VNodeFlags.ElementIdOffset),\n    \"canvas\",\n    null,\n    className,\n    null,\n  );\n}\nexport function caption(className?: string): VNode<HTMLTableCaptionElementProps | null, HTMLTableCaptionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Caption << VNodeFlags.ElementIdOffset),\n    \"caption\",\n    null,\n    className,\n    null,\n  );\n}\nexport function center(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Center << VNodeFlags.ElementIdOffset),\n    \"center\",\n    null,\n    className,\n    null,\n  );\n}\nexport function cite(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Cite << VNodeFlags.ElementIdOffset),\n    \"cite\",\n    null,\n    className,\n    null,\n  );\n}\nexport function code(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Code << VNodeFlags.ElementIdOffset),\n    \"code\",\n    null,\n    className,\n    null,\n  );\n}\nexport function col(className?: string): VNode<HTMLTableColElementProps | null, HTMLTableColElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Col << VNodeFlags.ElementIdOffset),\n    \"col\",\n    null,\n    className,\n    null,\n  );\n}\nexport function colgroup(className?: string): VNode<HTMLTableColElementProps | null, HTMLTableColElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Colgroup << VNodeFlags.ElementIdOffset),\n    \"colgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function data(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Data << VNodeFlags.ElementIdOffset),\n    \"data\",\n    null,\n    className,\n    null,\n  );\n}\nexport function datalist(className?: string): VNode<HTMLDataListElementProps | null, HTMLDataListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Datalist << VNodeFlags.ElementIdOffset),\n    \"datalist\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dd(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dd << VNodeFlags.ElementIdOffset),\n    \"dd\",\n    null,\n    className,\n    null,\n  );\n}\nexport function del(className?: string): VNode<HTMLModElementProps | null, HTMLModElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Del << VNodeFlags.ElementIdOffset),\n    \"del\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dfn(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dfn << VNodeFlags.ElementIdOffset),\n    \"dfn\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dir(className?: string): VNode<HTMLDirectoryElementProps | null, HTMLDirectoryElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dir << VNodeFlags.ElementIdOffset),\n    \"dir\",\n    null,\n    className,\n    null,\n  );\n}\nexport function div(className?: string): VNode<HTMLDivElementProps | null, HTMLDivElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Div << VNodeFlags.ElementIdOffset),\n    \"div\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dl(className?: string): VNode<HTMLDListElementProps | null, HTMLDListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dl << VNodeFlags.ElementIdOffset),\n    \"dl\",\n    null,\n    className,\n    null,\n  );\n}\nexport function dt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Dt << VNodeFlags.ElementIdOffset),\n    \"dt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function em(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Em << VNodeFlags.ElementIdOffset),\n    \"em\",\n    null,\n    className,\n    null,\n  );\n}\nexport function embed(className?: string): VNode<HTMLEmbedElementProps | null, HTMLEmbedElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Embed << VNodeFlags.ElementIdOffset),\n    \"embed\",\n    null,\n    className,\n    null,\n  );\n}\nexport function fieldset(className?: string): VNode<HTMLFieldSetElementProps | null, HTMLFieldSetElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Fieldset << VNodeFlags.ElementIdOffset),\n    \"fieldset\",\n    null,\n    className,\n    null,\n  );\n}\nexport function figcaption(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Figcaption << VNodeFlags.ElementIdOffset),\n    \"figcaption\",\n    null,\n    className,\n    null,\n  );\n}\nexport function figure(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Figure << VNodeFlags.ElementIdOffset),\n    \"figure\",\n    null,\n    className,\n    null,\n  );\n}\nexport function font(className?: string): VNode<HTMLFontElementProps | null, HTMLFontElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Font << VNodeFlags.ElementIdOffset),\n    \"font\",\n    null,\n    className,\n    null,\n  );\n}\nexport function footer(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Footer << VNodeFlags.ElementIdOffset),\n    \"footer\",\n    null,\n    className,\n    null,\n  );\n}\nexport function form(className?: string): VNode<HTMLFormElementProps | null, HTMLFormElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Form << VNodeFlags.ElementIdOffset),\n    \"form\",\n    null,\n    className,\n    null,\n  );\n}\nexport function frame(className?: string): VNode<HTMLFrameElementProps | null, HTMLFrameElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Frame << VNodeFlags.ElementIdOffset),\n    \"frame\",\n    null,\n    className,\n    null,\n  );\n}\nexport function frameset(className?: string): VNode<HTMLFrameSetElementProps | null, HTMLFrameSetElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Frameset << VNodeFlags.ElementIdOffset),\n    \"frameset\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h1(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H1 << VNodeFlags.ElementIdOffset),\n    \"h1\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h2(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H2 << VNodeFlags.ElementIdOffset),\n    \"h2\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h3(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H3 << VNodeFlags.ElementIdOffset),\n    \"h3\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h4(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H4 << VNodeFlags.ElementIdOffset),\n    \"h4\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h5(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H5 << VNodeFlags.ElementIdOffset),\n    \"h5\",\n    null,\n    className,\n    null,\n  );\n}\nexport function h6(className?: string): VNode<HTMLHeadingElementProps | null, HTMLHeadingElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.H6 << VNodeFlags.ElementIdOffset),\n    \"h6\",\n    null,\n    className,\n    null,\n  );\n}\nexport function head(className?: string): VNode<HTMLHeadElementProps | null, HTMLHeadElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Head << VNodeFlags.ElementIdOffset),\n    \"head\",\n    null,\n    className,\n    null,\n  );\n}\nexport function header(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Header << VNodeFlags.ElementIdOffset),\n    \"header\",\n    null,\n    className,\n    null,\n  );\n}\nexport function hgroup(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Hgroup << VNodeFlags.ElementIdOffset),\n    \"hgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function hr(className?: string): VNode<HTMLHRElementProps | null, HTMLHRElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Hr << VNodeFlags.ElementIdOffset),\n    \"hr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function html(className?: string): VNode<HTMLHtmlElementProps | null, HTMLHtmlElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Html << VNodeFlags.ElementIdOffset),\n    \"html\",\n    null,\n    className,\n    null,\n  );\n}\nexport function i(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.I << VNodeFlags.ElementIdOffset),\n    \"i\",\n    null,\n    className,\n    null,\n  );\n}\nexport function iframe(className?: string): VNode<HTMLIFrameElementProps | null, HTMLIFrameElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Iframe << VNodeFlags.ElementIdOffset),\n    \"iframe\",\n    null,\n    className,\n    null,\n  );\n}\nexport function img(className?: string): VNode<HTMLImageElementProps | null, HTMLImageElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Img << VNodeFlags.ElementIdOffset),\n    \"img\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ins(className?: string): VNode<HTMLModElementProps | null, HTMLModElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ins << VNodeFlags.ElementIdOffset),\n    \"ins\",\n    null,\n    className,\n    null,\n  );\n}\nexport function kbd(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Kbd << VNodeFlags.ElementIdOffset),\n    \"kbd\",\n    null,\n    className,\n    null,\n  );\n}\nexport function label(className?: string): VNode<HTMLLabelElementProps | null, HTMLLabelElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Label << VNodeFlags.ElementIdOffset),\n    \"label\",\n    null,\n    className,\n    null,\n  );\n}\nexport function legend(className?: string): VNode<HTMLLegendElementProps | null, HTMLLegendElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Legend << VNodeFlags.ElementIdOffset),\n    \"legend\",\n    null,\n    className,\n    null,\n  );\n}\nexport function li(className?: string): VNode<HTMLLIElementProps | null, HTMLLIElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Li << VNodeFlags.ElementIdOffset),\n    \"li\",\n    null,\n    className,\n    null,\n  );\n}\nexport function link(className?: string): VNode<HTMLLinkElementProps | null, HTMLLinkElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Link << VNodeFlags.ElementIdOffset),\n    \"link\",\n    null,\n    className,\n    null,\n  );\n}\nexport function listing(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Listing << VNodeFlags.ElementIdOffset),\n    \"listing\",\n    null,\n    className,\n    null,\n  );\n}\nexport function main(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Main << VNodeFlags.ElementIdOffset),\n    \"main\",\n    null,\n    className,\n    null,\n  );\n}\nexport function map(className?: string): VNode<HTMLMapElementProps | null, HTMLMapElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Map << VNodeFlags.ElementIdOffset),\n    \"map\",\n    null,\n    className,\n    null,\n  );\n}\nexport function mark(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Mark << VNodeFlags.ElementIdOffset),\n    \"mark\",\n    null,\n    className,\n    null,\n  );\n}\nexport function menu(className?: string): VNode<HTMLMenuElementProps | null, HTMLMenuElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Menu << VNodeFlags.ElementIdOffset),\n    \"menu\",\n    null,\n    className,\n    null,\n  );\n}\nexport function meta(className?: string): VNode<HTMLMetaElementProps | null, HTMLMetaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Meta << VNodeFlags.ElementIdOffset),\n    \"meta\",\n    null,\n    className,\n    null,\n  );\n}\nexport function meter(className?: string): VNode<HTMLMeterElementProps | null, HTMLMeterElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Meter << VNodeFlags.ElementIdOffset),\n    \"meter\",\n    null,\n    className,\n    null,\n  );\n}\nexport function nav(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Nav << VNodeFlags.ElementIdOffset),\n    \"nav\",\n    null,\n    className,\n    null,\n  );\n}\nexport function nobr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Nobr << VNodeFlags.ElementIdOffset),\n    \"nobr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function noframes(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Noframes << VNodeFlags.ElementIdOffset),\n    \"noframes\",\n    null,\n    className,\n    null,\n  );\n}\nexport function noscript(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Noscript << VNodeFlags.ElementIdOffset),\n    \"noscript\",\n    null,\n    className,\n    null,\n  );\n}\nexport function object(className?: string): VNode<HTMLObjectElementProps | null, HTMLObjectElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Object << VNodeFlags.ElementIdOffset),\n    \"object\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ol(className?: string): VNode<HTMLOListElementProps | null, HTMLOListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ol << VNodeFlags.ElementIdOffset),\n    \"ol\",\n    null,\n    className,\n    null,\n  );\n}\nexport function optgroup(className?: string): VNode<HTMLOptGroupElementProps | null, HTMLOptGroupElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Optgroup << VNodeFlags.ElementIdOffset),\n    \"optgroup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function option(className?: string): VNode<HTMLOptionElementProps | null, HTMLOptionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Option << VNodeFlags.ElementIdOffset),\n    \"option\",\n    null,\n    className,\n    null,\n  );\n}\nexport function p(className?: string): VNode<HTMLParagraphElementProps | null, HTMLParagraphElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.P << VNodeFlags.ElementIdOffset),\n    \"p\",\n    null,\n    className,\n    null,\n  );\n}\nexport function param(className?: string): VNode<HTMLParamElementProps | null, HTMLParamElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Param << VNodeFlags.ElementIdOffset),\n    \"param\",\n    null,\n    className,\n    null,\n  );\n}\nexport function picture(className?: string): VNode<HTMLPictureElementProps | null, HTMLPictureElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Picture << VNodeFlags.ElementIdOffset),\n    \"picture\",\n    null,\n    className,\n    null,\n  );\n}\nexport function plaintext(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Plaintext << VNodeFlags.ElementIdOffset),\n    \"plaintext\",\n    null,\n    className,\n    null,\n  );\n}\nexport function pre(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Pre << VNodeFlags.ElementIdOffset),\n    \"pre\",\n    null,\n    className,\n    null,\n  );\n}\nexport function progress(className?: string): VNode<HTMLProgressElementProps | null, HTMLProgressElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Progress << VNodeFlags.ElementIdOffset),\n    \"progress\",\n    null,\n    className,\n    null,\n  );\n}\nexport function q(className?: string): VNode<HTMLQuoteElementProps | null, HTMLQuoteElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Q << VNodeFlags.ElementIdOffset),\n    \"q\",\n    null,\n    className,\n    null,\n  );\n}\nexport function rt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Rt << VNodeFlags.ElementIdOffset),\n    \"rt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ruby(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ruby << VNodeFlags.ElementIdOffset),\n    \"ruby\",\n    null,\n    className,\n    null,\n  );\n}\nexport function s(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.S << VNodeFlags.ElementIdOffset),\n    \"s\",\n    null,\n    className,\n    null,\n  );\n}\nexport function samp(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Samp << VNodeFlags.ElementIdOffset),\n    \"samp\",\n    null,\n    className,\n    null,\n  );\n}\nexport function script(className?: string): VNode<HTMLScriptElementProps | null, HTMLScriptElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Script << VNodeFlags.ElementIdOffset),\n    \"script\",\n    null,\n    className,\n    null,\n  );\n}\nexport function section(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Section << VNodeFlags.ElementIdOffset),\n    \"section\",\n    null,\n    className,\n    null,\n  );\n}\nexport function select(className?: string): VNode<HTMLSelectElementProps | null, HTMLSelectElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Select << VNodeFlags.ElementIdOffset),\n    \"select\",\n    null,\n    className,\n    null,\n  );\n}\nexport function small(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Small << VNodeFlags.ElementIdOffset),\n    \"small\",\n    null,\n    className,\n    null,\n  );\n}\nexport function source(className?: string): VNode<HTMLSourceElementProps | null, HTMLSourceElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Source << VNodeFlags.ElementIdOffset),\n    \"source\",\n    null,\n    className,\n    null,\n  );\n}\nexport function span(className?: string): VNode<HTMLSpanElementProps | null, HTMLSpanElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Span << VNodeFlags.ElementIdOffset),\n    \"span\",\n    null,\n    className,\n    null,\n  );\n}\nexport function strike(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Strike << VNodeFlags.ElementIdOffset),\n    \"strike\",\n    null,\n    className,\n    null,\n  );\n}\nexport function strong(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Strong << VNodeFlags.ElementIdOffset),\n    \"strong\",\n    null,\n    className,\n    null,\n  );\n}\nexport function style(className?: string): VNode<HTMLStyleElementProps | null, HTMLStyleElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Style << VNodeFlags.ElementIdOffset),\n    \"style\",\n    null,\n    className,\n    null,\n  );\n}\nexport function sub(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Sub << VNodeFlags.ElementIdOffset),\n    \"sub\",\n    null,\n    className,\n    null,\n  );\n}\nexport function sup(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Sup << VNodeFlags.ElementIdOffset),\n    \"sup\",\n    null,\n    className,\n    null,\n  );\n}\nexport function table(className?: string): VNode<HTMLTableElementProps | null, HTMLTableElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Table << VNodeFlags.ElementIdOffset),\n    \"table\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tbody(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tbody << VNodeFlags.ElementIdOffset),\n    \"tbody\",\n    null,\n    className,\n    null,\n  );\n}\nexport function td(className?: string): VNode<HTMLTableDataCellElementProps | null, HTMLTableDataCellElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Td << VNodeFlags.ElementIdOffset),\n    \"td\",\n    null,\n    className,\n    null,\n  );\n}\nexport function template(className?: string): VNode<HTMLTemplateElementProps | null, HTMLTemplateElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Template << VNodeFlags.ElementIdOffset),\n    \"template\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tfoot(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tfoot << VNodeFlags.ElementIdOffset),\n    \"tfoot\",\n    null,\n    className,\n    null,\n  );\n}\nexport function th(className?: string): VNode<HTMLTableHeaderCellElementProps | null, HTMLTableHeaderCellElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Th << VNodeFlags.ElementIdOffset),\n    \"th\",\n    null,\n    className,\n    null,\n  );\n}\nexport function thead(className?: string): VNode<HTMLTableSectionElementProps | null, HTMLTableSectionElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Thead << VNodeFlags.ElementIdOffset),\n    \"thead\",\n    null,\n    className,\n    null,\n  );\n}\nexport function time(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Time << VNodeFlags.ElementIdOffset),\n    \"time\",\n    null,\n    className,\n    null,\n  );\n}\nexport function title(className?: string): VNode<HTMLTitleElementProps | null, HTMLTitleElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Title << VNodeFlags.ElementIdOffset),\n    \"title\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tr(className?: string): VNode<HTMLTableRowElementProps | null, HTMLTableRowElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tr << VNodeFlags.ElementIdOffset),\n    \"tr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function track(className?: string): VNode<HTMLTrackElementProps | null, HTMLTrackElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Track << VNodeFlags.ElementIdOffset),\n    \"track\",\n    null,\n    className,\n    null,\n  );\n}\nexport function tt(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Tt << VNodeFlags.ElementIdOffset),\n    \"tt\",\n    null,\n    className,\n    null,\n  );\n}\nexport function u(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.U << VNodeFlags.ElementIdOffset),\n    \"u\",\n    null,\n    className,\n    null,\n  );\n}\nexport function ul(className?: string): VNode<HTMLUListElementProps | null, HTMLUListElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Ul << VNodeFlags.ElementIdOffset),\n    \"ul\",\n    null,\n    className,\n    null,\n  );\n}\nexport function wbr(className?: string): VNode<HTMLElementProps | null, HTMLElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.VoidElement | (TagId.Wbr << VNodeFlags.ElementIdOffset),\n    \"wbr\",\n    null,\n    className,\n    null,\n  );\n}\nexport function xmp(className?: string): VNode<HTMLPreElementProps | null, HTMLPreElement> {\n  return new VNode(\n    VNodeFlags.Element | (TagId.Xmp << VNodeFlags.ElementIdOffset),\n    \"xmp\",\n    null,\n    className,\n    null,\n  );\n}\n\n// Textarea / Input Elements:\nexport function textarea(className?: string): VNode<HTMLTextAreaElementProps | null, HTMLTextAreaElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.TextAreaElement | (TagId.Textarea << VNodeFlags.ElementIdOffset),\n    \"textarea\",\n    null,\n    className,\n    null,\n  );\n}\nexport function input(className?: string): VNode<HTMLInputElementProps | null, HTMLInputElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.InputElement | VNodeFlags.VoidElement | (TagId.Input << VNodeFlags.ElementIdOffset),\n    \"input\",\n    null,\n    className,\n    null,\n  );\n}\n\n// Media Elements:\nexport function audio(className?: string): VNode<HTMLAudioElementProps | null, HTMLAudioElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.MediaElement | (TagId.Audio << VNodeFlags.ElementIdOffset),\n    \"audio\",\n    null,\n    className,\n    null,\n  );\n}\n\nexport function video(className?: string): VNode<HTMLVideoElementProps | null, HTMLVideoElement> {\n  return new VNode(\n    VNodeFlags.Element | VNodeFlags.MediaElement | (TagId.Video << VNodeFlags.ElementIdOffset),\n    \"video\",\n    null,\n    className,\n    null,\n  );\n}\n","/**\n * @final\n */\nvar Query = /** @class */ (function () {\n    function Query(elapsed, query) {\n        this.elapsed = elapsed;\n        this.query = query;\n    }\n    Query.rand = function () {\n        var elapsed = Math.random() * 15;\n        var query;\n        if (Math.random() < 0.1) {\n            query = \"vacuum\";\n        }\n        else if (Math.random() < 0.2) {\n            query = \"<IDLE> in transaction\";\n        }\n        else {\n            query = \"SELECT blah FROM something\";\n        }\n        return new Query(elapsed, query);\n    };\n    return Query;\n}());\nexport { Query };\nvar EMPTY_QUERY = new Query(0, \"***\");\n/**\n * @final\n */\nvar DB = /** @class */ (function () {\n    function DB(name) {\n        this.id = DB._nextId++;\n        this.name = name;\n        this.queries = null;\n        this.update();\n    }\n    DB.prototype.update = function () {\n        var queries = [];\n        var r = Math.floor((Math.random() * 10) + 1);\n        for (var j = 0; j < r; j++) {\n            queries.push(Query.rand());\n        }\n        this.queries = queries;\n    };\n    DB.prototype.getTopFiveQueries = function () {\n        var qs = this.queries.slice(0, 5);\n        qs.sort(function (a, b) {\n            return a.elapsed - b.elapsed;\n        });\n        while (qs.length < 5) {\n            qs.push(EMPTY_QUERY);\n        }\n        return qs;\n    };\n    DB._nextId = 0;\n    return DB;\n}());\nexport { DB };\n/**\n * @final\n */\nvar DBList = /** @class */ (function () {\n    function DBList(n) {\n        this.dbs = [];\n        for (var i = 0; i < n; i++) {\n            this.dbs.push(new DB(\"cluster\" + (i + 1)));\n            this.dbs.push(new DB(\"cluster\" + (i + 1) + \" slave\"));\n        }\n    }\n    DBList.prototype.update = function () {\n        var dbs = this.dbs;\n        for (var i = 0; i < dbs.length; i++) {\n            dbs[i] = new DB(dbs[i].name);\n        }\n    };\n    DBList.prototype.randomUpdate = function (r) {\n        var dbs = this.dbs;\n        for (var i = 0; i < dbs.length; i++) {\n            if (Math.random() < r) {\n                dbs[i] = new DB(dbs[i].name);\n            }\n        }\n    };\n    return DBList;\n}());\nexport { DBList };\n","var MonitorMaxSamples = 100;\nvar MonitorSamplesResult = (function () {\n    function MonitorSamplesResult(min, max, mean, last) {\n        this.min = min;\n        this.max = max;\n        this.mean = mean;\n        this.last = last;\n    }\n    return MonitorSamplesResult;\n}());\n/**\n * Profile Samples.\n */\nvar MonitorSamples = (function () {\n    function MonitorSamples(maxSamples) {\n        this.samples = [];\n        this.maxSamples = maxSamples;\n        this._i = -1;\n    }\n    MonitorSamples.prototype.addSample = function (v) {\n        this._i = (this._i + 1) % this.maxSamples;\n        this.samples[this._i] = v;\n    };\n    MonitorSamples.prototype.each = function (fn) {\n        var samples = this.samples;\n        for (var i = 0; i < samples.length; i++) {\n            fn(samples[(this._i + 1 + i) % samples.length], i);\n        }\n    };\n    MonitorSamples.prototype.calc = function () {\n        var samples = this.samples;\n        if (samples.length === 0) {\n            return new MonitorSamplesResult(0, 0, 0, 0);\n        }\n        var min = samples[(this._i + 1) % samples.length];\n        var max = min;\n        var sum = 0;\n        for (var i = 0; i < samples.length; i++) {\n            var k = samples[(this._i + 1 + i) % samples.length];\n            if (k < min) {\n                min = k;\n            }\n            if (k > max) {\n                max = k;\n            }\n            sum += k;\n        }\n        var last = samples[this._i];\n        var mean = sum / samples.length;\n        return new MonitorSamplesResult(min, max, mean, last);\n    };\n    return MonitorSamples;\n}());\n\n/**\n * Basic Counter.\n */\nvar BasicCounter = (function () {\n    function BasicCounter() {\n        this.value = 0;\n        this.onChange = null;\n    }\n    BasicCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return BasicCounter;\n}());\nvar TimestampedValue = (function () {\n    function TimestampedValue(timestamp, value) {\n        this.value = value;\n        this.next = null;\n    }\n    return TimestampedValue;\n}());\n/**\n * Sliding Counter counts how many times `inc` method were called during `interval` period.\n */\nvar SlidingCounter = (function () {\n    function SlidingCounter(interval) {\n        var _this = this;\n        this._dec = function () {\n            var now = performance.now();\n            while (_this._firstTimestamp !== null) {\n                var nextTimestamp = _this._firstTimestamp;\n                if (now >= nextTimestamp.value) {\n                    _this.value -= nextTimestamp.value;\n                    _this._firstTimestamp = _this._firstTimestamp.next;\n                }\n                else {\n                    setTimeout(_this._dec, Math.ceil(nextTimestamp.value - now));\n                    break;\n                }\n            }\n            if (_this._firstTimestamp === null) {\n                _this._lastTimestamp = null;\n            }\n            _this.onChange();\n        };\n        this.interval = interval;\n        this.value = 0;\n        this.onChange = null;\n        this._firstTimestamp = null;\n        this._lastTimestamp = null;\n    }\n    SlidingCounter.prototype.inc = function (value) {\n        if (value > 0) {\n            var timestamp = new TimestampedValue(performance.now() + this.interval, value);\n            if (this._firstTimestamp === null) {\n                this._firstTimestamp = timestamp;\n                setTimeout(this._dec, this.interval);\n            }\n            else {\n                this._lastTimestamp.next = timestamp;\n            }\n            this._lastTimestamp = timestamp;\n            this.value += value;\n            this.onChange();\n        }\n    };\n    return SlidingCounter;\n}());\n\nvar frameTasks = [];\nvar rafId = -1;\n/**\n * Schedule new task that will be executed on the next frame.\n */\nfunction scheduleNextFrameTask(task) {\n    frameTasks.push(task);\n    if (rafId === -1) {\n        requestAnimationFrame(function (t) {\n            rafId = -1;\n            var tasks = frameTasks;\n            frameTasks = [];\n            for (var i = 0; i < tasks.length; i++) {\n                tasks[i]();\n            }\n        });\n    }\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar MonitorGraphHeight = 30;\nvar MonitorGraphWidth = MonitorMaxSamples;\nvar Widget = (function () {\n    function Widget(name) {\n        var _this = this;\n        this._sync = function () {\n            _this.sync();\n            _this._dirty = false;\n        };\n        this.name = name;\n        this.element = document.createElement(\"div\");\n        this.element.style.cssText = \"padding: 2px;\" +\n            \"background-color: #020;\" +\n            \"font-family: monospace;\" +\n            \"font-size: 12px;\" +\n            \"color: #0f0\";\n        this._dirty = false;\n        this.invalidate();\n    }\n    Widget.prototype.invalidate = function () {\n        if (!this._dirty) {\n            this._dirty = true;\n            scheduleNextFrameTask(this._sync);\n        }\n    };\n    Widget.prototype.sync = function () {\n        throw new Error(\"sync method not implemented\");\n    };\n    return Widget;\n}());\nvar MonitorWidgetFlags;\n(function (MonitorWidgetFlags) {\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMin\"] = 1] = \"HideMin\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMax\"] = 2] = \"HideMax\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideMean\"] = 4] = \"HideMean\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideLast\"] = 8] = \"HideLast\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"HideGraph\"] = 16] = \"HideGraph\";\n    MonitorWidgetFlags[MonitorWidgetFlags[\"RoundValues\"] = 32] = \"RoundValues\";\n})(MonitorWidgetFlags || (MonitorWidgetFlags = {}));\nvar MonitorWidget = (function (_super) {\n    __extends(MonitorWidget, _super);\n    function MonitorWidget(name, flags, unitName, samples) {\n        var _this = _super.call(this, name) || this;\n        _this.flags = flags;\n        _this.unitName = unitName;\n        _this.samples = samples;\n        var label = document.createElement(\"div\");\n        label.style.cssText = \"text-align: center\";\n        label.textContent = _this.name;\n        var text = document.createElement(\"div\");\n        if ((flags & MonitorWidgetFlags.HideMin) === 0) {\n            _this.minText = document.createElement(\"div\");\n            text.appendChild(_this.minText);\n        }\n        else {\n            _this.minText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMax) === 0) {\n            _this.maxText = document.createElement(\"div\");\n            text.appendChild(_this.maxText);\n        }\n        else {\n            _this.maxText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideMean) === 0) {\n            _this.meanText = document.createElement(\"div\");\n            text.appendChild(_this.meanText);\n        }\n        else {\n            _this.meanText = null;\n        }\n        if ((flags & MonitorWidgetFlags.HideLast) === 0) {\n            _this.lastText = document.createElement(\"div\");\n            text.appendChild(_this.lastText);\n        }\n        else {\n            _this.lastText = null;\n        }\n        _this.element.appendChild(label);\n        _this.element.appendChild(text);\n        if ((flags & MonitorWidgetFlags.HideGraph) === 0) {\n            _this.canvas = document.createElement(\"canvas\");\n            _this.canvas.style.cssText = \"display: block; padding: 0; margin: 0\";\n            _this.canvas.width = MonitorGraphWidth;\n            _this.canvas.height = MonitorGraphHeight;\n            _this.ctx = _this.canvas.getContext(\"2d\");\n            _this.element.appendChild(_this.canvas);\n        }\n        else {\n            _this.canvas = null;\n            _this.ctx = null;\n        }\n        return _this;\n    }\n    MonitorWidget.prototype.sync = function () {\n        var _this = this;\n        var result = this.samples.calc();\n        var scale = MonitorGraphHeight / (result.max * 1.2);\n        var min;\n        var max;\n        var mean;\n        var last;\n        if ((this.flags & MonitorWidgetFlags.RoundValues) === 0) {\n            min = result.min.toFixed(2);\n            max = result.max.toFixed(2);\n            mean = result.mean.toFixed(2);\n            last = result.last.toFixed(2);\n        }\n        else {\n            min = Math.round(result.min).toString();\n            max = Math.round(result.max).toString();\n            mean = Math.round(result.mean).toString();\n            last = Math.round(result.last).toString();\n        }\n        if (this.minText !== null) {\n            this.minText.textContent = \"min: \\u00A0\" + min + this.unitName;\n        }\n        if (this.maxText !== null) {\n            this.maxText.textContent = \"max: \\u00A0\" + max + this.unitName;\n        }\n        if (this.meanText !== null) {\n            this.meanText.textContent = \"mean: \" + mean + this.unitName;\n        }\n        if (this.lastText !== null) {\n            this.lastText.textContent = \"last: \" + last + this.unitName;\n        }\n        if (this.ctx !== null) {\n            this.ctx.fillStyle = \"#010\";\n            this.ctx.fillRect(0, 0, MonitorGraphWidth, MonitorGraphHeight);\n            this.ctx.fillStyle = \"#0f0\";\n            this.samples.each(function (v, i) {\n                _this.ctx.fillRect(i, MonitorGraphHeight, 1, -(v * scale));\n            });\n        }\n    };\n    return MonitorWidget;\n}(Widget));\nvar CounterWidget = (function (_super) {\n    __extends(CounterWidget, _super);\n    function CounterWidget(name, counter) {\n        var _this = _super.call(this, name) || this;\n        _this.counter = counter;\n        _this.text = document.createElement(\"div\");\n        _this.element.appendChild(_this.text);\n        return _this;\n    }\n    CounterWidget.prototype.sync = function () {\n        this.text.textContent = this.name + \": \" + this.counter.value;\n    };\n    return CounterWidget;\n}(Widget));\n\nvar container = null;\nvar initialized = false;\n/**\n * Initialize Performance Monitor.\n */\nfunction initPerfMonitor(options) {\n    if (!initialized) {\n        if (options.container) {\n            container = options.container;\n        }\n        initialized = true;\n    }\n}\n/**\n * Check that everything is properly initialized.\n */\nfunction checkInit() {\n    if (!container) {\n        container = document.createElement(\"div\");\n        container.style.cssText = \"position: fixed;\" +\n            \"opacity: 0.9;\" +\n            \"right: 0;\" +\n            \"bottom: 0\";\n        document.body.appendChild(container);\n    }\n    initialized = true;\n}\n/**\n * Start FPS monitor\n */\nfunction startFPSMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMax |\n        MonitorWidgetFlags.HideMean | MonitorWidgetFlags.RoundValues; }\n    checkInit();\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"FPS\", flags, \"\", data);\n    container.appendChild(w.element);\n    var alpha = 2 / 121;\n    var last = 0;\n    var fps = 60;\n    function update(now) {\n        if (last > 0) {\n            fps += alpha * ((1000 / (now - last)) - fps);\n        }\n        last = now;\n        data.addSample(fps);\n        w.invalidate();\n        requestAnimationFrame(update);\n    }\n    requestAnimationFrame(update);\n}\n/**\n * Start Memory Monitor\n */\nfunction startMemMonitor(flags) {\n    if (flags === void 0) { flags = MonitorWidgetFlags.HideMin | MonitorWidgetFlags.HideMean; }\n    checkInit();\n    if (performance.memory === undefined) {\n        return;\n    }\n    var data = new MonitorSamples(MonitorMaxSamples);\n    var w = new MonitorWidget(\"Memory\", flags, \"MB\", data);\n    container.appendChild(w.element);\n    function update() {\n        data.addSample(Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)));\n        w.invalidate();\n        setTimeout(update, 30);\n    }\n    update();\n}\nvar ProfilerDetails = (function () {\n    function ProfilerDetails(name, unitName, flags) {\n        this.data = new MonitorSamples(MonitorMaxSamples);\n        this.widget = new MonitorWidget(name, flags, unitName, this.data);\n        this.startTime = -1;\n    }\n    return ProfilerDetails;\n}());\nvar profilerInstances = {};\nvar CounterDetails = (function () {\n    function CounterDetails(name, interval) {\n        var _this = this;\n        this.data = interval === undefined ? new BasicCounter() : new SlidingCounter(interval);\n        this.widget = new CounterWidget(name, this.data);\n        this.data.onChange = function () {\n            _this.widget.invalidate();\n        };\n    }\n    return CounterDetails;\n}());\nvar counterInstances = {};\n/**\n * Initialize profiler and insert into container.\n */\nfunction initProfiler(name, flags) {\n    if (flags === void 0) { flags = 0; }\n    checkInit();\n    var profiler = profilerInstances[name];\n    if (profiler === void 0) {\n        profilerInstances[name] = profiler = new ProfilerDetails(name, \"ms\", flags);\n        container.appendChild(profiler.widget.element);\n    }\n}\n/**\n * Initialize counter and insert into container.\n */\nfunction initCounter(name, interval) {\n    checkInit();\n    var counter = counterInstances[name];\n    if (counter === void 0) {\n        counterInstances[name] = counter = new CounterDetails(name, interval);\n        container.appendChild(counter.widget.element);\n    }\n}\nfunction startProfile(name) {\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0) {\n        profiler.startTime = performance.now();\n    }\n}\nfunction endProfile(name) {\n    var now = performance.now();\n    var profiler = profilerInstances[name];\n    if (profiler !== void 0 && profiler.startTime !== -1) {\n        profiler.data.addSample(now - profiler.startTime);\n        profiler.widget.invalidate();\n    }\n}\nfunction count(name, value) {\n    if (value === void 0) { value = 1; }\n    var counter = counterInstances[name];\n    if (counter !== void 0) {\n        counter.data.inc(value);\n    }\n}\n/**\n * lookup a profile by name\n * @param name the name of the profile to lookup\n */\nfunction getProfile(name) {\n    return profilerInstances[name];\n}\n/**\n * lookup a counter by name\n * @param name the name of the counter to lookup\n */\nfunction getCounter(name) {\n    return counterInstances[name];\n}\n\nexport { initPerfMonitor, startFPSMonitor, startMemMonitor, ProfilerDetails, CounterDetails, initProfiler, initCounter, startProfile, endProfile, count, getProfile, getCounter, MonitorSamplesResult, MonitorMaxSamples, MonitorSamples, BasicCounter, SlidingCounter, Widget, MonitorWidgetFlags, MonitorWidget, CounterWidget };\n","import { statelessComponent, render, update, connect, map } from \"ivi\";\nimport { div, tr, td, span, table, tbody } from \"ivi-html\";\nimport { DBList } from \"./db\";\nimport { startFPSMonitor, startMemMonitor, initProfiler, startProfile, endProfile } from \"perf-monitor\";\nvar mutations = 0.5;\nvar N = 50;\nvar qs = parseQueryString(window.location.search.substr(1).split(\"&\"));\nif (qs[\"n\"] !== undefined) {\n    N = parseInt(qs[\"n\"], 10);\n}\nif (qs[\"m\"] !== undefined) {\n    mutations = parseFloat(qs[\"m\"]);\n}\nvar store = new DBList(N);\nfunction entryFormatElapsed(v) {\n    if (v === 0) {\n        return \"\";\n    }\n    if (v > 60) {\n        var minutes = Math.floor(v / 60);\n        var comps = (v % 60).toFixed(2).split(\".\");\n        var seconds = comps[0];\n        var ms = comps[1];\n        return minutes + \":\" + seconds + \".\" + ms;\n    }\n    return v.toFixed(2);\n}\nfunction counterClasses(count) {\n    if (count >= 20) {\n        return \"label label-important\";\n    }\n    else if (count >= 10) {\n        return \"label label-warning\";\n    }\n    return \"label label-success\";\n}\nfunction queryClasses(elapsed) {\n    if (elapsed > 0) {\n        if (elapsed >= 10.0) {\n            return \"Query elapsed warn_long\";\n        }\n        else if (elapsed >= 1.0) {\n            return \"Query elapsed warn\";\n        }\n        return \"Query elapsed short\";\n    }\n    return \"\";\n}\nvar Popover = statelessComponent(function (query) { return (div(\"popover left\").c(div(\"popover-content\").c(query), div(\"arrow\"))); });\nvar DatabaseList = connect(function (prev, props) {\n    var db = store.dbs[props];\n    if (prev && prev.db === db) {\n        return prev;\n    }\n    return { db: db };\n}, function (props) {\n    var db = props.db;\n    var topFiveQueries = db.getTopFiveQueries();\n    var count = db.queries.length;\n    return tr().c(td(\"dbname\").c(db.name), td(\"query-count\").c(span(counterClasses(count)).c(count)), map(topFiveQueries, function (q, i) { return (td(queryClasses(q.elapsed)).k(i).c(entryFormatElapsed(q.elapsed), Popover(q.query))); }));\n});\nvar Main = statelessComponent(function (props) { return (table(\"table table-striped latest-data\").c(tbody().c(map(props.dbs, function (db, i) { return DatabaseList(i).k(db.id); })))); });\nfunction parseQueryString(a) {\n    if (a.length === 0) {\n        return {};\n    }\n    var b = {};\n    for (var i = 0; i < a.length; ++i) {\n        var p = a[i].split(\"=\", 2);\n        if (p.length === 1) {\n            b[p[0]] = \"\";\n        }\n        else {\n            b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\n        }\n    }\n    return b;\n}\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    startFPSMonitor();\n    startMemMonitor();\n    initProfiler(\"view update\");\n    var sliderContainer = document.createElement(\"div\");\n    sliderContainer.style.display = \"flex\";\n    var slider = document.createElement(\"input\");\n    slider.type = \"range\";\n    slider.style.marginBottom = \"10px\";\n    slider.style.marginTop = \"5px\";\n    var text = document.createElement(\"label\");\n    text.textContent = \"mutations : \" + (mutations * 100).toFixed(0) + \"%\";\n    slider.addEventListener(\"change\", function (e) {\n        mutations = Number.parseFloat(e.target.value) / 100;\n        text.textContent = \"mutations : \" + (mutations * 100).toFixed(0) + \"%\";\n    });\n    sliderContainer.appendChild(text);\n    sliderContainer.appendChild(slider);\n    document.body.insertBefore(sliderContainer, document.body.firstChild);\n    var container = document.getElementById(\"app\");\n    render(Main(store), container);\n    function tick() {\n        store.randomUpdate(mutations);\n        startProfile(\"view update\");\n        update();\n        endProfile(\"view update\");\n        setTimeout(tick, 0);\n    }\n    setTimeout(tick, 0);\n});\n"],"sourceRoot":""}