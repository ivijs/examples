{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/operations.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/factories.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/array.ts","webpack:////home/void/w/ts/ivi/packages/ivi-scheduler/src/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/error.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/noop.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/repeatable_task_list.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/feature_detection.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/shortcuts.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/dom/namespaces.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/state.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/context.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/reconciler.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/empty_object.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/root.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/scheduler/index.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/accumulate_dispatch_targets.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/dispatch_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/synthetic_native_event.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_event_dispatcher.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/events/native_events.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/vdom/attribute_directive.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/box.ts","webpack:////home/void/w/ts/ivi/packages/ivi-html/src/index.ts","webpack:///./src/state.ts","webpack:///./src/main.ts","webpack:////home/void/w/ts/ivi/packages/ivi/src/core/shortcuts.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","createOpType","f","EVENTS","TRACK_BY_KEY","createOpNode","Events","v","operations_key","k","TrackByKey","items","elementFactory","tag","flags","type","a","htmlElementFactory","unorderedArrayDeleteByIndex","array","index","length","last","pop","rAF","cb","requestAnimationFrame","ERROR_HANDLERS","catchError","fn","apply","arguments","e","forEach","h","NOOP","runRepeatableTasks","tasks","opts","[object Object]","window","addEventListener","KeyboardEvent","MouseEvent","IOS_GESTURE_EVENT","nodeProto","Node","shortcuts_elementProto","Element","objectHasOwnProperty","nodeInsertBefore","insertBefore","nodeRemoveChild","removeChild","nodeCloneNode","replaceChild","cloneNode","elementSetAttribute","setAttribute","elementRemoveAttribute","setAttributeNS","removeAttribute","SVG_NAMESPACE","createStateNode","_nextNode","_deepStateFlags","_dirtyContext","_context","setContext","tmp","restoreContext","context","_pushDeepState","_popDeepState","prev","current","getDOMNode","opState","children","_dirtyCheck","parentElement","moveNode","singleChild","state","deepState","_update","_moveNodes","assign","prevContext","domNode","_unmountWalk","u","_unmountRemove","textContent","_unmount","_mountText","op","node","document","createTextNode","_createElement","opType","svg","tagName","createElementNS","createElement","_updateClassName","_updateAttrs","_mountObject","deepStateFlags","prevState","_mount","descriptor","Array","_mountFragment","childrenOps","newChildren","stateNode","nextOp","nodeValue","b","opStateChildren","prevData","nextData","nextValue","su","_updateChildrenTrackByKeys","dirtyContext","j","result","aEnd","bEnd","start","outer","pos","updated","aLength","bLength","sources","keyIndex","Map","set","seq","lis","slice","element","className","_updateStyle","style","bValue","setProperty","removeProperty","matchCount","keys","_updateAttr","next","ROOTS","findRoot","predicate","find","dirtyCheck","root","container","run","_flags","_microtasks","_mutationEffects","_domLayoutEffects","_beforeMutations","_afterMutations","_frameStartTime","withSchedulerTick","inner","runMicrotasks","_handleNextFrame","time","performance","now","withNextFrame","requestNextFrame","task","push","Promise","resolve","then","requestDirtyCheck","render","onclick","accumulateDispatchTargets","target","match","contains","visitUp","parentNode","visitDown","accumulateDispatchTargetsFromEventsOpNode","dispatchEvent","targets","event","bubble","dispatch","dispatchEventToLocalEventHandlers","matchFlags","handlers","_dispatch","handler","createNativeEvent","timestamp","native","createNativeEventDispatcher","options","source","matchEventSource","src","ev","syntheticEvent","timeStamp","dispatchToListeners","preventDefault","listeners","cbs","createNativeEventHandler","bubbleDescriptor","captureDescriptor","capture","onKeyDown","updateAutofocus","focus","AUTOFOCUS_FALSE","AUTOFOCUS_TRUE","AUTOFOCUS","box","div","LEFT","x","y","RIGHT","UP","DOWN","Snake","startPosition","this","body","grow","head","splice","Grid","rows","cols","cells","fill","flag","pointToIndex","Math","random","addPoints","mod","cellClassName","GameView","game","keyDown","keyCode","setNewDirection","props","gameOver","tabIndex","autofocus","width","grid","height","map","component","CONTAINER","getElementById","GAME","startTime","currentTime","direction","snake","newDirection","mark","createRandomFood","dir","nextPosition","unmark","tail","move","isBodyAt","isFoodAt","tick","updateState","setTimeout"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { EventHandler } from \"../events/event_handler\";\nimport { NodeFlags } from \"./node_flags\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, StatelessComponentDescriptor } from \"./component\";\n\n/**\n * Operation type.\n */\nexport interface OpType {\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  readonly f: NodeFlags;\n  /**\n   * Operation type descriptor.\n   */\n  readonly d: StatelessComponentDescriptor | ComponentDescriptor | ElementProtoDescriptor | string | null;\n}\n\n/**\n * createOpType creates {@link OpType} instances.\n *\n * @param f See {@link NodeFlags} for details.\n * @param d Operation type descriptor.\n * @returns {@link OpType} instance.\n */\nexport const createOpType = (\n  f: NodeFlags,\n  d: StatelessComponentDescriptor | ComponentDescriptor | ElementProtoDescriptor | string | null,\n): OpType => ({ f, d });\n\n/**\n * OpType for Events nodes.\n */\nexport const EVENTS = createOpType(NodeFlags.Events, null);\n\n/**\n * OpType for Context nodes.\n */\nexport const CONTEXT = createOpType(NodeFlags.Context, null);\n\n/**\n * OpType for TrackByKey nodes.\n */\nexport const TRACK_BY_KEY = createOpType(NodeFlags.TrackByKey, null);\n\n/**\n * Operation node.\n *\n * @typeparam T Operation data type.\n */\nexport interface OpNode<T = any> {\n  /**\n   * Operation type.\n   */\n  readonly t: OpType;\n  /**\n   * Operation data.\n   */\n  readonly d: T;\n}\n\n/**\n * createOpNode creates an {@link OpNode} instance.\n *\n * @typeparam T Operation data type.\n * @param t Operation type.\n * @param d Operation data.\n * @returns {@link OpNode} instance.\n */\nexport const createOpNode = <T>(t: OpType, d: T): OpNode<T> => ({ t, d });\n\n/**\n * Operation data for element operations.\n *\n * @typeparam T Element attributes type.\n */\nexport interface ElementData<T = any> {\n  /**\n   * Element class name.\n   */\n  readonly n: string | undefined;\n  /**\n   * Element attributes.\n   */\n  readonly a: T | undefined;\n  /**\n   * Children operations.\n   */\n  readonly c: Op;\n}\n\n/**\n * Operation.\n */\nexport type Op = string | number | OpNode | OpArray | null;\n\n/**\n * Recursive operation array.\n */\nexport interface OpArray extends Readonly<Array<Op>> { }\n\n/**\n * Generic operation data for operations that has children nodes.\n *\n * @typeparam T Additional data type.\n */\nexport interface OpData<T = any> {\n  /**\n   * Generic value.\n   */\n  readonly v: T;\n  /**\n   * Children operation nodes.\n   */\n  readonly c: Op;\n}\n\n/**\n * Operation data for Events operations.\n */\nexport type EventsData = OpData<EventHandler>;\n\n/**\n * Operation data for Context operations.\n */\nexport type ContextData = OpData<{}>;\n\n/**\n * Operation factory for event handlers.\n *\n * @example\n *\n *     render(\n *       Events(onClick(() => { console.log(\"clicked\"); }),\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param v Event handlers.\n * @param c Children operation nodes.\n * @returns Events handler operation.\n */\nexport const Events = (\n  v: EventHandler,\n  c: Op,\n): OpNode<EventsData> => createOpNode(EVENTS, { v, c });\n\n/**\n * Operation factory for context nodes.\n *\n * @example\n *\n *     render(\n *       Context({ key: 123 },\n *         ChildComponent(),\n *       ),\n *       DOMContainer,\n *     );\n *\n * @param v Context object.\n * @param c Children operation nodes.\n * @returns Context operation.\n */\nexport const Context = (v: {}, c: Op): OpNode<ContextData> => createOpNode(CONTEXT, { v, c });\n\n/**\n * Key is an object that is used by TrackByKey operations to track operations.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n */\nexport interface Key<K, V> {\n  /**\n   * Key.\n   */\n  readonly k: K;\n  /**\n   * Value.\n   */\n  readonly v: V;\n}\n\n/**\n * key creates a {@link Key} instance.\n *\n * @typeparam K Key type.\n * @typeparam V Value type.\n * @param k Key.\n * @param v Value.\n * @returns {@link Key} instance.\n */\nexport const key = <K, V>(k: K, v: V): Key<K, V> => ({ k, v });\n\n/**\n * Operation factory for track by key nodes.\n *\n * @example\n *\n *     const items = [1, 2, 3];\n *     render(\n *       TrackByKey(items.map((item) => key(item, div(_, _, item))),\n *       DOMContainer,\n *     );\n *\n * @typeparam K Key type.\n * @param items Keyed operations.\n * @returns Track by key operation.\n */\nexport const TrackByKey = __IVI_DEBUG__ ?\n  <T>(items: Key<T, Op>[]) => {\n    const keys = new Set<T>();\n    for (let i = 0; i < items.length; i++) {\n      const { k } = items[i];\n      if (keys.has(k)) {\n        throw new Error(`Invalid key, found duplicated key: ${k}`);\n      }\n      keys.add(k);\n    }\n    return createOpNode(TRACK_BY_KEY, items);\n  } :\n  /* istanbul ignore next */ <T>(items: Key<T, Op>[]) => createOpNode(TRACK_BY_KEY, items);\n","import { checkElement } from \"../debug/element\";\nimport { NodeFlags } from \"./node_flags\";\nimport { OpNode, Op, ElementData, createOpNode, createOpType } from \"./operations\";\nimport { Component } from \"./component\";\n\n/**\n * elementFactory creates a factory for DOM elements.\n *\n * @param tag HTML element tag name.\n * @param flags Node flags.\n * @returns HTML element operation factory.\n */\nexport function elementFactory<T, U>(tag: string, flags: NodeFlags) {\n  const type = createOpType(flags, tag);\n  return __IVI_DEBUG__ ?\n    (n?: string, a?: T, c: Op = null) => {\n      checkElement(tag, a, (flags & NodeFlags.Svg) !== 0);\n      return createOpNode<ElementData<T>>(type, { n, a, c });\n    } :\n    /* istanbul ignore next */(n?: string, a?: T, c: Op = null) => createOpNode<ElementData<T>>(type, { n, a, c });\n}\n\n/**\n * htmlElementFactory creates a factory for HTML elements.\n *\n * @param tag HTML element tag name.\n * @returns HTML element operation factory.\n */\nexport const htmlElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => OpNode<ElementData<T>> = (tag: string) => elementFactory(tag, NodeFlags.Element);\n\n/**\n * svgElementFactory creates a factory for SVG elements.\n *\n * @param tag SVG element tag name.\n * @returns SVG element operation factory.\n */\nexport const svgElementFactory: <T, U>(tag: string) => (\n  className?: string,\n  attrs?: T,\n  children?: Op,\n) => OpNode<ElementData<T>> = (tag: string) => elementFactory(tag, NodeFlags.Element | NodeFlags.Svg);\n\n/**\n * `elementProto()` creates a factory that produces elements with predefined attributes.\n *\n * @example\n *\n *     const DivWithIdAttribute = elementProto(div(_, { id: \"predefined-id\" }));\n *\n *     render(\n *       DivWithIdAttribute(\"class-name\", { title: \"Title\" }, \"Hello World\"),\n *       document.getElementById(\"app\")!,\n *     );\n *\n * @param p Element prototype.\n * @returns Factory that produces elements with predefined attributes.\n */\nexport function elementProto<T>(p: OpNode<ElementData<T>>) {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (p.d.c !== null) {\n      throw new Error(`Invalid OpNode, element prototypes can't have any children`);\n    }\n    checkElement(p.t.d as string, p.d.a, (p.t.f & NodeFlags.Svg) !== 0);\n  }\n  const type = createOpType(p.t.f | NodeFlags.ElementProto, { n: null, p });\n  return (n?: string, a?: T, c: Op = null) => createOpNode<ElementData<T>>(type, { n, a, c });\n}\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component(\n  c: (c: Component) => () => Op,\n): () => OpNode<undefined>;\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: Component) => (props: P) => Op,\n  shouldUpdate?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => OpNode<P> : (props: P) => OpNode<P>;\n\n/**\n * component creates a factory that produces component nodes.\n *\n * @example\n *\n *     const A = component<string>(() => {\n *       let _text;\n *       const click = onClick(() => { console.log(_text); });\n *\n *       return (text) => (\n *         _text = text,\n *         Events(click,\n *           button(_, _, \"Click Me\"),\n *         )\n *       );\n *     });\n *\n * @param c Component function.\n * @param su `shouldUpdate` function.\n * @returns Factory that produces component nodes.\n */\nexport function component<P>(\n  c: (c: Component) => (props: P) => Op,\n  su?: (prev: P, next: P) => boolean,\n): (props: P) => OpNode<P> {\n  const type = createOpType(NodeFlags.Component | NodeFlags.Stateful | NodeFlags.DirtyCheck, { c, su });\n  return (props: P) => createOpNode(type, props);\n}\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @param shouldUpdate `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent(\n  update: () => Op,\n): () => OpNode<undefined>;\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param update Update function.\n * @param su `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  update: (props: P) => Op,\n  su?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): undefined extends P ? (props?: P) => OpNode<P> : (props: P) => OpNode<P>;\n\n/**\n * statelessComponent creates an factory that produces stateless components nodes.\n *\n * @example\n *\n *     const A = statelessComponent<string>((text) => div(_, _, text));\n *\n * @param c Update function.\n * @param su `shouldUpdate` function.\n * @returns Factory that produces stateless component nodes.\n */\nexport function statelessComponent<P>(\n  c: (props: P) => Op,\n  su?: undefined extends P ? undefined : (prev: P, next: P) => boolean,\n): (props: P) => OpNode<P> {\n  const type = createOpType(NodeFlags.Component, { c, su });\n  return (props: P) => createOpNode(type, props);\n}\n","/**\n * append pushes item to an array and automatically creates a new array when it doesn't exist.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param item Item to append.\n * @returns Array.\n */\nexport const append = <T>(array: T[] | null, item: T) => array === null ? [item] : (array.push(item), array);\n\n/**\n * unorderedArrayDeleteByIndex deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and removes the last one.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param index Index of an item to delete.\n */\nexport function unorderedArrayDeleteByIndex<T>(array: T[], index: number): void {\n  const length = array.length - 1;\n  const last = array.pop();\n  if (index !== length) {\n    array[index] = last!;\n  }\n}\n\n/**\n * unorderedArrayDelete deletes item from an array with O(1) complexity.\n *\n * It swaps item at `index` position with the last item and deletes the last one.\n *\n * @typeparam T Item type.\n * @param array Array.\n * @param item Item to delete.\n */\nexport function unorderedArrayDelete<T>(array: T[], item: T): void {\n  const index = array.indexOf(item);\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (index === -1) {\n      throw new Error(`Failed to delete an item from an array, item doesn't exist in the array`);\n    }\n  }\n  unorderedArrayDeleteByIndex(array, index);\n}\n","export function rAF(cb: (time?: number) => void): void {\n  requestAnimationFrame(cb);\n}\n\nexport function sMT(cb: () => void): void {\n  Promise.resolve().then(cb);\n}\n","const ERROR_HANDLERS: Array<(e: any) => void> = [];\n\n/**\n * addErrorHandler adds an error handler for errors catched by functions decorated with `catchError()`.\n *\n * @param handler error handler.\n */\nexport function addErrorHandler(handler: (e: any) => void): void {\n  ERROR_HANDLERS.push(handler);\n}\n\n/**\n * catchError is a decorator that catches exceptions and invokes error handlers registered with `addErrorHandler()`.\n *\n * @noinline\n * @throws\n * @param fn - Function to decorate\n * @returns function decorated with a catchError\n */\nexport function catchError<T>(fn: (...args: any[]) => T): (...args: any[]) => T;\nexport function catchError<T>(fn: Function): (...args: any[]) => T {\n  return function () {\n    try {\n      return fn.apply(void 0, arguments);\n    } catch (e) {\n      ERROR_HANDLERS.forEach((h) => { h(e); });\n      throw e;\n    }\n  };\n}\n","/**\n * NOOP function.\n */\nexport const NOOP = () => { /**/ };\n\n/**\n * NOOP_FALSE function always returns `false` value.\n *\n * @returns `false` value.\n */\nexport const NOOP_FALSE = () => false;\n\n/**\n * NOOP_TRUE function always returns `true` value.\n *\n * @returns `true` value.\n */\nexport const NOOP_TRUE = () => true;\n","import { unorderedArrayDeleteByIndex } from \"./array\";\n\n/**\n * RepeatableTaskList is a data structure for tasks that will be repeated until they return `true` value.\n */\nexport type RepeatableTaskList = Array<() => boolean | void>;\n\n/**\n * runRepeatableTasks runs repeatable tasks.\n *\n * @param tasks Repeatable tasks.\n */\nexport function runRepeatableTasks(tasks: RepeatableTaskList): void {\n  for (let i = 0; i < tasks.length; ++i) {\n    if (tasks[i]() === true) {\n      unorderedArrayDeleteByIndex(tasks, i--);\n    }\n  }\n}\n","/**\n * Feature Detection is used to implement polyfills or just disable some features when browser doesn't support them.\n * For example, when browser doesn't support passive events, we can just ignore it and always use active events.\n */\n\n/* istanbul ignore next */\n/**\n * Passive event listeners are a new feature in the DOM spec that enable developers to opt-in to better scroll\n * performance by eliminating the need for scrolling to block on touch and wheel event listeners. Developers can\n * annotate touch and wheel listeners with {passive: true} to indicate that they will never invoke preventDefault.\n *\n * https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nexport const PASSIVE_EVENTS = /*#__PURE__*/((__IVI_TARGET__ === \"electron\") ? true :\n  (() => {\n    let v = false;\n    try {\n      // Test via a getter in the options object to see if the passive property is accessed\n      const opts = Object.defineProperty({}, \"passive\", {\n        get() {\n          v = true;\n        },\n      });\n      window.addEventListener(\"test\", null as any as (ev: Event) => void, opts);\n    } catch (e) {\n      // ignore\n    }\n    return v;\n  })());\n\n/* istanbul ignore next */\n/**\n * `key` property is available on KeyboardEvent instances.\n */\nexport const KEYBOARD_EVENT_KEY = /*#__PURE__*/(\n  (__IVI_TARGET__ === \"electron\") ||\n  (__IVI_TARGET__ === \"evergreen\") ||\n  KeyboardEvent.prototype.hasOwnProperty(\"key\")\n);\n\n/* istanbul ignore next */\n/**\n * `buttons` property is available on MouseEvent instances.\n */\nexport const MOUSE_EVENT_BUTTONS = /*#__PURE__*/(\n  (__IVI_TARGET__ === \"electron\") ||\n  (__IVI_TARGET__ === \"evergreen\") ||\n  MouseEvent.prototype.hasOwnProperty(\"buttons\")\n);\n\n/* istanbul ignore next */\n/**\n * Touch Events support.\n */\nexport const TOUCH_EVENTS = (\"ontouchstart\" in window);\n\n/* istanbul ignore next */\n/**\n * Pointer Events support.\n */\nexport const POINTER_EVENTS = ((__IVI_TARGET__ === \"electron\") || (\"PointerEvent\" in window));\n\n/* istanbul ignore next */\n/**\n * InputDeviceCapabilities support.\n *\n * http://wicg.github.io/InputDeviceCapabilities/\n */\nexport const INPUT_DEVICE_CAPABILITIES = ((__IVI_TARGET__ === \"electron\") || \"InputDeviceCapabilities\" in window);\n\n/* istanbul ignore next */\n/**\n * iOS proprietary GestureEvent.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent}\n */\nexport const IOS_GESTURE_EVENT = (__IVI_TARGET__ !== \"electron\") && (\"GestureEvent\" in window);\n","const nodeProto = Node.prototype;\nconst elementProto = Element.prototype;\n\n/**\n * Shortcut for an `Object.prototype.hasOwnProperty`.\n */\nexport const objectHasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Shortcut for a `Node.prototype.insertBefore`.\n */\nexport const nodeInsertBefore = (\n  __IVI_DEBUG__ ?\n    function <T extends Node>(this: Node, newChild: T, refChild: Node | null): T {\n      return this.insertBefore(newChild, refChild);\n    } :\n    /* istanbul ignore next */nodeProto.insertBefore\n);\n\n/**\n * Shortcut for a `Node.prototype.removeChild`.\n */\nexport const nodeRemoveChild = (\n  __IVI_DEBUG__ ?\n    function <T extends Node>(this: Node, oldChild: T): T {\n      return this.removeChild(oldChild);\n    } :\n    /* istanbul ignore next */nodeProto.removeChild\n);\n\n/**\n * Shortcut for a `Node.prototype.replaceChild`.\n */\nexport const nodeReplaceChild = (\n  __IVI_DEBUG__ ?\n    function <T extends Node>(this: Node, newChild: Node, oldChild: T): T {\n      return this.replaceChild(newChild, oldChild);\n    } :\n    /* istanbul ignore next */nodeProto.replaceChild\n);\n\n/**\n * Shortcut for a `Node.prototype.cloneNode`.\n */\nexport const nodeCloneNode = (\n  __IVI_DEBUG__ ?\n    function (this: Node, deep?: boolean): Node {\n      return this.cloneNode(deep);\n    } :\n    /* istanbul ignore next */nodeProto.cloneNode\n);\n\n/**\n * Shortcut for an `Element.prototype.setAttribute`.\n */\nexport const elementSetAttribute = (\n  __IVI_DEBUG__ ?\n    function (this: Element, qualifiedName: string, value: string): void {\n      this.setAttribute(qualifiedName, value);\n    } :\n    /* istanbul ignore next */elementProto.setAttribute\n);\n\n/**\n * Shortcut for an `Element.prototype.setAttributeNS`.\n */\nexport const elementSetAttributeNS = (\n  __IVI_DEBUG__ ?\n    function (this: Element, namespace: string | null, qualifiedName: string, value: string): void {\n      this.setAttributeNS(namespace, qualifiedName, value);\n    } :\n    /* istanbul ignore next */elementProto.setAttributeNS\n);\n\n/**\n * Shortcut for an `Element.prototype.removeAttribute`.\n */\nexport const elementRemoveAttribute = (\n  __IVI_DEBUG__ ?\n    function (this: Element, qualifiedName: string): void {\n      this.removeAttribute(qualifiedName);\n    } :\n    /* istanbul ignore next */elementProto.removeAttribute\n);\n","export const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nexport const XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\";\nexport const XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n","import { NodeFlags } from \"./node_flags\";\nimport { Op } from \"./operations\";\n\n/**\n * Operation state.\n *\n * @typeparam T Internal state type.\n */\nexport interface OpState<T = any> {\n  /**\n   * Operation.\n   */\n  o: Op;\n  /**\n   * See {@link NodeFlags} for details.\n   */\n  f: NodeFlags;\n  /**\n   * State for children operations.\n   */\n  c: OpState | Array<OpState | null> | null;\n  /**\n   * Current state.\n   */\n  s: T;\n}\n\n/**\n * createStateNode creates a {@link StateNode} instance.\n *\n * @param op Operation.\n * @returns {@link StateNode} instance.\n */\nexport const createStateNode = (o: Op): OpState => (\n  { o, f: 0, c: null, s: null }\n);\n","import { EMPTY_OBJECT } from \"../core\";\n\n/**\n * Current context.\n */\nlet _context = EMPTY_OBJECT;\n\n/**\n * Used for detecting invalid `context()` invocations in DEBUG mode.\n */\nlet _contextEnabled = false;\n\n/**\n * Enable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function enableContext() {\n  _contextEnabled = true;\n}\n\n/**\n * Disable checking for invalid `context()` invocations in DEBUG mode.\n */\nexport function disableContext() {\n  _contextEnabled = false;\n}\n\n/**\n * setContext assigns current context.\n *\n * Should be executed before going deeper into Context node.\n *\n * @param c Current context.\n * @returns previous context\n */\nexport function setContext(c: {}): {} {\n  const tmp = _context;\n  _context = c;\n  return tmp;\n}\n\n/**\n * restoreContext restores previous context.\n *\n * Should be executed after processing Context node.\n *\n * @param c Previous context.\n */\nexport function restoreContext(c: {}): void {\n  _context = c;\n}\n\n/**\n * context retrieves current context.\n *\n * @typeparam Context type.\n * @returns current context\n */\nexport function context<T extends {}>(): T {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (!_contextEnabled) {\n      throw new Error(`Invalid context() invocation. Context can't be used outside of a reconciliation phase`);\n    }\n  }\n  return _context as T;\n}\n","import {\n  objectHasOwnProperty, nodeInsertBefore, nodeRemoveChild, elementSetAttribute, nodeCloneNode, elementRemoveAttribute,\n} from \"../dom/shortcuts\";\nimport { SVG_NAMESPACE } from \"../dom/namespaces\";\nimport { CSSStyleProps } from \"../dom/style\";\nimport { NodeFlags } from \"./node_flags\";\nimport { AttributeDirective } from \"./attribute_directive\";\nimport { OpNode, ElementData, OpArray, Key, OpData, ContextData, Op, EventsData } from \"./operations\";\nimport { OpState, createStateNode } from \"./state\";\nimport { ElementProtoDescriptor } from \"./element_proto\";\nimport { ComponentDescriptor, ComponentHooks, StatelessComponentDescriptor } from \"./component\";\nimport { context, setContext, restoreContext } from \"./context\";\n\nlet _nextNode!: Node | null;\nlet _deepStateFlags!: NodeFlags;\nlet _dirtyContext!: boolean;\n\nexport function _resetState(): void {\n  _nextNode = null;\n  _deepStateFlags = 0;\n  _dirtyContext = false;\n}\n\nfunction _pushDeepState(): NodeFlags {\n  const s = _deepStateFlags;\n  _deepStateFlags = 0;\n  return s;\n}\n\nfunction _popDeepState(prev: NodeFlags, current: NodeFlags): NodeFlags {\n  const r = current | _deepStateFlags;\n  _deepStateFlags |= prev;\n  return r;\n}\n\nexport function visitNodes(\n  currentOpState: OpState,\n  filter: NodeFlags,\n  visitor: (opState: OpState) => void | boolean,\n): boolean {\n  const flags = currentOpState.f;\n  if ((flags & filter) === filter) {\n    if (visitor(currentOpState) === true) {\n      return true;\n    }\n  }\n\n  const children = currentOpState.c;\n  if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n    for (let i = 0; i < (children as Array<OpState | null>).length; i++) {\n      const c = (children as Array<OpState | null>)[i];\n      if (c !== null) {\n        if (visitNodes(c, filter, visitor) === true) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  if (children !== null) {\n    return visitNodes(children as OpState, filter, visitor);\n  }\n  return false;\n}\n\n/**\n * getDOMNode retrieves closest DOM node from the {@link OpState} instance.\n *\n * @param opState State node.\n * @returns DOM node.\n */\nexport function getDOMNode(opState: OpState): Node | null {\n  const flags = opState.f;\n  if ((flags & (NodeFlags.Element | NodeFlags.Text)) === 0) {\n    const children = opState.c;\n    if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (let i = 0; i < (children as Array<OpState | null>).length; i++) {\n        const c = (children as Array<OpState | null>)[i];\n        if (c !== null) {\n          return getDOMNode(c);\n        }\n      }\n      return null;\n    }\n    if (children === null) {\n      return null;\n    }\n    return getDOMNode(children as OpState);\n  }\n  return opState.s as Node;\n}\n\nexport function _dirtyCheck(\n  parentElement: Element,\n  opState: OpState,\n  moveNode: boolean,\n  singleChild: boolean,\n): void {\n  const { f, c } = opState;\n  let state;\n  let deepState;\n  let i;\n\n  if ((f & NodeFlags.Component) !== 0) {\n    state = opState.s as ComponentHooks;\n    deepState = _pushDeepState();\n    if (\n      ((f & NodeFlags.Stateful) !== 0) && (\n        ((f & NodeFlags.Dirty) !== 0) ||\n        (state.s !== null && state.s() === true)\n      )\n    ) {\n      opState.c = _update(\n        parentElement,\n        c as OpState,\n        state.r!((opState.o as OpNode).d),\n        moveNode,\n        singleChild,\n      );\n    } else if ((f & NodeFlags.DeepStateDirtyCheck) !== 0) {\n      _dirtyCheck(parentElement, c as OpState, moveNode, singleChild);\n    } else {\n      if (moveNode === true) {\n        _moveNodes(parentElement, opState);\n      } else {\n        _nextNode = getDOMNode(opState);\n      }\n    }\n    opState.f = (opState.f & NodeFlags.SelfFlags) | _deepStateFlags;\n    _deepStateFlags |= deepState | ((opState.f & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else if ((f & NodeFlags.DeepStateDirtyCheck) !== 0) {\n    deepState = _pushDeepState();\n    if ((f & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n      state = opState.s as Node;\n      if (moveNode === true) {\n        nodeInsertBefore.call(parentElement, state, _nextNode);\n      }\n      if (c !== null) {\n        _dirtyCheck(state as Element, c as OpState, false, true);\n      }\n      _nextNode = state;\n    } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      i = (c as Array<OpState | null>).length;\n      while (--i >= 0) {\n        if ((state = (c as Array<OpState | null>)[i]) !== null) {\n          _dirtyCheck(parentElement, state, moveNode, false);\n        }\n      }\n    } else if ((f & NodeFlags.Events) !== 0) {\n      _dirtyCheck(parentElement, opState.c as OpState, moveNode, singleChild);\n    } else { // Context\n      if (_dirtyContext === true) {\n        opState.s = { ...context(), ...(opState.o as OpNode<ContextData>).d.v };\n      }\n      const prevContext = setContext(opState.s as {});\n      _dirtyCheck(parentElement, opState.c as OpState, moveNode, singleChild);\n      restoreContext(prevContext);\n    }\n    opState.f = _popDeepState(deepState, opState.f);\n  } else {\n    if (moveNode === true) {\n      _moveNodes(parentElement, opState);\n    } else {\n      _nextNode = getDOMNode(opState);\n    }\n  }\n}\n\nfunction _moveNodes(parentElement: Element, opState: OpState) {\n  const flags = opState.f;\n  if ((flags & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    const domNode = opState.s as Node;\n    nodeInsertBefore.call(parentElement, domNode, _nextNode);\n    _nextNode = domNode;\n  } else {\n    const children = opState.c;\n    if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      let i = (children as Array<OpState | null>).length;\n      while (--i >= 0) {\n        const c = (children as Array<OpState | null>)[i];\n        if (c !== null) {\n          _moveNodes(parentElement, c);\n        }\n      }\n    } else if (children !== null) {\n      _moveNodes(parentElement, children as OpState);\n    }\n  }\n}\n\nfunction _unmountWalk(opState: OpState): void {\n  const flags = opState.f;\n  let i;\n  let v;\n\n  if ((flags & NodeFlags.DeepStateUnmount) !== 0) {\n    const children = opState.c;\n    if (children !== null) {\n      if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n        for (i = 0; i < (children as Array<OpState | null>).length; i++) {\n          if ((v = (children as Array<OpState | null>)[i]) !== null) {\n            _unmountWalk(v);\n          }\n        }\n      } else {\n        _unmountWalk(children as OpState);\n      }\n    }\n  }\n\n  if ((flags & NodeFlags.Unmount) !== 0) {\n    v = (opState.s as ComponentHooks).u;\n    if (v !== null) {\n      if (typeof v === \"function\") {\n        v();\n      } else {\n        for (i = 0; i < v.length; i++) {\n          v[i](true);\n        }\n      }\n    }\n  }\n}\n\nfunction _unmountRemove(parentElement: Element, opState: OpState, singleChild: boolean): void {\n  const flags = opState.f;\n\n  if ((flags & (NodeFlags.Element | NodeFlags.Text)) !== 0) {\n    nodeRemoveChild.call(parentElement, opState.s as Node);\n  } else {\n    const children = opState.c;\n    if ((flags & (NodeFlags.TrackByKey | NodeFlags.Fragment)) !== 0) {\n      if (singleChild === true) {\n        parentElement.textContent = \"\";\n      } else {\n        for (let i = 0; i < (children as Array<OpState | null>).length; ++i) {\n          const c = (children as Array<OpState | null>)[i];\n          if (c !== null) {\n            _unmountRemove(parentElement, c, false);\n          }\n        }\n      }\n    } else if (children !== null) {\n      _unmountRemove(parentElement, children as OpState, singleChild);\n    }\n  }\n}\n\nexport function _unmount(parentElement: Element, opState: OpState, singleChild: boolean): void {\n  _unmountRemove(parentElement, opState, singleChild);\n  _unmountWalk(opState);\n}\n\nfunction _mountText(\n  parentElement: Element,\n  opState: OpState,\n  op: string | number,\n) {\n  const node = document.createTextNode(op as string);\n  nodeInsertBefore.call(parentElement, node, _nextNode);\n  _nextNode = node;\n  opState.s = node;\n  opState.f = NodeFlags.Text;\n}\n\nfunction _createElement(node: Element | undefined, op: OpNode<ElementData>): Element {\n  const opType = op.t;\n  const { n, a } = op.d;\n  const svg = (opType.f & NodeFlags.Svg) !== 0;\n  if (node === void 0) {\n    const tagName = opType.d as string;\n    node = svg ?\n      document.createElementNS(SVG_NAMESPACE, tagName) :\n      document.createElement(tagName);\n  }\n\n  if (n) {\n    _updateClassName(node, n, svg);\n  }\n\n  if (a !== void 0) {\n    _updateAttrs(node, void 0, a);\n  }\n\n  return node;\n}\n\nfunction _mountObject(\n  parentElement: Element,\n  opState: OpState,\n  op: OpNode,\n): void {\n  const { t, d } = op;\n  const flags = t.f;\n  let deepStateFlags;\n  let prevState;\n  let value;\n\n  if ((flags & NodeFlags.Component) !== 0) {\n    deepStateFlags = _pushDeepState();\n    if ((flags & NodeFlags.Stateful) !== 0) {\n      opState.s = prevState = { r: null, s: null, u: null } as ComponentHooks;\n      // Reusing value variable.\n      (prevState as ComponentHooks).r = value = (op.t.d as ComponentDescriptor).c(opState);\n    } else {\n      value = (op.t.d as StatelessComponentDescriptor).c;\n    }\n    opState.c = _mount(parentElement, value(d));\n    opState.f = (opState.f & NodeFlags.SelfFlags) | flags | _deepStateFlags;\n    _deepStateFlags |= deepStateFlags | ((opState.f & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n  } else {\n    deepStateFlags = _pushDeepState();\n    if ((flags & NodeFlags.Element) !== 0) {\n      const descriptor = t.d;\n      let node: Element | undefined;\n      if ((flags & NodeFlags.ElementProto) !== 0) {\n        node = (descriptor as ElementProtoDescriptor).n as Element;\n        if (node === null) {\n          (descriptor as ElementProtoDescriptor).n = node = _createElement(\n            void 0,\n            (descriptor as ElementProtoDescriptor).p,\n          );\n        }\n        node = nodeCloneNode.call(node, false) as Element;\n      }\n      opState.s = node = _createElement(node, op);\n\n      prevState = _nextNode;\n      _nextNode = null;\n      value = d.c;\n      if (value !== null) {\n        opState.c = _mount(node, value);\n      }\n      nodeInsertBefore.call(parentElement, node, prevState);\n      _nextNode = node;\n    } else if ((flags & (NodeFlags.Events | NodeFlags.Context)) !== 0) {\n      if ((flags & NodeFlags.Context) !== 0) {\n        prevState = setContext(\n          opState.s = { ...context(), ...(d as OpData<ContextData>).v },\n        );\n        opState.c = _mount(parentElement, (d as OpData<ContextData>).c);\n        restoreContext(prevState);\n      } else {\n        opState.c = _mount(parentElement, (d as OpData<ContextData>).c);\n      }\n    } else { // ((opFlags & NodeFlags.TrackByKey) !== 0)\n      let i = (d as Key<any, OpNode>[]).length;\n      opState.c = value = Array(i);\n      while (--i >= 0) {\n        value[i] = _mount(parentElement, (d as Key<any, OpNode>[])[i].v);\n      }\n    }\n    opState.f = _popDeepState(deepStateFlags, flags);\n  }\n}\n\nfunction _mountFragment(\n  parentElement: Element,\n  opState: OpState,\n  childrenOps: OpArray,\n): void {\n  let i = childrenOps.length;\n  const newChildren = Array(i);\n  const deepStateFlags = _pushDeepState();\n  while (--i >= 0) {\n    newChildren[i] = _mount(parentElement, childrenOps[i]);\n  }\n  opState.c = newChildren;\n  opState.f = _popDeepState(deepStateFlags, NodeFlags.Fragment);\n}\n\nexport function _mount(\n  parentElement: Element,\n  op: Op,\n): OpState | null {\n  if (op !== null) {\n    const stateNode = createStateNode(op);\n    if (typeof op === \"object\") {\n      if (op instanceof Array) {\n        _mountFragment(parentElement, stateNode, op);\n      } else {\n        _mountObject(parentElement, stateNode, op);\n      }\n    } else {\n      _mountText(parentElement, stateNode, op);\n    }\n    return stateNode;\n  }\n  return null;\n}\n\nfunction _hasDifferentType(\n  a: OpNode | OpArray,\n  b: OpNode | OpArray | string | number,\n): boolean {\n  if (typeof b !== \"object\") {\n    return true;\n  }\n  if (a instanceof Array) {\n    return !(b instanceof Array);\n  }\n  return (b instanceof Array || a.t !== b.t);\n}\n\n/**\n * _update updates a stateNode with a next operation.\n *\n * @param parentElement Parent DOM Element.\n * @param opState Operation state.\n * @param nextOp Next operation.\n * @param moveNode DOM Element should be moved.\n * @param singleChild Parent DOM Element contains a single child.\n * @returns OpNode state.\n */\nexport function _update(\n  parentElement: Element,\n  opState: OpState | null,\n  nextOp: Op,\n  moveNode: boolean,\n  singleChild: boolean,\n): OpState | null {\n  if (nextOp === null) {\n    if (opState !== null) {\n      _unmount(parentElement, opState, singleChild);\n    }\n    return null;\n  }\n  if (opState === null) {\n    return _mount(parentElement, nextOp);\n  }\n  const { o, s } = opState;\n  let flags = opState.f;\n\n  if ((flags & NodeFlags.Text) !== 0) {\n    if (typeof nextOp !== \"object\") {\n      // Reassign to reduce memory consumption even if nextOp is strictly equal to the prev op.\n      opState.o = nextOp;\n      if (o !== nextOp) {\n        (s as Node).nodeValue = nextOp as string;\n      }\n      if (moveNode === true) {\n        nodeInsertBefore.call(parentElement, s as Node, _nextNode);\n      }\n      _nextNode = s as Node;\n    } else {\n      nodeRemoveChild.call(parentElement, s as Node);\n      return _mount(parentElement, nextOp);\n    }\n  } else {\n    // Here we don't need to reassign nextOp because op should always be an object, and strict equality will guarantee\n    // that this object is occupying the same memory region.\n    if (o === nextOp) {\n      _dirtyCheck(parentElement, opState, moveNode, singleChild);\n      return opState;\n    }\n    if (_hasDifferentType(o as OpNode | OpArray, nextOp) === true) {\n      _unmount(parentElement, opState, singleChild);\n      return _mount(parentElement, nextOp);\n    }\n    opState.o = nextOp;\n    const opStateChildren = opState.c;\n    let deepStateFlags;\n    let prevData;\n    let nextData;\n    let nextValue;\n\n    if ((flags & NodeFlags.Component) !== 0) {\n      prevData = (o as OpNode).d;\n      nextData = (nextOp as OpNode).d;\n      const descriptor = ((nextOp as OpNode).t.d as StatelessComponentDescriptor | ComponentDescriptor);\n      if (\n        ((flags & NodeFlags.Dirty) !== 0) ||\n        (\n          (prevData !== nextData) &&\n          (descriptor.su === void 0 || descriptor.su(prevData, nextData) === true)\n        )\n      ) {\n        deepStateFlags = _pushDeepState();\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          ((flags & NodeFlags.Stateful) !== 0) ?\n            (opState.s as ComponentHooks).r!(nextData) :\n            (descriptor as StatelessComponentDescriptor).c(nextData),\n          moveNode,\n          singleChild,\n        );\n        // opState.f can be changed after `_update()`.\n        flags = opState.f;\n        opState.f = (flags & NodeFlags.SelfFlags) | _deepStateFlags;\n        _deepStateFlags |= deepStateFlags | ((flags & NodeFlags.DeepStateFlags) << NodeFlags.DeepStateShift);\n      } else {\n        _dirtyCheck(parentElement, opState, moveNode, singleChild);\n      }\n    } else {\n      deepStateFlags = _pushDeepState();\n      if ((flags & NodeFlags.Element) !== 0) {\n        prevData = (o as OpNode<ElementData>).d;\n        nextData = (nextOp as OpNode<ElementData>).d;\n        if (moveNode === true) {\n          nodeInsertBefore.call(parentElement, s, _nextNode);\n        }\n\n        nextValue = nextData.n;\n        if (prevData.n !== nextValue) {\n          if (nextValue === void 0) {\n            nextValue = \"\";\n          }\n          _updateClassName(s, nextValue, (flags & NodeFlags.Svg) !== 0);\n        }\n\n        nextValue = nextData.a;\n        if (prevData.a !== nextValue) {\n          _updateAttrs(s as Element, prevData.a, nextValue);\n        }\n\n        nextValue = nextData.c;\n        if (prevData.c !== nextValue) {\n          _nextNode = null;\n          opState.c = _update(s as Element, opStateChildren as OpState, nextValue, false, true);\n        }\n\n        _nextNode = s as Node;\n      } else if ((flags & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n        if ((flags & NodeFlags.Fragment) !== 0) {\n          let i = (nextOp as OpArray).length;\n          // When there is a different length for statically positioned elements, it is much more likely that internal\n          // elements should have a different internal state, so it is better to destroy previous state and instantiate\n          // a new one. This heuristics is slightly different from React, but it should be better at handling some\n          // use cases.\n          if ((opStateChildren as Array<OpState | null>).length === i) {\n            while (--i >= 0) {\n              (opStateChildren as Array<OpState | null>)[i] =\n                _update(\n                  parentElement,\n                  (opStateChildren as Array<OpState | null>)[i],\n                  (nextOp as OpArray)[i],\n                  moveNode,\n                  false);\n            }\n          } else {\n            _unmount(parentElement, opState, singleChild);\n            _mountFragment(parentElement, opState, nextOp as OpArray);\n          }\n        } else {\n          _updateChildrenTrackByKeys(\n            parentElement,\n            opState,\n            (o as OpNode).d,\n            (nextOp as OpNode).d,\n            moveNode,\n            singleChild,\n          );\n        }\n      } else if ((flags & NodeFlags.Events) !== 0) {\n        opState.c = _update(\n          parentElement,\n          opStateChildren as OpState,\n          (nextOp as OpNode<EventsData>).d.c,\n          moveNode,\n          singleChild,\n        );\n      } else { // if ((stateFlags & NodeFlags.Context) !== 0) {\n        const dirtyContext = _dirtyContext;\n        nextData = (nextOp as OpNode<ContextData>).d;\n        nextValue = nextData.v;\n        if ((o as OpNode<ContextData>).d.v !== nextValue || _dirtyContext === true) {\n          opState.s = { ...context(), ...nextValue };\n          _dirtyContext = true;\n        }\n        // reusing variable name, it is actually a previous value in the context stack.\n        nextValue = setContext(opState.s as {});\n        _update(parentElement, opStateChildren as OpState, nextData.c, moveNode, singleChild);\n        restoreContext(nextValue);\n        _dirtyContext = dirtyContext;\n      }\n      opState.f = _popDeepState(deepStateFlags, opState.f);\n    }\n  }\n\n  return opState;\n}\n\n/**\n * Update children list with track by key algorithm.\n *\n * High-level overview of the algorithm that is implemented in this function (slightly outdated, but the key ideas are\n * the same).\n *\n * This algorithm finds a minimum[1] number of DOM operations. It works in several steps:\n *\n * 1. Find common suffix and prefix.\n *\n * This optimization technique is searching for nodes with identical keys by simultaneously iterating over nodes in the\n * old children list `A` and new children list `B` from both sides:\n *\n *  A: -> [a b c d] <-\n *  B: -> [a b d] <-\n *\n * Here we can skip nodes \"a\" and \"b\" at the begininng, and node \"d\" at the end.\n *\n *  A: -> [c] <-\n *  B: -> [] <-\n *\n * Here it will check if the size of one of the list is equal to zero. When length of the old children list is zero,\n * it will insert all remaining nodes from the new list, and when length of the new children list is zero, it will\n * remove all remaining nodes from the old list.\n *\n * When algorithm can't find a solution with this simple optimization technique, it will go to the next step of the\n * algorithm. For example:\n *\n *  A: -> [a b c d e f g] <-\n *  B: -> [a c b h f e g] <-\n *\n * Nodes \"a\" and \"g\" at the edges are the same, skipping them.\n *\n *  A: -> [b c d e f] <-\n *  B: -> [c b h f e] <-\n *\n * Here we are stuck, so we need to switch to the next step.\n *\n * 2. Look for removed and inserted nodes, and simultaneously check if one of the nodes is moved.\n *\n * First we create an array `P` with the length of the new children list and assign to each position value `-1`, it has\n * a meaning of a new node that should be inserted. Later we will assign node positions in the old children list to this\n * array.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *\n * Then we need to build an index `I` that maps keys with node positions of the remaining nodes from the new children\n * list.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [. . . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 0\n *\n * With this index, we start to iterate over the remaining nodes from the old children list and check if we can find a\n * node with the same key in the index. If we can't find any node, it means that it should be removed, otherwise we\n * assign position of the node in the old children list to the positions array.\n *\n *  A: [b c d e f]\n *      ^\n *  B: [c b h f e]\n *  P: [. 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1, <-\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1\n *\n * When we assigning positions to the positions array, we also keep a position of the last seen node in the new children\n * list, if the last seen position is larger than current position of the node at the new list, then we are switching\n * `moved` flag to `true`.\n *\n *  A: [b c d e f]\n *        ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0, <-\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  last = 1 // last > 0; moved = true\n *\n * The last position `1` is larger than current position of the node at the new list `0`, switching `moved` flag to\n * `true`.\n *\n *  A: [b c d e f]\n *          ^\n *  B: [c b h f e]\n *  P: [1 0 . . .] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4,\n *  }\n *  moved = true\n *\n * Node with key \"d\" doesn't exist in the index, removing node.\n *\n *  A: [b c d e f]\n *            ^\n *  B: [c b h f e]\n *  P: [1 0 . . 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3,\n *    e: 4, <-\n *  }\n *  moved = true\n *\n * Assign position for `e`.\n *\n *  A: [b c d e f]\n *              ^\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  I: {\n *    c: 0,\n *    b: 1,\n *    h: 2,\n *    f: 3, <-\n *    e: 4,\n *  }\n *  moved = true\n *\n * Assign position for 'f'.\n *\n * At this point we are checking if `moved` flag is on, or if the length of the old children list minus the number of\n * removed nodes isn't equal to the length of the new children list. If any of this conditions is true, then we are\n * going to the next step.\n *\n * 3. Find minimum number of moves if `moved` flag is on, or insert new nodes if the length is changed.\n *\n * When `moved` flag is on, we need to find the\n * [longest increasing subsequence](http://en.wikipedia.org/wiki/Longest_increasing_subsequence) in the positions array,\n * and move all nodes that doesn't belong to this subsequence.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *  moved = true\n *\n * Now we just need to simultaneously iterate over the new children list and LIS from the end and check if the current\n * position is equal to a value from LIS.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *              ^  // new_pos == 4\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *              ^  // new_pos == 4\n *  moved = true\n *\n * Node \"e\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *            ^    // new_pos == 3\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos != 1\n *  moved = true\n *\n * Node \"f\" is moved, move it before the next node \"e\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *          ^      // new_pos == 2\n *  P: [1 0 . 4 3] // . == -1\n *          ^      // old_pos == -1\n *  LIS:     [1 4]\n *            ^\n *  moved = true\n *\n * Node \"h\" has a `-1` value in the positions array, insert new node \"h\".\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *        ^        // new_pos == 1\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *            ^    // new_pos == 1\n *  moved = true\n *\n * Node \"b\" stays at the same place.\n *\n *  A: [b c d e f]\n *  B: [c b h f e]\n *      ^          // new_pos == 0\n *  P: [1 0 . 4 3] // . == -1\n *  LIS:     [1 4]\n *          ^      // new_pos != undefined\n *  moved = true\n *\n * Node \"c\" is moved, move it before the next node \"b\".\n *\n * When moved flag is off, we don't need to find LIS, and we just iterate over the new children list and check its\n * current position in the positions array, if it is `-1`, then we insert new node.\n *\n * [1] Actually it is almost minimum number of dom ops, when node is removed and another one is inserted at the same\n * place, instead of insert and remove dom ops, we can use one replace op. It will make everything even more\n * complicated, and other use cases will be slower, so I don't think that it is worth to use replace here.\n *\n * @param parentElement Parent DOM element.\n * @param opState OpNode state for a TrackByKey operation.\n * @param a Previous operations.\n * @param b Next operations.\n * @param moveNode Children DOM nodes should be moved.\n * @param singleChild Parent DOM element contains a single node.\n * @noinline\n */\nfunction _updateChildrenTrackByKeys(\n  parentElement: Element,\n  opState: OpState,\n  a: Key<any, OpNode>[],\n  b: Key<any, OpNode>[],\n  moveNode: boolean,\n  singleChild: boolean,\n): void {\n  let i = b.length;\n  let j: number | undefined = a.length;\n  const result = Array(i);\n\n  if (i === 0) { // New children list is empty.\n    if (j > 0) { // Unmount nodes from the old children list.\n      _unmount(parentElement, opState, singleChild);\n    }\n  } else if (j === 0) { // Old children list is empty.\n    while (--i >= 0) { // Mount nodes from the new children list.\n      result[i] = _mount(parentElement, b[i].v);\n    }\n  } else {\n    const opStateChildren = opState.c as Array<OpState | null>;\n    let aEnd = j - 1; // a.length - 1\n    let bEnd = i - 1; // b.length - 1\n    let start = 0;\n    let node: OpNode | Key<any, OpNode> | OpState | null = b[bEnd];\n\n    // Step 1\n    outer: while (true) {\n      // Update nodes with the same key at the end.\n      while (a[aEnd].k === node.k) {\n        result[bEnd] = _update(parentElement, opStateChildren[aEnd--], node.v, moveNode, false);\n        if (start > --bEnd || start > aEnd) {\n          break outer;\n        }\n        node = b[bEnd];\n      }\n\n      // Update nodes with the same key at the beginning.\n      while (a[start].k === b[start].k) {\n        // delayed update (all updates should be performed from right-to-left).\n        if (++start > aEnd || start > bEnd) {\n          break outer;\n        }\n      }\n\n      break;\n    }\n\n    if (start > aEnd) {\n      // All nodes from `a` are updated, insert the rest from `b`.\n      while (bEnd >= start) {\n        result[bEnd] = _mount(parentElement, b[bEnd--].v);\n      }\n    } else if (start > bEnd) {\n      // All nodes from `b` are updated, remove the rest from `a`.\n      i = start;\n      do {\n        if ((node = opStateChildren[i++]) !== null) {\n          _unmount(parentElement, node, false);\n        }\n      } while (i <= aEnd);\n    } else { // Step 2\n      // When `pos === -1`, it means that one of the nodes is in the wrong position and we should rearrange nodes with\n      // lis-based algorithm.\n      let pos = 0;\n      // Number of updated nodes after prefix/suffix phase. It is used for an optimization that removes all child nodes\n      // with `textContent=\"\"` when there are no updated nodes.\n      let updated = 0;\n\n      const aLength = aEnd - start + 1;\n      const bLength = bEnd - start + 1;\n      const sources = Array(bLength); // Maps positions in the new children list to positions in the old children list.\n      const keyIndex = new Map<any, number>(); // Maps keys to their positions in the new children list.\n      for (i = 0; i < bLength; ++i) {\n        j = i + start;\n        sources[i] = -1; // Special value `-1` indicates that node doesn't exist in the old children list.\n        keyIndex.set(b[j].k, j);\n      }\n\n      for (i = start; i <= aEnd && updated < bLength; ++i) {\n        j = keyIndex.get(a[i].k);\n        if (j !== void 0) {\n          pos = (j < pos) ? j : -1;\n          ++updated;\n          sources[j - start] = i;\n          result[j] = opStateChildren[i];\n          // remove updated nodes from previous array, so that we could remove the rest from the document.\n          opStateChildren[i] = null;\n        }\n      }\n\n      if (aLength === a.length && updated === 0) {\n        // Zero updated nodes in step 1 and 2, remove all nodes and insert new ones.\n        _unmount(parentElement, opState, singleChild);\n        while (bEnd >= 0) {\n          result[bEnd] = _mount(parentElement, b[bEnd--].v);\n        }\n      } else {\n        // Step 3\n        // Remove nodes that weren't updated in the old children list.\n        for (i = start; i <= aEnd; i++) {\n          if ((node = opStateChildren[i]) !== null) {\n            _unmount(parentElement, node, false);\n          }\n        }\n\n        i = bLength;\n        if (moveNode === true || pos !== -1) {\n          while (--i >= 0) {\n            pos = start + i;\n            node = b[pos].v;\n            result[pos] = (sources[i] === -1) ?\n              _mount(parentElement, node) :\n              _update(parentElement, result[pos], node, moveNode, false);\n          }\n        } else {\n          const seq = lis(sources);\n          j = seq.length - 1;\n          while (--i >= 0) {\n            pos = start + i;\n            node = b[pos].v;\n            if (sources[i] === -1) {\n              result[pos] = _mount(parentElement, node);\n            } else {\n              if (j < 0 || i !== seq[j]) {\n                moveNode = true;\n              } else {\n                --j;\n              }\n              result[pos] = _update(parentElement, result[pos], node, moveNode, false);\n              moveNode = false;\n            }\n          }\n        }\n      }\n    }\n\n    // update nodes from Step 1 (prefix only)\n    while (--start >= 0) {\n      result[start] = _update(parentElement, opStateChildren[start], b[start].v, moveNode, false);\n    }\n  }\n  opState.c = result;\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it ignores items that have -1 value, they're representing\n * new items.\n *\n * {@link http://en.wikipedia.org/wiki/Longest_increasing_subsequence}\n *\n * It is possible to use typed arrays in this function, and it will make it faster in most javascript engines, but for\n * some reason instantiating small typed arrays is slower in synthetic microbenchmarks on V8\n * {@link https://gist.github.com/localvoid/88da772d987794605f7fa4a078bce4d6} (maybe there is something wrong in this\n * benchmarks, if someone want to spend more time on optimizations, I'd recommend to double check everything).\n *\n * To solve problem with instantiation, we could just reuse arrays, but in my opinion it isn't worth to overcomplicate\n * this algorithm since it is already extremely fast and it is highly unlikely that it will be even noticeable in the\n * profiler. Usually when there is an update in the real applications, it triggers reordering of one dynamic children\n * list, that is why I prefer to keep it simple.\n *\n * @param a - Array of numbers\n * @returns Longest increasing subsequence\n * @noinline\n */\nfunction lis(a: number[]): number[] {\n  const p = a.slice();\n  // result is instantiated as an empty array to prevent instantiation with CoW backing store.\n  const result: number[] = [];\n  let n = 0;\n  let i = 0;\n  let u: number;\n  let v: number;\n  let j: number;\n\n  result[0] = 0;\n  for (; i < a.length; ++i) {\n    const k = a[i];\n    if (k > -1) {\n      j = result[n];\n      if (a[j] < k) {\n        p[i] = j;\n        result[++n] = i;\n      } else {\n        u = 0;\n        v = n;\n\n        while (u < v) {\n          j = (u + v) >> 1;\n          if (a[result[j]] < k) {\n            u = j + 1;\n          } else {\n            v = j;\n          }\n        }\n\n        if (k < a[result[u]]) {\n          if (u > 0) {\n            p[i] = result[u - 1];\n          }\n          result[u] = i;\n        }\n      }\n    }\n  }\n\n  v = result[n];\n\n  while (n >= 0) {\n    result[n--] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Update DOM classname.\n *\n * @param element DOM Element.\n * @param className Class name.\n * @param svg SVG Element.\n */\nfunction _updateClassName(element: Element, className: string, svg: boolean): void {\n  /**\n   * SVGElement.className returns `SVGAnimatedString`.\n   *\n   * #quirks\n   */\n  if (svg === true) {\n    elementSetAttribute.call(element, \"class\", className);\n  } else {\n    (element as HTMLElement).className = className;\n  }\n}\n\n/**\n * Update DOM styles.\n *\n * @param element HTML or SVG Element.\n * @param a Prev styles.\n * @param b Next styles.\n */\nfunction _updateStyle(\n  element: HTMLElement | SVGElement,\n  a: CSSStyleProps | undefined,\n  b: CSSStyleProps | undefined,\n): void {\n  const style = element.style;\n  let key: string;\n  let bValue;\n\n  if (a === void 0) {\n    // a is empty, insert all styles from b.\n    for (key in b!) {\n      bValue = (b as { [key: string]: string })[key];\n      if (bValue !== void 0) {\n        style.setProperty(key, bValue);\n      }\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all styles from a\n    for (key in a) {\n      style.removeProperty(key);\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      const aValue = a[key];\n      bValue = (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0;\n      if (aValue !== bValue) {\n        if (bValue !== void 0) {\n          style.setProperty(key, bValue);\n        } else {\n          style.removeProperty(key);\n        }\n      }\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        style.setProperty(key, b[key]);\n        ++matchCount;\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attributes.\n *\n * @param element DOM element.\n * @param a Prev DOM attributes.\n * @param b Next DOM attributes.\n */\nfunction _updateAttrs(\n  element: Element,\n  a: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n  b: { [key: string]: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined } | undefined,\n): void {\n  let key: string;\n\n  if (a === void 0) {\n    // a is empty, insert all attributes from b.\n    for (key in b!) {\n      _updateAttr(element, key, void 0, b![key]);\n    }\n  } else if (b === void 0) {\n    // b is empty, remove all attributes from a.\n    for (key in a) {\n      _updateAttr(element, key, a[key], void 0);\n    }\n  } else {\n    let matchCount = 0;\n    let i = 0;\n    for (key in a) {\n      _updateAttr(\n        element,\n        key,\n        a[key],\n        (objectHasOwnProperty.call(b, key) === true) ? (matchCount++ , b[key]) : void 0,\n      );\n    }\n\n    const keys = Object.keys(b);\n    for (; matchCount < keys.length && i < keys.length; ++i) {\n      key = keys[i];\n      if (objectHasOwnProperty.call(a, key) === false) {\n        _updateAttr(element, key, void 0, b[key]);\n        ++matchCount;\n      }\n    }\n  }\n}\n\n/**\n * Update DOM attribute.\n *\n * @param element DOM Element.\n * @param key Attribute name.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction _updateAttr(\n  element: Element,\n  key: string,\n  prev: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n  next: string | number | boolean | AttributeDirective<any> | CSSStyleProps | undefined,\n): void {\n  if (key !== \"style\") {\n    if (typeof next === \"object\") {\n      next.u(\n        element,\n        key,\n        prev === void 0 ? void 0 : (prev as AttributeDirective<any>).v,\n        next.v,\n      );\n    } else if (prev !== next) {\n      if (typeof prev === \"object\") {\n        prev.u(\n          element,\n          key,\n          (prev as AttributeDirective<any>).v,\n          void 0,\n        );\n      } else {\n        if (typeof next === \"boolean\") {\n          next = next ? \"\" : void 0;\n        }\n        if (next === void 0) {\n          elementRemoveAttribute.call(element, key);\n        } else {\n          elementSetAttribute.call(element, key, next as string);\n        }\n      }\n    }\n  } else if (prev !== next) {\n    _updateStyle(element as HTMLElement, prev as CSSStyleProps, next as CSSStyleProps);\n  }\n}\n","/**\n * Empty object.\n */\nexport const EMPTY_OBJECT = /* istanbul ignore else */__IVI_DEBUG__ ? Object.freeze({}) : {};\n","import { checkNestingViolations } from \"../debug/html_nesting_rules\";\nimport { Op } from \"./operations\";\nimport { OpState } from \"./state\";\nimport { _mount, _update, _unmount, _dirtyCheck, _resetState } from \"./reconciler\";\nimport { enableContext, disableContext } from \"./context\";\n\n/**\n * Root.\n */\nexport interface Root {\n  /**\n   * Container element.\n   */\n  container: Element | null;\n  /**\n   * Current state.\n   */\n  state: OpState | null;\n  /**\n   * Next operation.\n   */\n  next: Op | undefined;\n}\n\n/**\n * Root nodes.\n */\nexport const ROOTS = [] as Root[];\n\n/**\n * Find root node of a container.\n *\n * @param predicate - Find predicate.\n * @returns root node or undefined when root node doesn't exist.\n */\nexport const findRoot = (predicate: (root: Root) => boolean) => ROOTS.find(predicate);\n\n/**\n * Performs a dirty checking.\n */\nexport function dirtyCheck() {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    enableContext();\n  }\n  for (let i = 0; i < ROOTS.length; ++i) {\n    const root = ROOTS[i];\n    const { container, state, next } = root;\n    _resetState();\n    if (next !== void 0) {\n      root.next = void 0;\n      root.state = _update(container!, state, next, false, true);\n    } else if (state !== null) {\n      _dirtyCheck(container!, state, false, true);\n    }\n\n    /* istanbul ignore else */\n    if (__IVI_DEBUG__) {\n      if (root.state) {\n        checkNestingViolations(container!, root.state);\n      }\n    }\n  }\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    disableContext();\n  }\n}\n","import { sMT, rAF } from \"ivi-scheduler\";\nimport { NOOP, catchError, runRepeatableTasks, RepeatableTaskList } from \"../core\";\nimport { printWarn } from \"../debug/print\";\nimport { IOS_GESTURE_EVENT } from \"../dom/feature_detection\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { Op } from \"../vdom/operations\";\nimport { Component } from \"../vdom/component\";\nimport { ROOTS, findRoot, dirtyCheck } from \"../vdom/root\";\n\n/**\n * Update flags.\n */\nexport const enum UpdateFlags {\n  /**\n   * Forces synchronous update.\n   */\n  RequestSyncUpdate = 1,\n}\n\n/**\n * Scheduler flags.\n */\nconst enum SchedulerFlags {\n  /**\n   * Running inside of a scheduler context.\n   */\n  Running = 1,\n  /**\n   * Scheduler tick is pending for an execution.\n   */\n  TickPending = 1 << 1,\n  /**\n   * Frame update is pending for an execution.\n   */\n  NextFramePending = 1 << 2,\n  /**\n   * Sync Frame update is pending for an execution.\n   */\n  NextSyncFramePending = 1 << 3,\n  /**\n   * Running inside of a frame update context.\n   */\n  UpdatingFrame = 1 << 4,\n  /**\n   * Dirty checking is pending for an execution.\n   */\n  DirtyCheckPending = 1 << 5,\n}\n\nconst enum SchedulerDebugFlags {\n  DirtyCheckingFinished = 1,\n  MutationsFinished = 1 << 1,\n  LayoutFinished = 1 << 2,\n}\n\n/**\n * Task list.\n */\ninterface TaskList { v: Array<() => void>; }\n\n/**\n * createTaskList creates a task list.\n *\n * @returns task list\n */\nconst createTaskList = () => ({ v: [] }) as TaskList;\n\n/**\n * Execute tasks from the `TaskList`.\n *\n * @param t - Task list\n */\nfunction run(t: TaskList) {\n  while (t.v.length > 0) {\n    const tasks = t.v;\n    let i = 0;\n    t.v = [];\n    do {\n      tasks[i++]();\n    } while (i < tasks.length);\n  }\n}\n\nlet _flags: SchedulerFlags = 0;\nlet _debugFlags: SchedulerDebugFlags;\n/* istanbul ignore else */\nif (__IVI_DEBUG__) {\n  _debugFlags = 0;\n}\nlet _clock = 1;\nconst _microtasks = createTaskList();\nconst _mutationEffects = createTaskList();\nconst _domLayoutEffects = createTaskList();\nconst _beforeMutations = [] as RepeatableTaskList;\nconst _afterMutations = [] as RepeatableTaskList;\nlet _frameStartTime = 0;\n\n/**\n * withSchedulerTick wraps `inner` function into a scheduler context execution.\n *\n * @typeparam T Arguments.\n * @param inner Inner function.\n * @returns function that will be executed in a scheduler context.\n */\nexport const withSchedulerTick = <T extends any[]>(inner: (...args: T) => void) => (\n  catchError(function () {\n    _flags |= SchedulerFlags.Running;\n    inner.apply(void 0, arguments as unknown as T);\n    run(_microtasks);\n    _flags &= ~(SchedulerFlags.Running | SchedulerFlags.TickPending);\n    ++_clock;\n  })\n) as (...args: T) => void;\n\nconst runMicrotasks = withSchedulerTick(NOOP);\n\n/**\n * clock returns monotonically increasing clock value.\n *\n * @returns current clock value.\n */\nexport const clock = () => _clock;\n\n/**\n * scheduleMicrotask adds task to the microtask queue.\n *\n * @param task Microtask.\n */\nexport function scheduleMicrotask(task: () => void): void {\n  _microtasks.v.push(task);\n  if ((_flags & (SchedulerFlags.Running | SchedulerFlags.TickPending)) === 0) {\n    _flags |= SchedulerFlags.TickPending;\n    sMT(runMicrotasks);\n  }\n}\n\n/**\n * beforeMutations adds a hook that will be executed before DOM mutations.\n *\n * @param fn Hook function.\n */\nexport function beforeMutations(fn: () => boolean | void): void {\n  _beforeMutations.push(fn);\n}\n\n/**\n * afterMutations adds a hook that will be executed after DOM mutations.\n *\n * @param fn Hook function.\n */\nexport function afterMutations(fn: () => boolean | void): void {\n  _afterMutations.push(fn);\n}\n\n/**\n * frameStartTime returns current frame start time.\n *\n * @returns current frame start time.\n */\nexport const frameStartTime = () => _frameStartTime;\n\n/**\n * withNextFrame wraps `inner` function into a scheduler frame update context.\n *\n * @param inner Inner function.\n * @returns function that will be executed in a frame update context.\n */\nexport const withNextFrame = (inner: (time?: number) => void) => (\n  withSchedulerTick((time?: number) => {\n    _flags |= SchedulerFlags.UpdatingFrame;\n    inner(time);\n\n    if ((_flags & SchedulerFlags.NextFramePending) !== 0) {\n      _frameStartTime = time === void 0 ? performance.now() : time;\n\n      runRepeatableTasks(_beforeMutations);\n      if ((_flags & SchedulerFlags.DirtyCheckPending) !== 0) {\n        dirtyCheck();\n      }\n      /* istanbul ignore else */\n      if (__IVI_DEBUG__) {\n        _debugFlags |= SchedulerDebugFlags.DirtyCheckingFinished;\n      }\n      run(_mutationEffects);\n      /* istanbul ignore else */\n      if (__IVI_DEBUG__) {\n        _debugFlags |= SchedulerDebugFlags.MutationsFinished;\n      }\n      runRepeatableTasks(_afterMutations);\n      run(_domLayoutEffects);\n      /* istanbul ignore else */\n      if (__IVI_DEBUG__) {\n        _debugFlags |= SchedulerDebugFlags.LayoutFinished;\n      }\n    }\n    _flags &= ~(\n      SchedulerFlags.UpdatingFrame |\n      SchedulerFlags.NextFramePending |\n      SchedulerFlags.NextSyncFramePending |\n      SchedulerFlags.DirtyCheckPending\n    );\n    /* istanbul ignore else */\n    if (__IVI_DEBUG__) {\n      _debugFlags &= ~(\n        SchedulerDebugFlags.DirtyCheckingFinished |\n        SchedulerDebugFlags.MutationsFinished |\n        SchedulerDebugFlags.LayoutFinished\n      );\n    }\n  })\n);\n\n/**\n * Frame tasks scheduler event handler.\n *\n * @param t Current time.\n */\nconst _handleNextFrame = withNextFrame(NOOP);\n\n/**\n * requestNextFrame requests an update for next frame.\n *\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function requestNextFrame(flags?: UpdateFlags): void {\n  if (\n    (flags !== void 0) &&\n    ((flags & UpdateFlags.RequestSyncUpdate) !== 0) &&\n    ((_flags & SchedulerFlags.NextSyncFramePending) === 0)\n  ) {\n    _flags |= SchedulerFlags.NextFramePending | SchedulerFlags.NextSyncFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      scheduleMicrotask(_handleNextFrame);\n    }\n  } else if ((_flags & SchedulerFlags.NextFramePending) === 0) {\n    _flags |= SchedulerFlags.NextFramePending;\n    if ((_flags & SchedulerFlags.UpdatingFrame) === 0) {\n      rAF(_handleNextFrame);\n    }\n  }\n}\n\n/**\n * Adds a write DOM task to the queue.\n *\n * @param fn Write DOM task.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function scheduleMutationEffect(fn: () => void, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Mutation effect is scheduled after mutations were finished\");\n      }\n    }\n  }\n  _mutationEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Adds a DOM layout task to the queue.\n *\n * @param fn Read DOM task\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function scheduleLayoutEffect(fn: () => void, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Layout effect is scheduled after layout were finished\");\n      }\n    }\n  }\n  _domLayoutEffects.v.push(fn);\n  requestNextFrame(flags);\n}\n\n/**\n * Request dirty checking.\n *\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function requestDirtyCheck(flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (_flags & SchedulerFlags.UpdatingFrame) {\n      if (_debugFlags & SchedulerDebugFlags.MutationsFinished) {\n        printWarn(\"Dirty checking is scheduled after dirty checking were finished\");\n      }\n    }\n  }\n  _flags |= SchedulerFlags.DirtyCheckPending;\n  requestNextFrame(flags);\n}\n\n/**\n * Invalidate component.\n *\n * @param c Component instance.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function invalidate(c: Component, flags?: UpdateFlags): void {\n  c.f |= NodeFlags.Dirty;\n  requestDirtyCheck(flags);\n}\n\n/**\n * dirty requests a dirty checking and returns current monotonic clock value.\n *\n * @param flags See {@link UpdateFlags} for details.\n * @returns current monotonic clock value.\n */\nexport const dirty = (flags?: UpdateFlags) => (requestDirtyCheck(flags), _clock);\n\n/**\n * Render operation into the container.\n *\n * @param next Operation to render.\n * @param container DOM Node that will contain rendered operation.\n * @param flags See {@link UpdateFlags} for details.\n */\nexport function render(next: Op, container: Element, flags?: UpdateFlags): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    /**\n     * Rendering into the <body> element is disabled to make it possible to fix iOS quirk with click events.\n     */\n    if (container === document.body) {\n      throw new Error(\"Rendering into the <body> element aren't allowed\");\n    }\n    if (!document.body.contains(container)) {\n      throw new Error(\"Container element should be attached to the document\");\n    }\n  }\n\n  const root = findRoot((v) => v.container === container);\n  if (root) {\n    root.next = next;\n  } else {\n    ROOTS.push({ container, state: null, next });\n    /* istanbul ignore if */\n    /**\n     * Fix for the Mouse Event bubbling on iOS devices.\n     *\n     * #quirks\n     *\n     * http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n     *\n     * Fixed in Safari TP71: https://trac.webkit.org/changeset/237978/webkit/\n     */\n    if (__IVI_TARGET__ === \"browser\" && IOS_GESTURE_EVENT) {\n      (container as HTMLElement).onclick = NOOP;\n    }\n  }\n\n  requestDirtyCheck(flags);\n}\n","import { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandlerNode, EventHandler } from \"./event_handler\";\nimport { NodeFlags } from \"../vdom/node_flags\";\nimport { OpState } from \"../vdom/state\";\nimport { findRoot } from \"../vdom/root\";\nimport { OpNode, EventsData } from \"../vdom/operations\";\n\n/**\n * accumulateDispatchTargets traverses the DOM tree from the `target` Element to the document top, then goes down\n * through Virtual DOM tree and accumulates matching Event Handlers in `result` array.\n *\n * @param result Accumulated Dispatch Targets.\n * @param target Target DOM Element.\n * @param match Matching function.\n */\nexport function accumulateDispatchTargets(\n  result: DispatchTarget[],\n  target: Element,\n  match: (h: EventHandlerNode) => boolean,\n): void {\n  const root = findRoot((r) => r.container!.contains(target));\n  if (root) {\n    const container = root.container;\n    if (container !== target) {\n      visitUp(result, match, target, container!, root.state);\n    }\n  }\n}\n\nfunction visitUp(\n  result: DispatchTarget[],\n  match: (h: EventHandlerNode) => boolean,\n  element: Element,\n  root: Element,\n  stateNode: OpState | null,\n): OpState | null {\n  const parentElement = element.parentNode! as Element;\n  return (parentElement === root || (stateNode = visitUp(result, match, parentElement, root, stateNode)) !== null) ?\n    visitDown(result, match, element, stateNode!) :\n    null;\n}\n\nfunction visitDown(\n  result: DispatchTarget[],\n  match: (h: EventHandlerNode) => boolean,\n  element: Element,\n  stateNode: OpState | null,\n): OpState | null {\n  if (stateNode !== null) {\n    const { f, c } = stateNode;\n    let r;\n    if ((f & NodeFlags.Element) !== 0) {\n      if (stateNode.s === element) {\n        return stateNode;\n      }\n      if (c !== null) {\n        return visitDown(result, match, element, c as OpState);\n      }\n    } else if ((f & (NodeFlags.Events | NodeFlags.Component | NodeFlags.Context)) !== 0) {\n      if ((r = visitDown(result, match, element, stateNode.c as OpState)) !== null) {\n        if ((f & NodeFlags.Events) !== 0) {\n          accumulateDispatchTargetsFromEventsOpNode(result, stateNode, (stateNode.o as OpNode<EventsData>).d.v, match);\n        }\n        return r;\n      }\n    } else if ((f & (NodeFlags.Fragment | NodeFlags.TrackByKey)) !== 0) {\n      for (let i = 0; i < (c as OpState[]).length; i++) {\n        if ((r = visitDown(result, match, element, (c as OpState[])[i])) !== null) {\n          return r;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * accumulateDispatchTargetsFromElement accumulates matching Event Handlers in `result` array from the `target`\n * operation state.\n *\n * @param result Accumulated Dispatch Targets.\n * @param t Target operation state.\n * @param h Event handler.\n * @param match Matching function.\n */\nfunction accumulateDispatchTargetsFromEventsOpNode(\n  result: DispatchTarget[],\n  t: OpState,\n  h: EventHandler,\n  match: (h: EventHandlerNode) => boolean,\n): void {\n  if (h !== null) {\n    if (h instanceof Array) {\n      for (let i = 0; i < h.length; ++i) {\n        accumulateDispatchTargetsFromEventsOpNode(result, t, h[i], match);\n      }\n    } else if (match(h) === true) {\n      result.push({ t, h });\n    }\n  }\n}\n","import { OpState } from \"../vdom/state\";\nimport { EventFlags, SyntheticEventFlags } from \"./flags\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { EventHandlerFlags, EventHandlerNode } from \"./event_handler\";\nimport { SyntheticEvent } from \"./synthetic_event\";\n\n/**\n * dispatchEvent dispatches event to the list of dispatch targets.\n *\n * Simplified version of w3 Events flow algorithm. This algorithm doesn't include target phase, only capture and\n * bubbling phases. We don't care too much about w3 events compatibility, and there aren't any use cases that require\n * target phase.\n *\n * https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\n *\n * @param targets Dispatch targets.\n * @param event Event to dispatch.\n * @param bubble Use bubbling phase.\n * @param dispatch Dispatch callback.\n */\nexport function dispatchEvent(\n  targets: DispatchTarget[],\n  event: SyntheticEvent,\n  bubble: boolean,\n  dispatch?: (h: EventHandlerNode, ev: SyntheticEvent) => EventFlags | void,\n): void {\n  let i = targets.length;\n\n  // capture phase\n  while (--i >= 0) {\n    dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Capture, dispatch);\n    if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n      return;\n    }\n  }\n\n  // bubble phase\n  if (bubble) {\n    while (++i < targets.length) {\n      dispatchEventToLocalEventHandlers(targets[i], event, EventHandlerFlags.Bubble, dispatch);\n      if (event.flags & SyntheticEventFlags.StoppedPropagation) {\n        return;\n      }\n    }\n  }\n}\n\n/**\n * dispatchEventToLocalEventHandlers dispatches event to local(at the same DOM Node) event handlers.\n *\n * @param target Dispatch Target.\n * @param event Synthetic Event.\n * @param matchFlags Flags that should match to deliver event.\n * @param dispatch Dispatch callback.\n */\nfunction dispatchEventToLocalEventHandlers(\n  target: DispatchTarget,\n  event: SyntheticEvent,\n  matchFlags: EventHandlerFlags,\n  dispatch: ((h: EventHandlerNode, ev: SyntheticEvent) => EventFlags | void) | undefined,\n): void {\n  const handlers = target.h;\n  if ((handlers.d.flags & matchFlags) === matchFlags) {\n    event.node = target.t as OpState;\n    event.flags |= _dispatch(handlers, dispatch, event);\n  }\n}\n\nfunction _dispatch(\n  handler: EventHandlerNode,\n  dispatch: ((h: EventHandlerNode, ev: SyntheticEvent) => EventFlags | void) | undefined,\n  event: SyntheticEvent,\n): EventFlags {\n  const flags = (dispatch === void 0) ? handler.h(event) : dispatch(handler, event);\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (flags !== void 0) {\n      if (flags & ~(EventFlags.PreventDefault | EventFlags.StopPropagation)) {\n        throw new Error(`Invalid event flags: ${flags}`);\n      }\n    }\n  }\n  return (flags === void 0) ? 0 : flags;\n}\n","import { SyntheticEventFlags } from \"./flags\";\nimport { SyntheticEvent } from \"./synthetic_event\";\nimport { OpState } from \"../vdom/state\";\n\n/**\n * SyntheticNativeEvent is a wrapper for native events.\n *\n * @typeparam E Native event type.\n */\nexport interface SyntheticNativeEvent<E extends Event> extends SyntheticEvent {\n  readonly native: E;\n}\n\n/**\n * createNativeEvent creates a wrapper for a native event.\n *\n * @typeparam E Native event type.\n */\nexport function createNativeEvent<E extends Event>(\n  flags: SyntheticEventFlags,\n  timestamp: number,\n  node: OpState | null,\n  native: E,\n): SyntheticNativeEvent<E> {\n  return { flags, timestamp, node, native };\n}\n","import { append, unorderedArrayDelete } from \"../core\";\nimport { withSchedulerTick } from \"../scheduler\";\nimport { SyntheticEventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventHandlerNode } from \"./event_handler\";\nimport { DispatchTarget } from \"./dispatch_target\";\nimport { accumulateDispatchTargets } from \"./accumulate_dispatch_targets\";\nimport { dispatchEvent } from \"./dispatch_event\";\nimport { SyntheticNativeEvent, createNativeEvent } from \"./synthetic_native_event\";\n\n/**\n * NativeEventSource dispatches native events.\n *\n * It is using two-phase dispatching algorithm similar to native DOM events flow.\n *\n * @typeparam E Native event type.\n */\nexport interface NativeEventDispatcher<E extends Event> {\n  /**\n   * Hooks that will be executed after dispatching an event.\n   */\n  a: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n  /**\n   * Hooks that will be executed before dispatching an event.\n   */\n  b: Array<(ev: SyntheticNativeEvent<E>) => void> | null;\n}\n\n/**\n * Creates a native event dispatcher.\n *\n * @typeparam E Native event type.\n * @param flags See {@link NativeEventSourceFlags} for details.\n * @param name Event name\n * @param options Event handler options\n * @returns {@link NativeEventDispatcher} instance\n */\nexport function createNativeEventDispatcher<E extends Event>(\n  flags: NativeEventSourceFlags,\n  name: string,\n  options: { capture?: boolean, passive?: boolean } | boolean = true,\n): NativeEventDispatcher<E> {\n  const source: NativeEventDispatcher<E> = { a: null, b: null };\n  const matchEventSource = (h: EventHandlerNode) => h.d.src === source;\n\n  document.addEventListener(name, withSchedulerTick((ev: Event): void => {\n    const target = ev.target as Element;\n    const targets: DispatchTarget[] = [];\n\n    accumulateDispatchTargets(targets, target, matchEventSource);\n\n    if (targets.length || source.b || source.a) {\n      const syntheticEvent = createNativeEvent(0, ev.timeStamp, null, ev as E);\n\n      dispatchToListeners(source.b, syntheticEvent);\n      if (targets.length) {\n        dispatchEvent(targets, syntheticEvent, (flags & NativeEventSourceFlags.Bubbles) !== 0);\n      }\n      dispatchToListeners(source.a, syntheticEvent);\n\n      if (syntheticEvent.flags & SyntheticEventFlags.PreventedDefault) {\n        ev.preventDefault();\n      }\n    }\n  }), options);\n\n  return source;\n}\n\n/**\n * beforeNativeEvent attaches a hook that will be executed before dispatching an event.\n *\n * @typeparam E Native event type.\n * @param source Event dispatcher source.\n * @param cb Hook.\n */\nexport function beforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.b = append(source.b, cb);\n}\n\n/**\n * afterNativeEvent attaches a hook that will be executed after dispatching an event.\n *\n * @typeparam E Native event type.\n * @param source Event dispatcher source.\n * @param cb Hook.\n */\nexport function afterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  source.a = append(source.a, cb);\n}\n\n/**\n * removeBeforeNativeEvent removes a hook that is executed before dispatching an event.\n *\n * @typeparam E Native event type.\n * @param source Event dispatcher source.\n * @param cb Hook.\n */\nexport function removeBeforeNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (source.b === null) {\n      throw new Error(\"removeBeforeNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.b!, cb);\n}\n\n/**\n * removeAfterNativeEvent removes a hook that is executed after dispatching an event.\n *\n * @typeparam E Native event type.\n * @param source Event dispatcher source.\n * @param cb Hook\n */\nexport function removeAfterNativeEvent<E extends Event>(\n  source: NativeEventDispatcher<E>,\n  cb: (e: SyntheticNativeEvent<E>) => void,\n): void {\n  /* istanbul ignore else */\n  if (__IVI_DEBUG__) {\n    if (source.a === null) {\n      throw new Error(\"removeAfterNativeEvent() failed, unable to find registered callback\");\n    }\n  }\n  unorderedArrayDelete(source.a!, cb);\n}\n\nfunction dispatchToListeners<E extends Event>(\n  listeners: Array<(ev: SyntheticNativeEvent<E>) => void> | null,\n  ev: SyntheticNativeEvent<E>,\n): void {\n  if (listeners !== null) {\n    ev.node = null;\n    const cbs = listeners.slice();\n    for (let i = 0; i < cbs.length; i++) {\n      cbs[i](ev);\n    }\n  }\n}\n","/**\n * Event Handlers.\n *\n * Optimizing compilers should inline all this functions and completely remove unused code.\n */\n\nimport { EventFlags, NativeEventSourceFlags } from \"./flags\";\nimport { EventHandlerNode, EventHandlerFlags } from \"./event_handler\";\nimport { NativeEventDispatcher, createNativeEventDispatcher } from \"./native_event_dispatcher\";\nimport { SyntheticNativeEvent } from \"./synthetic_native_event\";\nimport { EVENT_CAPTURE_ACTIVE_OPTIONS } from \"./utils\";\n\n/* tslint:disable:max-line-length */\nexport const EVENT_DISPATCHER_ABORT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"abort\") as NativeEventDispatcher<UIEvent>;\nexport const EVENT_DISPATCHER_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"activate\");\nexport const EVENT_DISPATCHER_ARIA_REQUEST = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"ariarequest\");\nexport const EVENT_DISPATCHER_BEFORE_ACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture, \"beforecopy\");\nexport const EVENT_DISPATCHER_BEFORE_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforecut\");\nexport const EVENT_DISPATCHER_BEFORE_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforedeactivate\");\nexport const EVENT_DISPATCHER_BEFORE_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"beforepaste\");\nexport const EVENT_DISPATCHER_BLUR = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"blur\");\nexport const EVENT_DISPATCHER_CAN_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplay\");\nexport const EVENT_DISPATCHER_CAN_PLAYTHROUGH = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"canplaythrough\");\nexport const EVENT_DISPATCHER_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"change\");\nexport const EVENT_DISPATCHER_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"click\");\nexport const EVENT_DISPATCHER_CONTEXT_MENU = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"contextmenu\");\nexport const EVENT_DISPATCHER_COPY = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"copy\");\nexport const EVENT_DISPATCHER_CUE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"cuechange\");\nexport const EVENT_DISPATCHER_CUT = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"cut\");\nexport const EVENT_DISPATCHER_DOUBLE_CLICK = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dblclick\");\nexport const EVENT_DISPATCHER_DEACTIVATE = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"deactivate\");\nexport const EVENT_DISPATCHER_DRAG = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drag\");\nexport const EVENT_DISPATCHER_DRAG_END = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragend\");\nexport const EVENT_DISPATCHER_DRAG_ENTER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragenter\");\nexport const EVENT_DISPATCHER_DRAG_LEAVE = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragleave\");\nexport const EVENT_DISPATCHER_DRAG_OVER = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragover\");\nexport const EVENT_DISPATCHER_DRAG_START = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"dragstart\");\nexport const EVENT_DISPATCHER_DROP = /*#__PURE__*/createNativeEventDispatcher<DragEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"drop\");\nexport const EVENT_DISPATCHER_DURATION_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"durationchange\");\nexport const EVENT_DISPATCHER_EMPTIED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"emptied\");\nexport const EVENT_DISPATCHER_ENCRYPTED = /*#__PURE__*/createNativeEventDispatcher<MediaEncryptedEvent>(NativeEventSourceFlags.Capture, \"encrypted\");\nexport const EVENT_DISPATCHER_ENDED = /*#__PURE__*/createNativeEventDispatcher<MediaStreamErrorEvent>(NativeEventSourceFlags.Capture, \"ended\");\nexport const EVENT_DISPATCHER_ERROR = /*#__PURE__*/createNativeEventDispatcher<ErrorEvent>(NativeEventSourceFlags.Capture, \"error\");\nexport const EVENT_DISPATCHER_FOCUS = /*#__PURE__*/createNativeEventDispatcher<FocusEvent>(NativeEventSourceFlags.Capture, \"focus\");\nexport const EVENT_DISPATCHER_GOT_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"gotpointercapture\");\nexport const EVENT_DISPATCHER_INPUT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"input\");\nexport const EVENT_DISPATCHER_INVALID = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"invalid\");\nexport const EVENT_DISPATCHER_KEY_DOWN = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keydown\");\nexport const EVENT_DISPATCHER_KEY_PRESS = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keypress\");\nexport const EVENT_DISPATCHER_KEY_UP = /*#__PURE__*/createNativeEventDispatcher<KeyboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"keyup\");\nexport const EVENT_DISPATCHER_LOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"load\");\nexport const EVENT_DISPATCHER_LOADED_DATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadeddata\");\nexport const EVENT_DISPATCHER_LOADED_METADATA = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadedmetadata\");\nexport const EVENT_DISPATCHER_LOAD_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"loadstart\");\nexport const EVENT_DISPATCHER_LOST_POINTER_CAPTURE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture, \"lostpointercapture\");\nexport const EVENT_DISPATCHER_MOUSE_DOWN = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousedown\");\nexport const EVENT_DISPATCHER_MOUSE_MOVE = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mousemove\");\nexport const EVENT_DISPATCHER_MOUSE_OUT = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseout\");\nexport const EVENT_DISPATCHER_MOUSE_OVER = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseover\");\nexport const EVENT_DISPATCHER_MOUSE_UP = /*#__PURE__*/createNativeEventDispatcher<MouseEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"mouseup\");\nexport const EVENT_DISPATCHER_PASTE = /*#__PURE__*/createNativeEventDispatcher<ClipboardEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"paste\");\nexport const EVENT_DISPATCHER_PAUSE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"pause\");\nexport const EVENT_DISPATCHER_PLAY = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"play\");\nexport const EVENT_DISPATCHER_PLAYING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"playing\");\nexport const EVENT_DISPATCHER_POINTER_CANCEL = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointercancel\");\nexport const EVENT_DISPATCHER_POINTER_DOWN = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerdown\");\nexport const EVENT_DISPATCHER_POINTER_MOVE = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointermove\");\nexport const EVENT_DISPATCHER_POINTER_OUT = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerout\");\nexport const EVENT_DISPATCHER_POINTER_OVER = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerover\");\nexport const EVENT_DISPATCHER_POINTER_UP = /*#__PURE__*/createNativeEventDispatcher<PointerEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"pointerup\");\nexport const EVENT_DISPATCHER_PROGRESS = /*#__PURE__*/createNativeEventDispatcher<ProgressEvent>(NativeEventSourceFlags.Capture, \"progress\");\nexport const EVENT_DISPATCHER_RATE_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"ratechange\");\nexport const EVENT_DISPATCHER_RESET = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"reset\");\nexport const EVENT_DISPATCHER_SCROLL = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture, \"scroll\");\nexport const EVENT_DISPATCHER_SEEKED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeked\");\nexport const EVENT_DISPATCHER_SEEKING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"seeking\");\nexport const EVENT_DISPATCHER_SELECT = /*#__PURE__*/createNativeEventDispatcher<UIEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"select\");\nexport const EVENT_DISPATCHER_SELECT_START = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"selectstart\");\nexport const EVENT_DISPATCHER_STALLED = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"stalled\");\nexport const EVENT_DISPATCHER_SUBMIT = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"submit\");\nexport const EVENT_DISPATCHER_SUSPEND = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"suspend\");\nexport const EVENT_DISPATCHER_TIME_UPDATE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"timeupdate\");\nexport const EVENT_DISPATCHER_TOUCH_CANCEL = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchcancel\");\nexport const EVENT_DISPATCHER_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchend\");\nexport const EVENT_DISPATCHER_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchmove\");\nexport const EVENT_DISPATCHER_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"touchstart\");\nexport const EVENT_DISPATCHER_UNLOAD = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"unload\");\nexport const EVENT_DISPATCHER_VOLUME_CHANGE = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"volumechange\");\nexport const EVENT_DISPATCHER_WAITING = /*#__PURE__*/createNativeEventDispatcher<Event>(NativeEventSourceFlags.Capture, \"waiting\");\nexport const EVENT_DISPATCHER_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles | NativeEventSourceFlags.Passive, \"wheel\");\n\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_END = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchend\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchmove\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_TOUCH_START = /*#__PURE__*/createNativeEventDispatcher<TouchEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"touchstart\", EVENT_CAPTURE_ACTIVE_OPTIONS);\nexport const EVENT_DISPATCHER_ACTIVE_WHEEL = /*#__PURE__*/createNativeEventDispatcher<WheelEvent>(NativeEventSourceFlags.Capture | NativeEventSourceFlags.Bubbles, \"wheel\", EVENT_CAPTURE_ACTIVE_OPTIONS);\n\n/**\n * Helper function that creates event handlers.\n *\n * @param d - Event source\n * @param h - Event Handler function\n * @param capture - Capture mode\n * @returns EventHandler instance\n */\nexport function createNativeEventHandler(src: NativeEventDispatcher<any>): (\n  h: (ev: SyntheticNativeEvent<any>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<any> {\n  const bubbleDescriptor = { src, flags: EventHandlerFlags.Bubble };\n  const captureDescriptor = { src, flags: EventHandlerFlags.Capture };\n  return (h, capture) => ({\n    d: capture === true ? captureDescriptor : bubbleDescriptor,\n    h,\n  });\n}\n\nexport const onAbort: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ABORT));\nexport const onActivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVATE));\nexport const onAriaRequest: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ARIA_REQUEST));\nexport const onBeforeActivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_ACTIVATE));\nexport const onBeforeCopy: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_COPY));\nexport const onBeforeCut: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_CUT));\nexport const onBeforeDeactivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_DEACTIVATE));\nexport const onBeforePaste: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BEFORE_PASTE));\nexport const onBlur: <P>(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<FocusEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_BLUR));\nexport const onCanPlay: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CAN_PLAY));\nexport const onCanPlaythrough: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CAN_PLAYTHROUGH));\nexport const onChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CHANGE));\nexport const onClick: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CLICK));\nexport const onContextMenu: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CONTEXT_MENU));\nexport const onCopy: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_COPY));\nexport const onCueChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CUE_CHANGE));\nexport const onCut: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_CUT));\nexport const onDoubleClick: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DOUBLE_CLICK));\nexport const onDeactivate: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DEACTIVATE));\nexport const onDrag: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG));\nexport const onDragEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_END));\nexport const onDragEnter: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_ENTER));\nexport const onDragLeave: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_LEAVE));\nexport const onDragOver: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_OVER));\nexport const onDragStart: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DRAG_START));\nexport const onDrop: <P>(\n  handler: (ev: SyntheticNativeEvent<DragEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<DragEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DROP));\nexport const onDurationChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_DURATION_CHANGE));\nexport const onEmptied: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_EMPTIED));\nexport const onEncrypted: <P>(\n  handler: (ev: SyntheticNativeEvent<MediaEncryptedEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MediaEncryptedEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ENCRYPTED));\nexport const onEnded: <P>(\n  handler: (ev: SyntheticNativeEvent<MediaStreamErrorEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MediaStreamErrorEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ENDED));\nexport const onError: <P>(\n  handler: (ev: SyntheticNativeEvent<ErrorEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ErrorEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ERROR));\nexport const onFocus: <P>(\n  handler: (ev: SyntheticNativeEvent<FocusEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<FocusEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_FOCUS));\nexport const onGotPointerCapture: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_GOT_POINTER_CAPTURE));\nexport const onInput: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_INPUT));\nexport const onInvalid: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_INVALID));\nexport const onKeyDown: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_DOWN));\nexport const onKeyPress: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_PRESS));\nexport const onKeyUp: <P>(\n  handler: (ev: SyntheticNativeEvent<KeyboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<KeyboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_KEY_UP));\nexport const onLoad: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOAD));\nexport const onLoadedData: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOADED_DATA));\nexport const onLoadedMetadata: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOADED_METADATA));\nexport const onLoadStart: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOAD_START));\nexport const onLostPointerCapture: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_LOST_POINTER_CAPTURE));\nexport const onMouseDown: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_DOWN));\nexport const onMouseMove: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_MOVE));\nexport const onMouseOut: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_OUT));\nexport const onMouseOver: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_OVER));\nexport const onMouseUp: <P>(\n  handler: (ev: SyntheticNativeEvent<MouseEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<MouseEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_MOUSE_UP));\nexport const onPaste: <P>(\n  handler: (ev: SyntheticNativeEvent<ClipboardEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ClipboardEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PASTE));\nexport const onPause: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PAUSE));\nexport const onPlay: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PLAY));\nexport const onPlaying: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PLAYING));\nexport const onPointerCancel: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_CANCEL));\nexport const onPointerDown: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_DOWN));\nexport const onPointerMove: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_MOVE));\nexport const onPointerOut: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_OUT));\nexport const onPointerOver: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_OVER));\nexport const onPointerUp: <P>(\n  handler: (ev: SyntheticNativeEvent<PointerEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<PointerEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_POINTER_UP));\nexport const onProgress: <P>(\n  handler: (ev: SyntheticNativeEvent<ProgressEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<ProgressEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_PROGRESS));\nexport const onRateChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_RATE_CHANGE));\nexport const onReset: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_RESET));\nexport const onScroll: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SCROLL));\nexport const onSeeked: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SEEKED));\nexport const onSeeking: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SEEKING));\nexport const onSelect: <P>(\n  handler: (ev: SyntheticNativeEvent<UIEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<UIEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SELECT));\nexport const onSelectStart: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SELECT_START));\nexport const onStalled: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_STALLED));\nexport const onSubmit: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SUBMIT));\nexport const onSuspend: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_SUSPEND));\nexport const onTimeUpdate: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TIME_UPDATE));\nexport const onTouchCancel: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_CANCEL));\nexport const onTouchEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_END));\nexport const onTouchMove: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_MOVE));\nexport const onTouchStart: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_TOUCH_START));\nexport const onUnload: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_UNLOAD));\nexport const onVolumeChange: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_VOLUME_CHANGE));\nexport const onWaiting: <P>(\n  handler: (ev: SyntheticNativeEvent<Event>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<Event>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_WAITING));\nexport const onWheel: <P>(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<WheelEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_WHEEL));\n\nexport const onActiveTouchEnd: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_END));\nexport const onActiveTouchMove: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_MOVE));\nexport const onActiveTouchStart: <P>(\n  handler: (ev: SyntheticNativeEvent<TouchEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<TouchEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_TOUCH_START));\nexport const onActiveWheel: <P>(\n  handler: (ev: SyntheticNativeEvent<WheelEvent>) => EventFlags | void,\n  capture?: boolean,\n) => EventHandlerNode<SyntheticNativeEvent<WheelEvent>> = (/*#__PURE__*/createNativeEventHandler(EVENT_DISPATCHER_ACTIVE_WHEEL));\n\n/* tslint:enable:max-line-length */\n","import { NOOP } from \"../core\";\nimport { scheduleLayoutEffect } from \"../scheduler\";\nimport { emitChildren, emitAttribute } from \"../ssr/render\";\n\n/**\n * Attribute directives are used to extend reconciliation and renderToString algorithms.\n *\n * When DOM element attributes are updated, all value types are checked if it is a string, number, boolean or an\n * `AttributeDirective`. When it is an attribute directive, custom update function will be invoked with the DOM\n * element, attribute key, previous and next values.\n *\n * @typeparam T Value type.\n */\nexport interface AttributeDirective<T> {\n  /**\n   * Value.\n   */\n  readonly v: T | undefined;\n  /**\n   * Update function.\n   *\n   * @param element Target element.\n   * @param key Attribute key.\n   * @param prev Previous value.\n   * @param next Next value.\n   */\n  readonly u?: (element: Element, key: string, prev: T | undefined, next: T | undefined) => void;\n  /**\n   * Render to string function.\n   *\n   * @param key Attribute key.\n   * @param value Value.\n   */\n  readonly s?: (key: string, value: T) => void;\n}\n\n/**\n * {@link AttributeDirective} that ignores rendering to string.\n */\nexport const IGNORE_RENDER_TO_STRING = ({ v: void 0, s: NOOP });\n\n/**\n * PROPERTY function creates an {@link AttributeDirective} that assigns a property to a property name derived from the\n * `key` of the attribute.\n *\n * @example\n *\n *   const e = div(\"\", { _customProperty: PROPERTY(\"value\") });\n *\n * @typeparam Property value type.\n * @param v Property value.\n * @returns {@link AttributeDirective}\n */\nexport const PROPERTY = <T>(v: T): AttributeDirective<T> => (\n  __IVI_TARGET__ === \"ssr\" ? IGNORE_RENDER_TO_STRING : ({ v, u: updateProperty })\n);\n\n/**\n * Update function for an {@link AttributeDirective} created with a {@link PROPERTY} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateProperty(element: Element, key: string, prev: any, next: any): void {\n  if (prev !== next && next !== void 0) {\n    (element as any)[key] = next!;\n  }\n}\n\n/**\n * UNSAFE_HTML function creates a {@link AttributeDirective} that assigns an `innerHTML` property to an Element.\n *\n * @example\n *\n *   const e = div(\"\", { unsafeHTML: UNSAFE_HTML(\"<span></span>\") });\n *\n * @param v innerHTML value.\n * @returns {@link AttributeDirective}\n */\nexport const UNSAFE_HTML = (v: string): AttributeDirective<string> => (\n  __IVI_TARGET__ === \"ssr\" ?\n    ({ v, s: renderToStringUnsafeHTML }) :\n    ({ v, u: updateUnsafeHTML })\n);\n\n/**\n * Render to string function for an {@link AttributeDirective} created with {@link UNSAFE_HTML} function.\n *\n * @param key Attribute key.\n * @param value Value.\n */\nfunction renderToStringUnsafeHTML(key: string, value: string) {\n  emitChildren(value);\n}\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link UNSAFE_HTML} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateUnsafeHTML(element: Element, key: string, prev: string | undefined, next: string | undefined) {\n  if (prev !== next) {\n    if (next === void 0) {\n      element.innerHTML = \"\";\n    } else if (prev !== void 0 || next !== \"\") {\n      element.innerHTML = next!;\n    }\n  }\n}\n\n/**\n * EVENT function creates an {@link AttributeDirective} that assigns a native event handler derived from the `key`\n * attribute to an Element.\n *\n * @example\n *\n *   const e = div(\"\", { click: EVENT((ev) => { console.log(ev) }); });\n *\n * @param v Event handler.\n * @returns {@link AttributeDirective}\n */\nexport const EVENT = (v: (ev: Event) => void): AttributeDirective<(ev: Event) => void> => (\n  __IVI_TARGET__ === \"ssr\" ?\n    IGNORE_RENDER_TO_STRING :\n    ({ v, u: updateEvent })\n);\n\n/**\n * Update function for an {@link AttributeDirective} created with {@link EVENT} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateEvent(\n  element: Element,\n  key: string,\n  prev: ((ev: Event) => void) | undefined,\n  next: ((ev: Event) => void) | undefined,\n) {\n  if (prev !== next) {\n    if (prev !== void 0) {\n      element.removeEventListener(key, prev);\n    }\n    if (next !== void 0) {\n      element.addEventListener(key, next);\n    }\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link AUTOFOCUS} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateAutofocus(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0 && next) {\n    scheduleLayoutEffect(() => { (element as HTMLElement).focus(); });\n  }\n}\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_FALSE: AttributeDirective<boolean> = { v: false, u: updateAutofocus };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateAutofocus} sync function.\n */\nconst AUTOFOCUS_TRUE: AttributeDirective<boolean> = { v: true, u: updateAutofocus };\n\n/**\n * {@link AttributeDirective} with `true` value that emits `autofocus` attribute.\n */\nconst AUTOFOCUS_TRUE_RENDER_TO_STRING: AttributeDirective<boolean> = {\n  v: true,\n  s: () => { emitAttribute(\"autofocus\"); },\n};\n\n/**\n * AUTOFOCUS function creates a {@link AttributeDirective} that sets autofocus on an element.\n *\n * @example\n *\n *   const e = input(\"\", { autofocus: AUTOFOCUS(true) });\n *\n * @param v Autofocus state.\n * @returns {@link AttributeDirective}\n */\nexport const AUTOFOCUS = (v: boolean): AttributeDirective<boolean> => (\n  __IVI_TARGET__ === \"ssr\" ?\n    v ? AUTOFOCUS_TRUE_RENDER_TO_STRING : IGNORE_RENDER_TO_STRING :\n    v ? AUTOFOCUS_TRUE : AUTOFOCUS_FALSE\n);\n","/**\n * Boxed value.\n *\n * @typeparam T Value type.\n */\nexport interface Box<T> {\n  v: T;\n}\n\n/**\n * box creates a boxed value.\n *\n * @typeparam T Value type.\n * @param v Value.\n * @returns Boxed value.\n */\nexport const box = <T>(v: T) => ({ v });\n","import {\n  HTMLAnchorElementAttrs, HTMLElementAttrs, HTMLAreaElementAttrs, HTMLAudioElementAttrs,\n  HTMLBaseElementAttrs, HTMLBodyElementAttrs, HTMLBRElementAttrs, HTMLButtonElementAttrs,\n  HTMLCanvasElementAttrs, HTMLQuoteElementAttrs, HTMLTableCaptionElementAttrs, HTMLTableColElementAttrs,\n  HTMLModElementAttrs, HTMLDivElementAttrs, HTMLDListElementAttrs, HTMLFieldSetElementAttrs, HTMLFormElementAttrs,\n  HTMLHeadElementAttrs, HTMLHeadingElementAttrs, HTMLHRElementAttrs, HTMLHtmlElementAttrs, HTMLIFrameElementAttrs,\n  HTMLImageElementAttrs, HTMLInputElementAttrs, HTMLLabelElementAttrs, HTMLLegendElementAttrs, HTMLLIElementAttrs,\n  HTMLLinkElementAttrs, HTMLMapElementAttrs, HTMLMenuElementAttrs, HTMLMetaElementAttrs, HTMLMeterElementAttrs,\n  HTMLOListElementAttrs, HTMLOptGroupElementAttrs, HTMLOptionElementAttrs, HTMLParagraphElementAttrs,\n  HTMLPictureElementAttrs, HTMLPreElementAttrs, HTMLProgressElementAttrs, HTMLScriptElementAttrs,\n  HTMLSelectElementAttrs, HTMLSourceElementAttrs, HTMLSpanElementAttrs, HTMLStyleElementAttrs,\n  HTMLTableDataCellElementAttrs, HTMLTableElementAttrs, HTMLTableHeaderCellElementAttrs, HTMLTableRowElementAttrs,\n  HTMLTableSectionElementAttrs, HTMLTemplateElementAttrs, HTMLTextAreaElementAttrs, HTMLTitleElementAttrs,\n  HTMLTrackElementAttrs, HTMLUListElementAttrs, HTMLVideoElementAttrs,\n\n  AttributeDirective, elementFactory, htmlElementFactory, NodeFlags,\n  emitAttribute, emitChildren, escapeAttributeValue, escapeText, IGNORE_RENDER_TO_STRING,\n} from \"ivi\";\n\n/**\n * {@link AttributeDirective} with `\"\"` value and {@link updateValue} sync function.\n */\nconst VALUE_EMPTY: AttributeDirective<string | number> = { v: \"\", u: updateValue };\n\n/**\n * {@link AttributeDirective} with `false` value and {@link updateChecked} sync function.\n */\nconst CHECKED_FALSE: AttributeDirective<boolean> = { v: false, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value and {@link updateChecked} sync function.\n */\nconst CHECKED_TRUE: AttributeDirective<boolean> = { v: true, u: updateChecked };\n\n/**\n * {@link AttributeDirective} with `true` value that emits `checked` attribute.\n */\nconst CHECKED_TRUE_RENDER_TO_STRING: AttributeDirective<boolean> = { v: true, s: () => { emitAttribute(\"checked\"); } };\n\n/**\n * Render to string function for an {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param key Attribute key.\n * @param value Value.\n */\nfunction renderToStringValue(key: string, value: string | number) {\n  emitAttribute(`value=\"${escapeAttributeValue(value)}\"`);\n}\n\n/**\n * Render to string function for an {@link AttributeDirective} created with {@link CONTENT} function.\n *\n * @param key Attribute key.\n * @param value Value.\n */\nfunction renderToStringContent(key: string, value: string | number) {\n  emitChildren(escapeText(value));\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link VALUE} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateValue(\n  element: Element,\n  key: string,\n  prev: string | number | undefined,\n  next: string | number | undefined,\n) {\n  if (prev === void 0) {\n    if (next !== \"\") {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement | HTMLTextAreaElement).value !== next) {\n      (element as HTMLInputElement | HTMLTextAreaElement).value = next as string;\n    }\n  }\n}\n\n/**\n * Synchronization function for {@link AttributeDirective} created with {@link CHECKED} function.\n *\n * @param element Target element.\n * @param key Attribute key.\n * @param prev Previous value.\n * @param next Next value.\n */\nfunction updateChecked(\n  element: Element,\n  key: string,\n  prev: boolean | undefined,\n  next: boolean | undefined,\n) {\n  if (prev === void 0) {\n    if (next) {\n      (element as HTMLInputElement).checked = next;\n    }\n  } else if (next !== void 0) {\n    if ((element as HTMLInputElement).checked !== next) {\n      (element as HTMLInputElement).checked = next!;\n    }\n  }\n}\n\n/**\n * VALUE function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { value: VALUE(\"value\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const VALUE = (v: string | number): AttributeDirective<string | number> => (\n  __IVI_TARGET__ === \"ssr\" ?\n    v === \"\" ? IGNORE_RENDER_TO_STRING : { v, s: renderToStringValue } :\n    v === \"\" ? VALUE_EMPTY : { v, u: updateValue }\n);\n\n/**\n * CONTENT function creates a {@link AttributeDirective} that assigns a `value` property to an HTMLTextAreaElement.\n *\n * @example\n *\n *   const e = textarea(\"\", { content: CONTENT(\"content\") });\n *\n * @param v Value.\n * @returns {@link AttributeDirective}\n */\nexport const CONTENT = (\n  __IVI_TARGET__ === \"ssr\" ?\n    (v: string | number): AttributeDirective<string | number> => (\n      v === \"\" ? IGNORE_RENDER_TO_STRING : ({ v, s: renderToStringContent })\n    ) :\n    VALUE\n);\n\n/**\n * CHECKED function creates a {@link AttributeDirective} that assigns a `checked` property to an HTMLInputElement.\n *\n * @example\n *\n *   const e = input(\"\", { checked: CHECKED(true) });\n *\n * @param v Checked value.\n * @returns {@link AttributeDirective}\n */\nexport const CHECKED = (v: boolean): AttributeDirective<boolean> => (\n  __IVI_TARGET__ === \"ssr\" ?\n    v ? CHECKED_TRUE_RENDER_TO_STRING : IGNORE_RENDER_TO_STRING :\n    v ? CHECKED_TRUE : CHECKED_FALSE\n);\n\n/* tslint:disable:max-line-length */\n/**\n * Creates OpNode HTML element <a>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <a>\n */\nexport const a = /*#__PURE__*/htmlElementFactory<HTMLAnchorElementAttrs, HTMLAnchorElement>(\"a\");\n\n/**\n * Creates OpNode HTML element <abbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/abbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <abbr>\n */\nexport const abbr = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"abbr\");\n\n/**\n * Creates OpNode HTML element <address>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/address}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <address>\n */\nexport const address = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"address\");\n\n/**\n * Creates OpNode HTML element <article>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/article}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <article>\n */\nexport const article = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"article\");\n\n/**\n * Creates OpNode HTML element <aside>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <aside>\n */\nexport const aside = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"aside\");\n\n/**\n * Creates OpNode HTML element <b>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <b>\n */\nexport const b = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"b\");\n\n/**\n * Creates OpNode HTML element <base>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <base>\n */\nexport const base = /*#__PURE__*/elementFactory<HTMLBaseElementAttrs, HTMLBaseElement>(\"base\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <bdo>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <bdo>\n */\nexport const bdo = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"bdo\");\n\n/**\n * Creates OpNode HTML element <blockquote>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <blockquote>\n */\nexport const blockquote = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"blockquote\");\n\n/**\n * Creates OpNode HTML element <body>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <body>\n */\nexport const body = /*#__PURE__*/htmlElementFactory<HTMLBodyElementAttrs, HTMLBodyElement>(\"body\");\n\n/**\n * Creates OpNode HTML element <br>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <br>\n */\nexport const br = /*#__PURE__*/elementFactory<HTMLBRElementAttrs, HTMLBRElement>(\"br\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <button>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <button>\n */\nexport const button = /*#__PURE__*/htmlElementFactory<HTMLButtonElementAttrs, HTMLButtonElement>(\"button\");\n\n/**\n * Creates OpNode HTML element <canvas>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <canvas>\n */\nexport const canvas = /*#__PURE__*/htmlElementFactory<HTMLCanvasElementAttrs, HTMLCanvasElement>(\"canvas\");\n\n/**\n * Creates OpNode HTML element <caption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <caption>\n */\nexport const caption = /*#__PURE__*/htmlElementFactory<HTMLTableCaptionElementAttrs, HTMLTableCaptionElement>(\"caption\");\n\n/**\n * Creates OpNode HTML element <cite>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <cite>\n */\nexport const cite = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"cite\");\n\n/**\n * Creates OpNode HTML element <code>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <code>\n */\nexport const code = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"code\");\n\n/**\n * Creates OpNode HTML element <col>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <col>\n */\nexport const col = /*#__PURE__*/elementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"col\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <colgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <colgroup>\n */\nexport const colgroup = /*#__PURE__*/htmlElementFactory<HTMLTableColElementAttrs, HTMLTableColElement>(\"colgroup\");\n\n/**\n * Creates OpNode HTML element <del>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <del>\n */\nexport const del = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"del\");\n\n/**\n * Creates OpNode HTML element <dfn>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dfn>\n */\nexport const dfn = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dfn\");\n\n/**\n * Creates OpNode HTML element <div>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <div>\n */\nexport const div = /*#__PURE__*/htmlElementFactory<HTMLDivElementAttrs, HTMLDivElement>(\"div\");\n\n/**\n * Creates OpNode HTML element <dd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dd>\n */\nexport const dd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dd\");\n\n/**\n * Creates OpNode HTML element <dl>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dl>\n */\nexport const dl = /*#__PURE__*/htmlElementFactory<HTMLDListElementAttrs, HTMLDListElement>(\"dl\");\n\n/**\n * Creates OpNode HTML element <dt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <dt>\n */\nexport const dt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"dt\");\n\n/**\n * Creates OpNode HTML element <em>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <em>\n */\nexport const em = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"em\");\n\n/**\n * Creates OpNode HTML element <fieldset>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <fieldset>\n */\nexport const fieldset = /*#__PURE__*/htmlElementFactory<HTMLFieldSetElementAttrs, HTMLFieldSetElement>(\"fieldset\");\n\n/**\n * Creates OpNode HTML element <figcaption>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figcaption>\n */\nexport const figcaption = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figcaption\");\n\n/**\n * Creates OpNode HTML element <figure>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <figure>\n */\nexport const figure = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"figure\");\n\n/**\n * Creates OpNode HTML element <footer>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <footer>\n */\nexport const footer = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"footer\");\n\n/**\n * Creates OpNode HTML element <form>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <form>\n */\nexport const form = /*#__PURE__*/htmlElementFactory<HTMLFormElementAttrs, HTMLFormElement>(\"form\");\n\n/**\n * Creates OpNode HTML element <h1>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h1>\n */\nexport const h1 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h1\");\n\n/**\n * Creates OpNode HTML element <h2>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h2}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h2>\n */\nexport const h2 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h2\");\n\n/**\n * Creates OpNode HTML element <h3>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h3}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h3>\n */\nexport const h3 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h3\");\n\n/**\n * Creates OpNode HTML element <h4>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h4}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h4>\n */\nexport const h4 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h4\");\n\n/**\n * Creates OpNode HTML element <h5>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h5}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h5>\n */\nexport const h5 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h5\");\n\n/**\n * Creates OpNode HTML element <h6>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h6}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <h6>\n */\nexport const h6 = /*#__PURE__*/htmlElementFactory<HTMLHeadingElementAttrs, HTMLHeadingElement>(\"h6\");\n\n/**\n * Creates OpNode HTML element <head>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <head>\n */\nexport const head = /*#__PURE__*/htmlElementFactory<HTMLHeadElementAttrs, HTMLHeadElement>(\"head\");\n\n/**\n * Creates OpNode HTML element <header>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <header>\n */\nexport const header = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"header\");\n\n/**\n * Creates OpNode HTML element <hgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hgroup>\n */\nexport const hgroup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"hgroup\");\n\n/**\n * Creates OpNode HTML element <hr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <hr>\n */\nexport const hr = /*#__PURE__*/elementFactory<HTMLHRElementAttrs, HTMLHRElement>(\"hr\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <html>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <html>\n */\nexport const html = /*#__PURE__*/htmlElementFactory<HTMLHtmlElementAttrs, HTMLHtmlElement>(\"html\");\n\n/**\n * Creates OpNode HTML element <i>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <i>\n */\nexport const i = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"i\");\n\n/**\n * Creates OpNode HTML element <iframe>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <iframe>\n */\nexport const iframe = /*#__PURE__*/htmlElementFactory<HTMLIFrameElementAttrs, HTMLIFrameElement>(\"iframe\");\n\n/**\n * Creates OpNode HTML element <img>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <img>\n */\nexport const img = /*#__PURE__*/elementFactory<HTMLImageElementAttrs, HTMLImageElement>(\"img\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <area>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <area>\n */\nexport const area = /*#__PURE__*/elementFactory<HTMLAreaElementAttrs, HTMLAreaElement>(\"area\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <map>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <map>\n */\nexport const map = /*#__PURE__*/htmlElementFactory<HTMLMapElementAttrs, HTMLMapElement>(\"map\");\n\n/**\n * Creates OpNode HTML element <ins>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ins>\n */\nexport const ins = /*#__PURE__*/htmlElementFactory<HTMLModElementAttrs, HTMLModElement>(\"ins\");\n\n/**\n * Creates OpNode HTML element <kbd>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <kbd>\n */\nexport const kbd = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"kbd\");\n\n/**\n * Creates OpNode HTML element <label>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <label>\n */\nexport const label = /*#__PURE__*/htmlElementFactory<HTMLLabelElementAttrs, HTMLLabelElement>(\"label\");\n\n/**\n * Creates OpNode HTML element <legend>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <legend>\n */\nexport const legend = /*#__PURE__*/htmlElementFactory<HTMLLegendElementAttrs, HTMLLegendElement>(\"legend\");\n\n/**\n * Creates OpNode HTML element <li>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <li>\n */\nexport const li = /*#__PURE__*/htmlElementFactory<HTMLLIElementAttrs, HTMLLIElement>(\"li\");\n\n/**\n * Creates OpNode HTML element <link>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <link>\n */\nexport const link = /*#__PURE__*/elementFactory<HTMLLinkElementAttrs, HTMLLinkElement>(\"link\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <main>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <main>\n */\nexport const main = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"main\");\n\n/**\n * Creates OpNode HTML element <mark>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <mark>\n */\nexport const mark = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"mark\");\n\n/**\n * Creates OpNode HTML element <menu>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <menu>\n */\nexport const menu = /*#__PURE__*/htmlElementFactory<HTMLMenuElementAttrs, HTMLMenuElement>(\"menu\");\n\n/**\n * Creates OpNode HTML element <meta>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meta>\n */\nexport const meta = /*#__PURE__*/elementFactory<HTMLMetaElementAttrs, HTMLMetaElement>(\"meta\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <meter>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <meter>\n */\nexport const meter = /*#__PURE__*/htmlElementFactory<HTMLMeterElementAttrs, HTMLMeterElement>(\"meter\");\n\n/**\n * Creates OpNode HTML element <nav>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <nav>\n */\nexport const nav = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"nav\");\n\n/**\n * Creates OpNode HTML element <noscript>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <noscript>\n */\nexport const noscript = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"noscript\");\n\n/**\n * Creates OpNode HTML element <ol>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ol>\n */\nexport const ol = /*#__PURE__*/htmlElementFactory<HTMLOListElementAttrs, HTMLOListElement>(\"ol\");\n\n/**\n * Creates OpNode HTML element <optgroup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <optgroup>\n */\nexport const optgroup = /*#__PURE__*/htmlElementFactory<HTMLOptGroupElementAttrs, HTMLOptGroupElement>(\"optgroup\");\n\n/**\n * Creates OpNode HTML element <option>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <option>\n */\nexport const option = /*#__PURE__*/htmlElementFactory<HTMLOptionElementAttrs, HTMLOptionElement>(\"option\");\n\n/**\n * Creates OpNode HTML element <p>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <p>\n */\nexport const p = /*#__PURE__*/htmlElementFactory<HTMLParagraphElementAttrs, HTMLParagraphElement>(\"p\");\n\n/**\n * Creates OpNode HTML element <picture>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <picture>\n */\nexport const picture = /*#__PURE__*/htmlElementFactory<HTMLPictureElementAttrs, HTMLPictureElement>(\"picture\");\n\n/**\n * Creates OpNode HTML element <pre>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <pre>\n */\nexport const pre = /*#__PURE__*/elementFactory<HTMLPreElementAttrs, HTMLPreElement>(\"pre\", NodeFlags.Element | NodeFlags.NewlineEatingElement);\n\n/**\n * Creates OpNode HTML element <progress>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <progress>\n */\nexport const progress = /*#__PURE__*/htmlElementFactory<HTMLProgressElementAttrs, HTMLProgressElement>(\"progress\");\n\n/**\n * Creates OpNode HTML element <q>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <q>\n */\nexport const q = /*#__PURE__*/htmlElementFactory<HTMLQuoteElementAttrs, HTMLQuoteElement>(\"q\");\n\n/**\n * Creates OpNode HTML element <rt>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <rt>\n */\nexport const rt = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"rt\");\n\n/**\n * Creates OpNode HTML element <ruby>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ruby>\n */\nexport const ruby = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"ruby\");\n\n/**\n * Creates OpNode HTML element <s>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <s>\n */\nexport const s = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"s\");\n\n/**\n * Creates OpNode HTML element <samp>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <samp>\n */\nexport const samp = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"samp\");\n\n/**\n * Creates OpNode HTML element <script>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <script>\n */\nexport const script = /*#__PURE__*/htmlElementFactory<HTMLScriptElementAttrs, HTMLScriptElement>(\"script\");\n\n/**\n * Creates OpNode HTML element <section>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <section>\n */\nexport const section = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"section\");\n\n/**\n * Creates OpNode HTML element <select>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <select>\n */\nexport const select = /*#__PURE__*/htmlElementFactory<HTMLSelectElementAttrs, HTMLSelectElement>(\"select\");\n\n/**\n * Creates OpNode HTML element <source>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <source>\n */\nexport const source = /*#__PURE__*/elementFactory<HTMLSourceElementAttrs, HTMLSourceElement>(\"source\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <span>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <span>\n */\nexport const span = /*#__PURE__*/htmlElementFactory<HTMLSpanElementAttrs, HTMLSpanElement>(\"span\");\n\n/**\n * Creates OpNode HTML element <strong>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <strong>\n */\nexport const strong = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"strong\");\n\n/**\n * Creates OpNode HTML element <style>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <style>\n */\nexport const style = /*#__PURE__*/htmlElementFactory<HTMLStyleElementAttrs, HTMLStyleElement>(\"style\");\n\n/**\n * Creates OpNode HTML element <sub>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sub>\n */\nexport const sub = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sub\");\n\n/**\n * Creates OpNode HTML element <sup>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <sup>\n */\nexport const sup = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"sup\");\n\n/**\n * Creates OpNode HTML element <table>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <table>\n */\nexport const table = /*#__PURE__*/htmlElementFactory<HTMLTableElementAttrs, HTMLTableElement>(\"table\");\n\n/**\n * Creates OpNode HTML element <tbody>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tbody>\n */\nexport const tbody = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tbody\");\n\n/**\n * Creates OpNode HTML element <td>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <td>\n */\nexport const td = /*#__PURE__*/htmlElementFactory<HTMLTableDataCellElementAttrs, HTMLTableDataCellElement>(\"td\");\n\n/**\n * Creates OpNode HTML element <template>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <template>\n */\nexport const template = /*#__PURE__*/htmlElementFactory<HTMLTemplateElementAttrs, HTMLTemplateElement>(\"template\");\n\n/**\n * Creates OpNode HTML element <tfoot>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tfoot>\n */\nexport const tfoot = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"tfoot\");\n\n/**\n * Creates OpNode HTML element <th>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <th>\n */\nexport const th = /*#__PURE__*/htmlElementFactory<HTMLTableHeaderCellElementAttrs, HTMLTableHeaderCellElement>(\"th\");\n\n/**\n * Creates OpNode HTML element <thead>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <thead>\n */\nexport const thead = /*#__PURE__*/htmlElementFactory<HTMLTableSectionElementAttrs, HTMLTableSectionElement>(\"thead\");\n\n/**\n * Creates OpNode HTML element <time>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <time>\n */\nexport const time = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"time\");\n\n/**\n * Creates OpNode HTML element <title>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <title>\n */\nexport const title = /*#__PURE__*/htmlElementFactory<HTMLTitleElementAttrs, HTMLTitleElement>(\"title\");\n\n/**\n * Creates OpNode HTML element <tr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <tr>\n */\nexport const tr = /*#__PURE__*/htmlElementFactory<HTMLTableRowElementAttrs, HTMLTableRowElement>(\"tr\");\n\n/**\n * Creates OpNode HTML element <track>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <track>\n */\nexport const track = /*#__PURE__*/elementFactory<HTMLTrackElementAttrs, HTMLTrackElement>(\"track\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <u>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <u>\n */\nexport const u = /*#__PURE__*/htmlElementFactory<HTMLElementAttrs, HTMLElement>(\"u\");\n\n/**\n * Creates OpNode HTML element <ul>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <ul>\n */\nexport const ul = /*#__PURE__*/htmlElementFactory<HTMLUListElementAttrs, HTMLUListElement>(\"ul\");\n\n/**\n * Creates OpNode HTML element <wbr>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <wbr>\n */\nexport const wbr = /*#__PURE__*/elementFactory<HTMLElementAttrs, HTMLElement>(\"wbr\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <textarea>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <textarea>\n */\nexport const textarea = /*#__PURE__*/elementFactory<HTMLTextAreaElementAttrs, HTMLTextAreaElement>(\"textarea\", NodeFlags.Element | NodeFlags.NewlineEatingElement);\n\n/**\n * Creates OpNode HTML element <input>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <input>\n */\nexport const input = /*#__PURE__*/elementFactory<HTMLInputElementAttrs, HTMLInputElement>(\"input\", NodeFlags.Element | NodeFlags.VoidElement);\n\n/**\n * Creates OpNode HTML element <audio>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <audio>\n */\nexport const audio = /*#__PURE__*/htmlElementFactory<HTMLAudioElementAttrs, HTMLAudioElement>(\"audio\");\n\n/**\n * Creates OpNode HTML element <video>.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video}\n *\n * @param className Class name.\n * @param attrs Attributes.\n * @param children Children nodes.\n * @returns OpNode HTML element <video>\n */\nexport const video = /*#__PURE__*/htmlElementFactory<HTMLVideoElementAttrs, HTMLVideoElement>(\"video\");\n","export const LEFT = { x: -1, y: 0 };\nexport const RIGHT = { x: 1, y: 0 };\nexport const UP = { x: 0, y: -1 };\nexport const DOWN = { x: 0, y: 1 };\nexport class Snake {\n    constructor(startPosition = { x: 0, y: 0 }) {\n        this.body = [];\n        this.grow = 4;\n        this.body.push(startPosition);\n    }\n    get head() {\n        return this.body[this.body.length - 1];\n    }\n    move(p) {\n        this.body.push(p);\n        if (this.grow) {\n            this.grow--;\n            return null;\n        }\n        else {\n            const r = this.body[0];\n            this.body = this.body.splice(1);\n            return r;\n        }\n    }\n}\nexport class Grid {\n    constructor(rows = 20, cols = 20) {\n        this.rows = rows;\n        this.cols = cols;\n        this.cells = new Array(rows * cols).fill(0);\n    }\n    pointToIndex(p) {\n        return this.cols * p.y + p.x;\n    }\n    mark(p, flag) {\n        this.cells[this.pointToIndex(p)] |= flag;\n    }\n    unmark(p, flag) {\n        this.cells[this.pointToIndex(p)] &= ~flag;\n    }\n    createRandomFood() {\n        let i = 0;\n        do {\n            i = (Math.random() * this.cells.length) | 0;\n        } while (this.cells[i] !== 0);\n        this.cells[i] |= 4 /* Food */;\n    }\n    isBodyAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 1 /* Body */);\n    }\n    isHeadAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 2 /* Head */);\n    }\n    isFoodAt(p) {\n        return !!(this.cells[this.pointToIndex(p)] & 4 /* Food */);\n    }\n}\nfunction addPoints(a, b) {\n    return {\n        x: a.x + b.x,\n        y: a.y + b.y,\n    };\n}\nfunction eqPoints(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\nfunction mod(a, b) {\n    return ((a % b) + b) % b;\n}\nexport class Game {\n    constructor() {\n        this.gameOver = false;\n        this.startTime = 0;\n        this.currentTime = 0;\n        this.direction = { x: 1, y: 0 };\n        this.grid = new Grid();\n        this.snake = new Snake();\n        this.newDirection = null;\n        this.snake.body.forEach((p) => {\n            this.grid.mark(p, 1 /* Body */);\n        });\n        this.grid.mark(this.snake.head, 2 /* Head */);\n        this.grid.createRandomFood();\n    }\n    setNewDirection(dir) {\n        this.newDirection = dir;\n    }\n    updateState() {\n        if (!this.gameOver) {\n            if (this.newDirection) {\n                if (!eqPoints(addPoints(this.direction, this.newDirection), { x: 0, y: 0 })) {\n                    this.direction = this.newDirection;\n                }\n                this.newDirection = null;\n            }\n            let nextPosition = addPoints(this.snake.head, this.direction);\n            nextPosition = {\n                x: mod(nextPosition.x, this.grid.cols),\n                y: mod(nextPosition.y, this.grid.rows),\n            };\n            this.grid.unmark(this.snake.head, 2 /* Head */);\n            const tail = this.snake.move(nextPosition);\n            if (tail) {\n                this.grid.unmark(tail, 1 /* Body */);\n            }\n            this.grid.mark(nextPosition, 2 /* Head */);\n            if (this.grid.isBodyAt(nextPosition)) {\n                this.gameOver = true;\n            }\n            else if (this.grid.isFoodAt(nextPosition)) {\n                this.snake.grow = 3;\n                this.grid.unmark(nextPosition, 4 /* Food */);\n                this.grid.createRandomFood();\n            }\n            this.grid.mark(nextPosition, 1 /* Body */);\n        }\n    }\n}\n","import { box, render, component, onKeyDown, AUTOFOCUS, Events, TrackByKey, key, _, } from \"ivi\";\nimport { div } from \"ivi-html\";\nimport { Game, LEFT, RIGHT, UP, DOWN } from \"./state\";\nfunction cellClassName(flags) {\n    if (flags & 1 /* Body */) {\n        if (flags & 2 /* Head */) {\n            return \"Cell body head\";\n        }\n        return \"Cell body\";\n    }\n    else if (flags & 4 /* Food */) {\n        return \"Cell food\";\n    }\n    return \"Cell\";\n}\nconst CELL_SIZE = 30;\nconst GameView = component(() => {\n    let game;\n    const keyDown = onKeyDown((ev) => {\n        switch (ev.native.keyCode) {\n            case 37 /* ArrowLeft */:\n                game.setNewDirection(LEFT);\n                return 1 /* PreventDefault */;\n            case 38 /* ArrowUp */:\n                game.setNewDirection(UP);\n                return 1 /* PreventDefault */;\n            case 39 /* ArrowRight */:\n                game.setNewDirection(RIGHT);\n                return 1 /* PreventDefault */;\n            case 40 /* ArrowDown */:\n                game.setNewDirection(DOWN);\n                return 1 /* PreventDefault */;\n        }\n        return;\n    });\n    return (props) => (game = props.v,\n        div(game.gameOver ? \"SnakeGame gameOver\" : \"SnakeGame\", _, Events(keyDown, div(\"Grid\", {\n            tabIndex: 0,\n            autofocus: AUTOFOCUS(true),\n            style: {\n                width: `${CELL_SIZE * game.grid.cols}px`,\n                height: `${CELL_SIZE * game.grid.rows}px`,\n            },\n        }, TrackByKey(game.grid.cells.map((c, i) => key(i, div(cellClassName(c)))))))));\n});\nconst CONTAINER = document.getElementById(\"app\");\nconst GAME = new Game();\nfunction tick() {\n    GAME.updateState();\n    render(GameView(box(GAME)), CONTAINER);\n    setTimeout(tick, 100);\n}\ntick();\n","/**\n * Shortcut for an `undefined` value.\n */\nexport const _ = void 0;\n"],"sourceRoot":""}